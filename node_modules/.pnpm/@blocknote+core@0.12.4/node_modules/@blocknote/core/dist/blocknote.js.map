{"version":3,"file":"blocknote.js","sources":["../src/extensions/UniqueID/UniqueID.ts","../src/api/getBlockInfoFromPos.ts","../src/schema/inlineContent/types.ts","../src/util/typescript.ts","../src/api/nodeConversions/nodeConversions.ts","../src/api/exporters/html/util/sharedHTMLConversion.ts","../src/api/exporters/html/util/simplifyBlocksRehypePlugin.ts","../src/api/exporters/html/externalHTMLExporter.ts","../src/api/exporters/html/internalHTMLSerializer.ts","../src/blocks/ImageBlockContent/uploadToTmpFilesDotOrg_DEV_ONLY.ts","../src/util/browser.ts","../src/blocks/defaultBlockHelpers.ts","../src/blocks/defaultProps.ts","../src/util/string.ts","../src/schema/blocks/internal.ts","../src/schema/blocks/createSpec.ts","../src/schema/inlineContent/internal.ts","../src/schema/inlineContent/createSpec.ts","../src/schema/styles/internal.ts","../src/schema/styles/createSpec.ts","../src/extensions/BackgroundColor/BackgroundColorMark.ts","../src/extensions/TextColor/TextColorMark.ts","../src/api/getCurrentBlockContentType.ts","../src/blocks/HeadingBlockContent/HeadingBlockContent.ts","../src/blocks/ImageBlockContent/ImageBlockContent.ts","../src/blocks/ListItemBlockContent/ListItemKeyboardShortcuts.ts","../src/blocks/ListItemBlockContent/BulletListItemBlockContent/BulletListItemBlockContent.ts","../src/blocks/ListItemBlockContent/NumberedListItemBlockContent/NumberedListIndexingPlugin.ts","../src/blocks/ListItemBlockContent/NumberedListItemBlockContent/NumberedListItemBlockContent.ts","../src/blocks/ParagraphBlockContent/ParagraphBlockContent.ts","../src/blocks/TableBlockContent/TableExtension.ts","../src/blocks/TableBlockContent/TableBlockContent.ts","../src/blocks/defaultBlocks.ts","../src/blocks/defaultBlockTypeGuards.ts","../src/api/nodeUtil.ts","../src/api/blockManipulation/blockManipulation.ts","../src/api/exporters/markdown/removeUnderlinesRehypePlugin.ts","../src/api/exporters/markdown/markdownExporter.ts","../src/api/parsers/html/util/nestedLists.ts","../src/api/parsers/html/parseHTML.ts","../src/api/parsers/markdown/parseMarkdown.ts","../src/util/EventEmitter.ts","../src/extensions/FormattingToolbar/FormattingToolbarPlugin.ts","../src/extensions/LinkToolbar/LinkToolbarPlugin.ts","../src/extensions/SuggestionMenu/SuggestionPlugin.ts","../src/extensions/SideMenu/MultipleNodeSelection.ts","../src/extensions/SideMenu/SideMenuPlugin.ts","../src/extensions/ImagePanel/ImageToolbarPlugin.ts","../src/extensions/TableHandles/TableHandlesPlugin.ts","../src/api/exporters/copyExtension.ts","../src/api/parsers/pasteExtension.ts","../src/extensions/BackgroundColor/BackgroundColorExtension.ts","../src/extensions/Placeholder/PlaceholderExtension.ts","../src/extensions/TextAlignment/TextAlignmentExtension.ts","../src/extensions/TextColor/TextColorExtension.ts","../src/extensions/TrailingNode/TrailingNodeExtension.ts","../src/extensions/NonEditableBlocks/NonEditableBlockPlugin.ts","../src/extensions/PreviousBlockType/PreviousBlockTypePlugin.ts","../src/pm-nodes/BlockContainer.ts","../src/pm-nodes/BlockGroup.ts","../src/pm-nodes/Doc.ts","../src/editor/BlockNoteExtensions.ts","../src/editor/transformPasted.ts","../src/editor/BlockNoteSchema.ts","../src/editor/BlockNoteTipTapEditor.ts","../src/editor/BlockNoteEditor.ts","../src/extensions/SuggestionMenu/getDefaultSlashMenuItems.ts","../src/api/testUtil/partialBlockTestUtil.ts"],"sourcesContent":["import {\n  combineTransactionSteps,\n  Extension,\n  findChildrenInRange,\n  getChangedRanges,\n} from \"@tiptap/core\";\nimport { Fragment, Slice } from \"prosemirror-model\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\nimport { v4 } from \"uuid\";\n\n/**\n * Code from Tiptap UniqueID extension (https://tiptap.dev/api/extensions/unique-id)\n * This extension is licensed under MIT (even though it's part of Tiptap pro).\n *\n * If you're a user of BlockNote, we still recommend to support their awesome work and become a sponsor!\n * https://tiptap.dev/pro\n */\n\n/**\n * Removes duplicated values within an array.\n * Supports numbers, strings and objects.\n */\nfunction removeDuplicates(array: any, by = JSON.stringify) {\n  const seen: any = {};\n  return array.filter((item: any) => {\n    const key = by(item);\n    return Object.prototype.hasOwnProperty.call(seen, key)\n      ? false\n      : (seen[key] = true);\n  });\n}\n\n/**\n * Returns a list of duplicated items within an array.\n */\nfunction findDuplicates(items: any) {\n  const filtered = items.filter(\n    (el: any, index: number) => items.indexOf(el) !== index\n  );\n  const duplicates = removeDuplicates(filtered);\n  return duplicates;\n}\n\nconst UniqueID = Extension.create({\n  name: \"uniqueID\",\n  // we’ll set a very high priority to make sure this runs first\n  // and is compatible with `appendTransaction` hooks of other extensions\n  priority: 10000,\n  addOptions() {\n    return {\n      attributeName: \"id\",\n      types: [],\n      generateID: () => {\n        // Use mock ID if tests are running.\n        if (typeof window !== \"undefined\" && (window as any).__TEST_OPTIONS) {\n          const testOptions = (window as any).__TEST_OPTIONS;\n          if (testOptions.mockID === undefined) {\n            testOptions.mockID = 0;\n          } else {\n            testOptions.mockID++;\n          }\n\n          return testOptions.mockID.toString() as string;\n        }\n\n        return v4();\n      },\n      filterTransaction: null,\n    };\n  },\n  addGlobalAttributes() {\n    return [\n      {\n        types: this.options.types,\n        attributes: {\n          [this.options.attributeName]: {\n            default: null,\n            parseHTML: (element) =>\n              element.getAttribute(`data-${this.options.attributeName}`),\n            renderHTML: (attributes) => ({\n              [`data-${this.options.attributeName}`]:\n                attributes[this.options.attributeName],\n            }),\n          },\n        },\n      },\n    ];\n  },\n  // check initial content for missing ids\n  // onCreate() {\n  //   // Don’t do this when the collaboration extension is active\n  //   // because this may update the content, so Y.js tries to merge these changes.\n  //   // This leads to empty block nodes.\n  //   // See: https://github.com/ueberdosis/tiptap/issues/2400\n  //   if (\n  //     this.editor.extensionManager.extensions.find(\n  //       (extension) => extension.name === \"collaboration\"\n  //     )\n  //   ) {\n  //     return;\n  //   }\n  //   const { view, state } = this.editor;\n  //   const { tr, doc } = state;\n  //   const { types, attributeName, generateID } = this.options;\n  //   const nodesWithoutId = findChildren(doc, (node) => {\n  //     return (\n  //       types.includes(node.type.name) && node.attrs[attributeName] === null\n  //     );\n  //   });\n  //   nodesWithoutId.forEach(({ node, pos }) => {\n  //     tr.setNodeMarkup(pos, undefined, {\n  //       ...node.attrs,\n  //       [attributeName]: generateID(),\n  //     });\n  //   });\n  //   tr.setMeta(\"addToHistory\", false);\n  //   view.dispatch(tr);\n  // },\n  addProseMirrorPlugins() {\n    let dragSourceElement: any = null;\n    let transformPasted = false;\n    return [\n      new Plugin({\n        key: new PluginKey(\"uniqueID\"),\n        appendTransaction: (transactions, oldState, newState) => {\n          // console.log(\"appendTransaction\");\n          const docChanges =\n            transactions.some((transaction) => transaction.docChanged) &&\n            !oldState.doc.eq(newState.doc);\n          const filterTransactions =\n            this.options.filterTransaction &&\n            transactions.some((tr) => {\n              let _a, _b;\n              return !((_b = (_a = this.options).filterTransaction) === null ||\n              _b === void 0\n                ? void 0\n                : _b.call(_a, tr));\n            });\n          if (!docChanges || filterTransactions) {\n            return;\n          }\n          const { tr } = newState;\n          const { types, attributeName, generateID } = this.options;\n          const transform = combineTransactionSteps(\n            oldState.doc,\n            transactions as any\n          );\n          const { mapping } = transform;\n          // get changed ranges based on the old state\n          const changes = getChangedRanges(transform);\n\n          changes.forEach(({ newRange }) => {\n            const newNodes = findChildrenInRange(\n              newState.doc,\n              newRange,\n              (node) => {\n                return types.includes(node.type.name);\n              }\n            );\n            const newIds = newNodes\n              .map(({ node }) => node.attrs[attributeName])\n              .filter((id) => id !== null);\n            const duplicatedNewIds = findDuplicates(newIds);\n            newNodes.forEach(({ node, pos }) => {\n              let _a;\n              // instead of checking `node.attrs[attributeName]` directly\n              // we look at the current state of the node within `tr.doc`.\n              // this helps to prevent adding new ids to the same node\n              // if the node changed multiple times within one transaction\n              const id =\n                (_a = tr.doc.nodeAt(pos)) === null || _a === void 0\n                  ? void 0\n                  : _a.attrs[attributeName];\n              if (id === null) {\n                // edge case, when using collaboration, yjs will set the id to null in `_forceRerender`\n                // when loading the editor\n                // this checks for this case and keeps it at initialBlockId so there will be no change\n                const initialDoc = oldState.doc.type.createAndFill()!.content;\n                const wasInitial =\n                  oldState.doc.content.findDiffStart(initialDoc) === null;\n\n                if (wasInitial) {\n                  // the old state was the \"initial content\"\n                  const jsonNode = JSON.parse(\n                    JSON.stringify(newState.doc.toJSON())\n                  );\n                  jsonNode.content[0].content[0].attrs.id = \"initialBlockId\";\n                  // would the new state with the fix also be the \"initial content\"?\n                  if (\n                    JSON.stringify(jsonNode.content) ===\n                    JSON.stringify(initialDoc.toJSON())\n                  ) {\n                    // yes, apply the fix\n                    tr.setNodeMarkup(pos, undefined, {\n                      ...node.attrs,\n                      [attributeName]: \"initialBlockId\",\n                    });\n                    return;\n                  }\n                }\n\n                tr.setNodeMarkup(pos, undefined, {\n                  ...node.attrs,\n                  [attributeName]: generateID(),\n                });\n                return;\n              }\n              // check if the node doesn’t exist in the old state\n              const { deleted } = mapping.invert().mapResult(pos);\n              const newNode = deleted && duplicatedNewIds.includes(id);\n              if (newNode) {\n                tr.setNodeMarkup(pos, undefined, {\n                  ...node.attrs,\n                  [attributeName]: generateID(),\n                });\n              }\n            });\n          });\n          if (!tr.steps.length) {\n            return;\n          }\n          return tr;\n        },\n        // we register a global drag handler to track the current drag source element\n        view(view) {\n          const handleDragstart = (event: any) => {\n            let _a;\n            dragSourceElement = (\n              (_a = view.dom.parentElement) === null || _a === void 0\n                ? void 0\n                : _a.contains(event.target)\n            )\n              ? view.dom.parentElement\n              : null;\n          };\n          window.addEventListener(\"dragstart\", handleDragstart);\n          return {\n            destroy() {\n              window.removeEventListener(\"dragstart\", handleDragstart);\n            },\n          };\n        },\n        props: {\n          // `handleDOMEvents` is called before `transformPasted`\n          // so we can do some checks before\n          handleDOMEvents: {\n            // only create new ids for dropped content while holding `alt`\n            // or content is dragged from another editor\n            drop: (view, event: any) => {\n              let _a;\n              if (\n                dragSourceElement !== view.dom.parentElement ||\n                ((_a = event.dataTransfer) === null || _a === void 0\n                  ? void 0\n                  : _a.effectAllowed) === \"copy\"\n              ) {\n                dragSourceElement = null;\n                transformPasted = true;\n              }\n              return false;\n            },\n            // always create new ids on pasted content\n            paste: () => {\n              transformPasted = true;\n              return false;\n            },\n          },\n          // we’ll remove ids for every pasted node\n          // so we can create a new one within `appendTransaction`\n          transformPasted: (slice) => {\n            if (!transformPasted) {\n              return slice;\n            }\n            const { types, attributeName } = this.options;\n            const removeId = (fragment: any) => {\n              const list: any[] = [];\n              fragment.forEach((node: any) => {\n                // don’t touch text nodes\n                if (node.isText) {\n                  list.push(node);\n                  return;\n                }\n                // check for any other child nodes\n                if (!types.includes(node.type.name)) {\n                  list.push(node.copy(removeId(node.content)));\n                  return;\n                }\n                // remove id\n                const nodeWithoutId = node.type.create(\n                  {\n                    ...node.attrs,\n                    [attributeName]: null,\n                  },\n                  removeId(node.content),\n                  node.marks\n                );\n                list.push(nodeWithoutId);\n              });\n              return Fragment.from(list);\n            };\n            // reset check\n            transformPasted = false;\n            return new Slice(\n              removeId(slice.content),\n              slice.openStart,\n              slice.openEnd\n            );\n          },\n        },\n      }),\n    ];\n  },\n});\n\nexport { UniqueID as default, UniqueID };\n","import { Node, NodeType } from \"prosemirror-model\";\n\nexport type BlockInfoWithoutPositions = {\n  id: string;\n  node: Node;\n  contentNode: Node;\n  contentType: NodeType;\n  numChildBlocks: number;\n};\n\nexport type BlockInfo = BlockInfoWithoutPositions & {\n  startPos: number;\n  endPos: number;\n  depth: number;\n};\n\n/**\n * Helper function for `getBlockInfoFromPos`, returns information regarding\n * provided blockContainer node.\n * @param blockContainer The blockContainer node to retrieve info for.\n */\nexport function getBlockInfo(blockContainer: Node): BlockInfoWithoutPositions {\n  const id = blockContainer.attrs[\"id\"];\n  const contentNode = blockContainer.firstChild!;\n  const contentType = contentNode.type;\n  const numChildBlocks =\n    blockContainer.childCount === 2 ? blockContainer.lastChild!.childCount : 0;\n\n  return {\n    id,\n    node: blockContainer,\n    contentNode,\n    contentType,\n    numChildBlocks,\n  };\n}\n\n/**\n * Retrieves information regarding the nearest blockContainer node in a\n * ProseMirror doc, relative to a position.\n * @param doc The ProseMirror doc.\n * @param pos An integer position.\n * @returns A BlockInfo object for the nearest blockContainer node.\n */\nexport function getBlockInfoFromPos(doc: Node, pos: number): BlockInfo {\n  // If the position is outside the outer block group, we need to move it to the\n  // nearest block. This happens when the collaboration plugin is active, where\n  // the selection is placed at the very end of the doc.\n  const outerBlockGroupStartPos = 1;\n  const outerBlockGroupEndPos = doc.nodeSize - 2;\n  if (pos <= outerBlockGroupStartPos) {\n    pos = outerBlockGroupStartPos + 1;\n\n    while (\n      doc.resolve(pos).parent.type.name !== \"blockContainer\" &&\n      pos < outerBlockGroupEndPos\n    ) {\n      pos++;\n    }\n  } else if (pos >= outerBlockGroupEndPos) {\n    pos = outerBlockGroupEndPos - 1;\n\n    while (\n      doc.resolve(pos).parent.type.name !== \"blockContainer\" &&\n      pos > outerBlockGroupStartPos\n    ) {\n      pos--;\n    }\n  }\n\n  // This gets triggered when a node selection on a block is active, i.e. when\n  // you drag and drop a block.\n  if (doc.resolve(pos).parent.type.name === \"blockGroup\") {\n    pos++;\n  }\n\n  const $pos = doc.resolve(pos);\n\n  const maxDepth = $pos.depth;\n  let node = $pos.node(maxDepth);\n  let depth = maxDepth;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (depth < 0) {\n      throw new Error(\n        \"Could not find blockContainer node. This can only happen if the underlying BlockNote schema has been edited.\"\n      );\n    }\n\n    if (node.type.name === \"blockContainer\") {\n      break;\n    }\n\n    depth -= 1;\n    node = $pos.node(depth);\n  }\n\n  const { id, contentNode, contentType, numChildBlocks } = getBlockInfo(node);\n\n  const startPos = $pos.start(depth);\n  const endPos = $pos.end(depth);\n\n  return {\n    id,\n    node,\n    contentNode,\n    contentType,\n    numChildBlocks,\n    startPos,\n    endPos,\n    depth,\n  };\n}\n","import { Node } from \"@tiptap/core\";\nimport { PropSchema, Props } from \"../propTypes\";\nimport { StyleSchema, Styles } from \"../styles/types\";\n\nexport type CustomInlineContentConfig = {\n  type: string;\n  content: \"styled\" | \"none\"; // | \"plain\"\n  readonly propSchema: PropSchema;\n  // content: \"inline\" | \"none\" | \"table\";\n};\n// InlineContentConfig contains the \"schema\" info about an InlineContent type\n// i.e. what props it supports, what content it supports, etc.\nexport type InlineContentConfig = CustomInlineContentConfig | \"text\" | \"link\";\n\n// InlineContentImplementation contains the \"implementation\" info about an InlineContent element\n// such as the functions / Nodes required to render and / or serialize it\n// @ts-ignore\nexport type InlineContentImplementation<T extends InlineContentConfig> =\n  T extends \"link\" | \"text\"\n    ? undefined\n    : {\n        node: Node;\n      };\n\n// Container for both the config and implementation of InlineContent,\n// and the type of `implementation` is based on that of the config\nexport type InlineContentSpec<T extends InlineContentConfig> = {\n  config: T;\n  implementation: InlineContentImplementation<T>;\n};\n\n// A Schema contains all the types (Configs) supported in an editor\n// The keys are the \"type\" of InlineContent elements\nexport type InlineContentSchema = Record<string, InlineContentConfig>;\n\nexport type InlineContentSpecs = {\n  text: { config: \"text\"; implementation: undefined };\n  link: { config: \"link\"; implementation: undefined };\n} & Record<string, InlineContentSpec<InlineContentConfig>>;\n\nexport type InlineContentSchemaFromSpecs<T extends InlineContentSpecs> = {\n  [K in keyof T]: T[K][\"config\"];\n};\n\nexport type CustomInlineContentFromConfig<\n  I extends CustomInlineContentConfig,\n  S extends StyleSchema\n> = {\n  type: I[\"type\"];\n  props: Props<I[\"propSchema\"]>;\n  content: I[\"content\"] extends \"styled\"\n    ? StyledText<S>[]\n    : I[\"content\"] extends \"plain\"\n    ? string\n    : I[\"content\"] extends \"none\"\n    ? undefined\n    : never;\n};\n\nexport type InlineContentFromConfig<\n  I extends InlineContentConfig,\n  S extends StyleSchema\n> = I extends \"text\"\n  ? StyledText<S>\n  : I extends \"link\"\n  ? Link<S>\n  : I extends CustomInlineContentConfig\n  ? CustomInlineContentFromConfig<I, S>\n  : never;\n\nexport type PartialCustomInlineContentFromConfig<\n  I extends CustomInlineContentConfig,\n  S extends StyleSchema\n> = {\n  type: I[\"type\"];\n  props?: Props<I[\"propSchema\"]>;\n  content?: I[\"content\"] extends \"styled\"\n    ? StyledText<S>[] | string\n    : I[\"content\"] extends \"plain\"\n    ? string\n    : I[\"content\"] extends \"none\"\n    ? undefined\n    : never;\n};\n\nexport type PartialInlineContentFromConfig<\n  I extends InlineContentConfig,\n  S extends StyleSchema\n> = I extends \"text\"\n  ? string | StyledText<S>\n  : I extends \"link\"\n  ? PartialLink<S>\n  : I extends CustomInlineContentConfig\n  ? PartialCustomInlineContentFromConfig<I, S>\n  : never;\n\nexport type StyledText<T extends StyleSchema> = {\n  type: \"text\";\n  text: string;\n  styles: Styles<T>;\n};\n\nexport type Link<T extends StyleSchema> = {\n  type: \"link\";\n  href: string;\n  content: StyledText<T>[];\n};\n\nexport type PartialLink<T extends StyleSchema> = Omit<Link<T>, \"content\"> & {\n  content: string | Link<T>[\"content\"];\n};\n\nexport type InlineContent<\n  I extends InlineContentSchema,\n  T extends StyleSchema\n> = InlineContentFromConfig<I[keyof I], T>;\n\ntype PartialInlineContentElement<\n  I extends InlineContentSchema,\n  T extends StyleSchema\n> = PartialInlineContentFromConfig<I[keyof I], T>;\n\nexport type PartialInlineContent<\n  I extends InlineContentSchema,\n  T extends StyleSchema\n> = PartialInlineContentElement<I, T>[] | string;\n\nexport function isLinkInlineContent<T extends StyleSchema>(\n  content: InlineContent<any, T>\n): content is Link<T> {\n  return content.type === \"link\";\n}\n\nexport function isPartialLinkInlineContent<T extends StyleSchema>(\n  content: PartialInlineContentElement<any, T>\n): content is PartialLink<T> {\n  return typeof content !== \"string\" && content.type === \"link\";\n}\n\nexport function isStyledTextInlineContent<T extends StyleSchema>(\n  content: PartialInlineContentElement<any, T>\n): content is StyledText<T> {\n  return typeof content !== \"string\" && content.type === \"text\";\n}\n","export class UnreachableCaseError extends Error {\n  constructor(val: never) {\n    super(`Unreachable case: ${val}`);\n  }\n}\n\n// TODO: change for built-in version of typescript 5.4 after upgrade\nexport type NoInfer<T> = [T][T extends any ? 0 : never];\n","import { Mark, Node, Schema } from \"@tiptap/pm/model\";\n\nimport UniqueID from \"../../extensions/UniqueID/UniqueID\";\nimport type {\n  BlockSchema,\n  CustomInlineContentConfig,\n  CustomInlineContentFromConfig,\n  InlineContent,\n  InlineContentFromConfig,\n  InlineContentSchema,\n  PartialCustomInlineContentFromConfig,\n  PartialInlineContent,\n  PartialLink,\n  PartialTableContent,\n  StyleSchema,\n  StyledText,\n  Styles,\n  TableContent,\n} from \"../../schema\";\nimport { getBlockInfo } from \"../getBlockInfoFromPos\";\n\nimport type { Block, PartialBlock } from \"../../blocks/defaultBlocks\";\nimport {\n  isLinkInlineContent,\n  isPartialLinkInlineContent,\n  isStyledTextInlineContent,\n} from \"../../schema/inlineContent/types\";\nimport { UnreachableCaseError } from \"../../util/typescript\";\n\n/**\n * Convert a StyledText inline element to a\n * prosemirror text node with the appropriate marks\n */\nfunction styledTextToNodes<T extends StyleSchema>(\n  styledText: StyledText<T>,\n  schema: Schema,\n  styleSchema: T\n): Node[] {\n  const marks: Mark[] = [];\n\n  for (const [style, value] of Object.entries(styledText.styles)) {\n    const config = styleSchema[style];\n    if (!config) {\n      throw new Error(`style ${style} not found in styleSchema`);\n    }\n\n    if (config.propSchema === \"boolean\") {\n      marks.push(schema.mark(style));\n    } else if (config.propSchema === \"string\") {\n      marks.push(schema.mark(style, { stringValue: value }));\n    } else {\n      throw new UnreachableCaseError(config.propSchema);\n    }\n  }\n\n  return (\n    styledText.text\n      // Splits text & line breaks.\n      .split(/(\\n)/g)\n      // If the content ends with a line break, an empty string is added to the\n      // end, which this removes.\n      .filter((text) => text.length > 0)\n      // Converts text & line breaks to nodes.\n      .map((text) => {\n        if (text === \"\\n\") {\n          return schema.nodes[\"hardBreak\"].create();\n        } else {\n          return schema.text(text, marks);\n        }\n      })\n  );\n}\n\n/**\n * Converts a Link inline content element to\n * prosemirror text nodes with the appropriate marks\n */\nfunction linkToNodes(\n  link: PartialLink<StyleSchema>,\n  schema: Schema,\n  styleSchema: StyleSchema\n): Node[] {\n  const linkMark = schema.marks.link.create({\n    href: link.href,\n  });\n\n  return styledTextArrayToNodes(link.content, schema, styleSchema).map(\n    (node) => {\n      if (node.type.name === \"text\") {\n        return node.mark([...node.marks, linkMark]);\n      }\n\n      if (node.type.name === \"hardBreak\") {\n        return node;\n      }\n      throw new Error(\"unexpected node type\");\n    }\n  );\n}\n\n/**\n * Converts an array of StyledText inline content elements to\n * prosemirror text nodes with the appropriate marks\n */\nfunction styledTextArrayToNodes<S extends StyleSchema>(\n  content: string | StyledText<S>[],\n  schema: Schema,\n  styleSchema: S\n): Node[] {\n  const nodes: Node[] = [];\n\n  if (typeof content === \"string\") {\n    nodes.push(\n      ...styledTextToNodes(\n        { type: \"text\", text: content, styles: {} },\n        schema,\n        styleSchema\n      )\n    );\n    return nodes;\n  }\n\n  for (const styledText of content) {\n    nodes.push(...styledTextToNodes(styledText, schema, styleSchema));\n  }\n  return nodes;\n}\n\n/**\n * converts an array of inline content elements to prosemirror nodes\n */\nexport function inlineContentToNodes<\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  blockContent: PartialInlineContent<I, S>,\n  schema: Schema,\n  styleSchema: S\n): Node[] {\n  const nodes: Node[] = [];\n\n  for (const content of blockContent) {\n    if (typeof content === \"string\") {\n      nodes.push(...styledTextArrayToNodes(content, schema, styleSchema));\n    } else if (isPartialLinkInlineContent(content)) {\n      nodes.push(...linkToNodes(content, schema, styleSchema));\n    } else if (isStyledTextInlineContent(content)) {\n      nodes.push(...styledTextArrayToNodes([content], schema, styleSchema));\n    } else {\n      nodes.push(\n        blockOrInlineContentToContentNode(content, schema, styleSchema)\n      );\n    }\n  }\n  return nodes;\n}\n\n/**\n * converts an array of inline content elements to prosemirror nodes\n */\nexport function tableContentToNodes<\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  tableContent: PartialTableContent<I, S>,\n  schema: Schema,\n  styleSchema: StyleSchema\n): Node[] {\n  const rowNodes: Node[] = [];\n\n  for (const row of tableContent.rows) {\n    const columnNodes: Node[] = [];\n    for (const cell of row.cells) {\n      let pNode: Node;\n      if (!cell) {\n        pNode = schema.nodes[\"tableParagraph\"].create({});\n      } else if (typeof cell === \"string\") {\n        pNode = schema.nodes[\"tableParagraph\"].create({}, schema.text(cell));\n      } else {\n        const textNodes = inlineContentToNodes(cell, schema, styleSchema);\n        pNode = schema.nodes[\"tableParagraph\"].create({}, textNodes);\n      }\n\n      const cellNode = schema.nodes[\"tableCell\"].create({}, pNode);\n      columnNodes.push(cellNode);\n    }\n    const rowNode = schema.nodes[\"tableRow\"].create({}, columnNodes);\n    rowNodes.push(rowNode);\n  }\n  return rowNodes;\n}\n\nfunction blockOrInlineContentToContentNode(\n  block:\n    | PartialBlock<any, any, any>\n    | PartialCustomInlineContentFromConfig<any, any>,\n  schema: Schema,\n  styleSchema: StyleSchema\n) {\n  let contentNode: Node;\n  let type = block.type;\n\n  // TODO: needed? came from previous code\n  if (type === undefined) {\n    type = \"paragraph\";\n  }\n\n  if (!schema.nodes[type]) {\n    throw new Error(`node type ${type} not found in schema`);\n  }\n\n  if (!block.content) {\n    contentNode = schema.nodes[type].create(block.props);\n  } else if (typeof block.content === \"string\") {\n    contentNode = schema.nodes[type].create(\n      block.props,\n      schema.text(block.content)\n    );\n  } else if (Array.isArray(block.content)) {\n    const nodes = inlineContentToNodes(block.content, schema, styleSchema);\n    contentNode = schema.nodes[type].create(block.props, nodes);\n  } else if (block.content.type === \"tableContent\") {\n    const nodes = tableContentToNodes(block.content, schema, styleSchema);\n    contentNode = schema.nodes[type].create(block.props, nodes);\n  } else {\n    throw new UnreachableCaseError(block.content.type);\n  }\n  return contentNode;\n}\n/**\n * Converts a BlockNote block to a TipTap node.\n */\nexport function blockToNode(\n  block: PartialBlock<any, any, any>,\n  schema: Schema,\n  styleSchema: StyleSchema\n) {\n  let id = block.id;\n\n  if (id === undefined) {\n    id = UniqueID.options.generateID();\n  }\n\n  const contentNode = blockOrInlineContentToContentNode(\n    block,\n    schema,\n    styleSchema\n  );\n\n  const children: Node[] = [];\n\n  if (block.children) {\n    for (const child of block.children) {\n      children.push(blockToNode(child, schema, styleSchema));\n    }\n  }\n\n  const groupNode = schema.nodes[\"blockGroup\"].create({}, children);\n\n  return schema.nodes[\"blockContainer\"].create(\n    {\n      id: id,\n      ...block.props,\n    },\n    children.length > 0 ? [contentNode, groupNode] : contentNode\n  );\n}\n\n/**\n * Converts an internal (prosemirror) table node contentto a BlockNote Tablecontent\n */\nfunction contentNodeToTableContent<\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(contentNode: Node, inlineContentSchema: I, styleSchema: S) {\n  const ret: TableContent<I, S> = {\n    type: \"tableContent\",\n    rows: [],\n  };\n\n  contentNode.content.forEach((rowNode) => {\n    const row: TableContent<I, S>[\"rows\"][0] = {\n      cells: [],\n    };\n\n    rowNode.content.forEach((cellNode) => {\n      row.cells.push(\n        contentNodeToInlineContent(\n          cellNode.firstChild!,\n          inlineContentSchema,\n          styleSchema\n        )\n      );\n    });\n\n    ret.rows.push(row);\n  });\n\n  return ret;\n}\n\n/**\n * Converts an internal (prosemirror) content node to a BlockNote InlineContent array.\n */\nexport function contentNodeToInlineContent<\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(contentNode: Node, inlineContentSchema: I, styleSchema: S) {\n  const content: InlineContent<any, S>[] = [];\n  let currentContent: InlineContent<any, S> | undefined = undefined;\n\n  // Most of the logic below is for handling links because in ProseMirror links are marks\n  // while in BlockNote links are a type of inline content\n  contentNode.content.forEach((node) => {\n    // hardBreak nodes do not have an InlineContent equivalent, instead we\n    // add a newline to the previous node.\n    if (node.type.name === \"hardBreak\") {\n      if (currentContent) {\n        // Current content exists.\n        if (isStyledTextInlineContent(currentContent)) {\n          // Current content is text.\n          currentContent.text += \"\\n\";\n        } else if (isLinkInlineContent(currentContent)) {\n          // Current content is a link.\n          currentContent.content[currentContent.content.length - 1].text +=\n            \"\\n\";\n        } else {\n          throw new Error(\"unexpected\");\n        }\n      } else {\n        // Current content does not exist.\n        currentContent = {\n          type: \"text\",\n          text: \"\\n\",\n          styles: {},\n        };\n      }\n\n      return;\n    }\n\n    if (\n      node.type.name !== \"link\" &&\n      node.type.name !== \"text\" &&\n      inlineContentSchema[node.type.name]\n    ) {\n      if (currentContent) {\n        content.push(currentContent);\n        currentContent = undefined;\n      }\n\n      content.push(\n        nodeToCustomInlineContent(node, inlineContentSchema, styleSchema)\n      );\n\n      return;\n    }\n\n    const styles: Styles<S> = {};\n    let linkMark: Mark | undefined;\n\n    for (const mark of node.marks) {\n      if (mark.type.name === \"link\") {\n        linkMark = mark;\n      } else {\n        const config = styleSchema[mark.type.name];\n        if (!config) {\n          throw new Error(`style ${mark.type.name} not found in styleSchema`);\n        }\n        if (config.propSchema === \"boolean\") {\n          (styles as any)[config.type] = true;\n        } else if (config.propSchema === \"string\") {\n          (styles as any)[config.type] = mark.attrs.stringValue;\n        } else {\n          throw new UnreachableCaseError(config.propSchema);\n        }\n      }\n    }\n\n    // Parsing links and text.\n    // Current content exists.\n    if (currentContent) {\n      // Current content is text.\n      if (isStyledTextInlineContent(currentContent)) {\n        if (!linkMark) {\n          // Node is text (same type as current content).\n          if (\n            JSON.stringify(currentContent.styles) === JSON.stringify(styles)\n          ) {\n            // Styles are the same.\n            currentContent.text += node.textContent;\n          } else {\n            // Styles are different.\n            content.push(currentContent);\n            currentContent = {\n              type: \"text\",\n              text: node.textContent,\n              styles,\n            };\n          }\n        } else {\n          // Node is a link (different type to current content).\n          content.push(currentContent);\n          currentContent = {\n            type: \"link\",\n            href: linkMark.attrs.href,\n            content: [\n              {\n                type: \"text\",\n                text: node.textContent,\n                styles,\n              },\n            ],\n          };\n        }\n      } else if (isLinkInlineContent(currentContent)) {\n        // Current content is a link.\n        if (linkMark) {\n          // Node is a link (same type as current content).\n          // Link URLs are the same.\n          if (currentContent.href === linkMark.attrs.href) {\n            // Styles are the same.\n            if (\n              JSON.stringify(\n                currentContent.content[currentContent.content.length - 1].styles\n              ) === JSON.stringify(styles)\n            ) {\n              currentContent.content[currentContent.content.length - 1].text +=\n                node.textContent;\n            } else {\n              // Styles are different.\n              currentContent.content.push({\n                type: \"text\",\n                text: node.textContent,\n                styles,\n              });\n            }\n          } else {\n            // Link URLs are different.\n            content.push(currentContent);\n            currentContent = {\n              type: \"link\",\n              href: linkMark.attrs.href,\n              content: [\n                {\n                  type: \"text\",\n                  text: node.textContent,\n                  styles,\n                },\n              ],\n            };\n          }\n        } else {\n          // Node is text (different type to current content).\n          content.push(currentContent);\n          currentContent = {\n            type: \"text\",\n            text: node.textContent,\n            styles,\n          };\n        }\n      } else {\n        // TODO\n      }\n    }\n    // Current content does not exist.\n    else {\n      // Node is text.\n      if (!linkMark) {\n        currentContent = {\n          type: \"text\",\n          text: node.textContent,\n          styles,\n        };\n      }\n      // Node is a link.\n      else {\n        currentContent = {\n          type: \"link\",\n          href: linkMark.attrs.href,\n          content: [\n            {\n              type: \"text\",\n              text: node.textContent,\n              styles,\n            },\n          ],\n        };\n      }\n    }\n  });\n\n  if (currentContent) {\n    content.push(currentContent);\n  }\n\n  return content as InlineContent<I, S>[];\n}\n\nexport function nodeToCustomInlineContent<\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(node: Node, inlineContentSchema: I, styleSchema: S): InlineContent<I, S> {\n  if (node.type.name === \"text\" || node.type.name === \"link\") {\n    throw new Error(\"unexpected\");\n  }\n  const props: any = {};\n  const icConfig = inlineContentSchema[\n    node.type.name\n  ] as CustomInlineContentConfig;\n  for (const [attr, value] of Object.entries(node.attrs)) {\n    if (!icConfig) {\n      throw Error(\"ic node is of an unrecognized type: \" + node.type.name);\n    }\n\n    const propSchema = icConfig.propSchema;\n\n    if (attr in propSchema) {\n      props[attr] = value;\n    }\n  }\n\n  let content: CustomInlineContentFromConfig<any, any>[\"content\"];\n\n  if (icConfig.content === \"styled\") {\n    content = contentNodeToInlineContent(\n      node,\n      inlineContentSchema,\n      styleSchema\n    ) as any; // TODO: is this safe? could we have Links here that are undesired?\n  } else {\n    content = undefined;\n  }\n\n  const ic = {\n    type: node.type.name,\n    props,\n    content,\n  } as InlineContentFromConfig<I[keyof I], S>;\n  return ic;\n}\n\n/**\n * Convert a TipTap node to a BlockNote block.\n */\nexport function nodeToBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  node: Node,\n  blockSchema: BSchema,\n  inlineContentSchema: I,\n  styleSchema: S,\n  blockCache?: WeakMap<Node, Block<BSchema, I, S>>\n): Block<BSchema, I, S> {\n  if (node.type.name !== \"blockContainer\") {\n    throw Error(\n      \"Node must be of type blockContainer, but is of type\" +\n        node.type.name +\n        \".\"\n    );\n  }\n\n  const cachedBlock = blockCache?.get(node);\n\n  if (cachedBlock) {\n    return cachedBlock;\n  }\n\n  const blockInfo = getBlockInfo(node);\n\n  let id = blockInfo.id;\n\n  // Only used for blocks converted from other formats.\n  if (id === null) {\n    id = UniqueID.options.generateID();\n  }\n\n  const props: any = {};\n  for (const [attr, value] of Object.entries({\n    ...node.attrs,\n    ...blockInfo.contentNode.attrs,\n  })) {\n    const blockSpec = blockSchema[blockInfo.contentType.name];\n\n    if (!blockSpec) {\n      throw Error(\n        \"Block is of an unrecognized type: \" + blockInfo.contentType.name\n      );\n    }\n\n    const propSchema = blockSpec.propSchema;\n\n    if (attr in propSchema) {\n      props[attr] = value;\n    }\n  }\n\n  const blockConfig = blockSchema[blockInfo.contentType.name];\n\n  const children: Block<BSchema, I, S>[] = [];\n  for (let i = 0; i < blockInfo.numChildBlocks; i++) {\n    children.push(\n      nodeToBlock(\n        node.lastChild!.child(i),\n        blockSchema,\n        inlineContentSchema,\n        styleSchema,\n        blockCache\n      )\n    );\n  }\n\n  let content: Block<any, any, any>[\"content\"];\n\n  if (blockConfig.content === \"inline\") {\n    content = contentNodeToInlineContent(\n      blockInfo.contentNode,\n      inlineContentSchema,\n      styleSchema\n    );\n  } else if (blockConfig.content === \"table\") {\n    content = contentNodeToTableContent(\n      blockInfo.contentNode,\n      inlineContentSchema,\n      styleSchema\n    );\n  } else if (blockConfig.content === \"none\") {\n    content = undefined;\n  } else {\n    throw new UnreachableCaseError(blockConfig.content);\n  }\n\n  const block = {\n    id,\n    type: blockConfig.type,\n    props,\n    content,\n    children,\n  } as Block<BSchema, I, S>;\n\n  blockCache?.set(node, block);\n\n  return block;\n}\n","import { DOMSerializer, Fragment, Node } from \"prosemirror-model\";\n\nimport type { BlockNoteEditor } from \"../../../../editor/BlockNoteEditor\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../../schema\";\nimport { nodeToBlock } from \"../../../nodeConversions/nodeConversions\";\n\nfunction doc(options: { document?: Document }) {\n  return options.document || window.document;\n}\n\n// Used to implement `serializeNodeInner` for the `internalHTMLSerializer` and\n// `externalHTMLExporter`. Changes how the content of `blockContainer` nodes is\n// serialized vs the default `DOMSerializer` implementation. For the\n// `blockContent` node, the `toInternalHTML` or `toExternalHTML` function of its\n// corresponding block is used for serialization instead of the node's\n// `renderHTML` method.\nexport const serializeNodeInner = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  node: Node,\n  options: { document?: Document },\n  serializer: DOMSerializer,\n  editor: BlockNoteEditor<BSchema, I, S>,\n  toExternalHTML: boolean\n) => {\n  if (!serializer.nodes[node.type.name]) {\n    throw new Error(\"Serializer is missing a node type: \" + node.type.name);\n  }\n\n  const { dom, contentDOM } = DOMSerializer.renderSpec(\n    doc(options),\n    serializer.nodes[node.type.name](node)\n  );\n\n  if (contentDOM) {\n    if (node.isLeaf) {\n      throw new RangeError(\"Content hole not allowed in a leaf node spec\");\n    }\n\n    // Handles converting `blockContainer` nodes to HTML.\n    if (node.type.name === \"blockContainer\") {\n      const blockContentNode =\n        node.childCount > 0 &&\n        node.firstChild!.type.spec.group === \"blockContent\"\n          ? node.firstChild!\n          : undefined;\n      const blockGroupNode =\n        node.childCount > 0 && node.lastChild!.type.spec.group === \"blockGroup\"\n          ? node.lastChild!\n          : undefined;\n\n      // Converts `blockContent` node using the custom `blockSpec`'s\n      // `toExternalHTML` or `toInternalHTML` function.\n      // Note: While `blockContainer` nodes should always contain a\n      // `blockContent` node according to the schema, PM Fragments don't always\n      // conform to the schema. This is unintuitive but important as it occurs\n      // when copying only nested blocks.\n      if (blockContentNode !== undefined) {\n        const impl =\n          editor.blockImplementations[blockContentNode.type.name]\n            .implementation;\n        const toHTML = toExternalHTML\n          ? impl.toExternalHTML\n          : impl.toInternalHTML;\n        const blockContent = toHTML(\n          nodeToBlock(\n            node,\n            editor.schema.blockSchema,\n            editor.schema.inlineContentSchema,\n            editor.schema.styleSchema,\n            editor.blockCache\n          ),\n          editor as any\n        );\n\n        // Converts inline nodes in the `blockContent` node's content to HTML\n        // using their `renderHTML` methods.\n        if (blockContent.contentDOM !== undefined) {\n          if (node.isLeaf) {\n            throw new RangeError(\n              \"Content hole not allowed in a leaf node spec\"\n            );\n          }\n\n          blockContent.contentDOM.appendChild(\n            serializer.serializeFragment(blockContentNode.content, options)\n          );\n        }\n\n        contentDOM.appendChild(blockContent.dom);\n      }\n\n      // Converts `blockGroup` node to HTML using its `renderHTML` method.\n      if (blockGroupNode !== undefined) {\n        serializer.serializeFragment(\n          Fragment.from(blockGroupNode),\n          options,\n          contentDOM\n        );\n      }\n    } else {\n      // Converts the node normally, i.e. using its `renderHTML method`.\n      serializer.serializeFragment(node.content, options, contentDOM);\n    }\n  }\n\n  return dom as HTMLElement;\n};\n\n// Used to implement `serializeProseMirrorFragment` for the\n// `internalHTMLSerializer` and `externalHTMLExporter`. Does basically the same\n// thing as `serializer.serializeFragment`, but takes fewer arguments and\n// returns a string instead, to make it easier to use.\nexport const serializeProseMirrorFragment = (\n  fragment: Fragment,\n  serializer: DOMSerializer\n) => {\n  const internalHTML = serializer.serializeFragment(fragment);\n  const parent = document.createElement(\"div\");\n  parent.appendChild(internalHTML);\n\n  return parent.innerHTML;\n};\n","import { Element as HASTElement, Parent as HASTParent } from \"hast\";\nimport { fromDom } from \"hast-util-from-dom\";\n\ntype SimplifyBlocksOptions = {\n  orderedListItemBlockTypes: Set<string>;\n  unorderedListItemBlockTypes: Set<string>;\n};\n\n/**\n * Rehype plugin which converts the HTML output string rendered by BlockNote into a simplified structure which better\n * follows HTML standards. It does several things:\n * - Removes all block related div elements, leaving only the actual content inside the block.\n * - Lifts nested blocks to a higher level for all block types that don't represent list items.\n * - Wraps blocks which represent list items in corresponding ul/ol HTML elements and restructures them to comply\n * with HTML list structure.\n * @param options Options for specifying which block types represent ordered and unordered list items.\n */\nexport function simplifyBlocks(options: SimplifyBlocksOptions) {\n  const listItemBlockTypes = new Set<string>([\n    ...options.orderedListItemBlockTypes,\n    ...options.unorderedListItemBlockTypes,\n  ]);\n\n  const simplifyBlocksHelper = (tree: HASTParent) => {\n    // Checks whether blocks in the tree are wrapped by a parent `blockGroup`\n    // element, in which case the `blockGroup`'s children are lifted out, and it\n    // is removed.\n    if (\n      tree.children.length === 1 &&\n      (tree.children[0] as HASTElement).properties?.[\"dataNodeType\"] ===\n        \"blockGroup\"\n    ) {\n      const blockGroup = tree.children[0] as HASTElement;\n      tree.children.pop();\n      tree.children.push(...blockGroup.children);\n    }\n\n    let numChildElements = tree.children.length;\n    let activeList: HASTElement | undefined;\n\n    for (let i = 0; i < numChildElements; i++) {\n      const blockOuter = tree.children[i] as HASTElement;\n      const blockContainer = blockOuter.children[0] as HASTElement;\n      const blockContent = blockContainer.children[0] as HASTElement;\n      const blockGroup =\n        blockContainer.children.length === 2\n          ? (blockContainer.children[1] as HASTElement)\n          : null;\n\n      const isListItemBlock = listItemBlockTypes.has(\n        blockContent.properties![\"dataContentType\"] as string\n      );\n\n      const listItemBlockType = isListItemBlock\n        ? options.orderedListItemBlockTypes.has(\n            blockContent.properties![\"dataContentType\"] as string\n          )\n          ? \"ol\"\n          : \"ul\"\n        : null;\n\n      // Plugin runs recursively to process nested blocks.\n      if (blockGroup !== null) {\n        simplifyBlocksHelper(blockGroup);\n      }\n\n      // Checks that there is an active list, but the block can't be added to it as it's of a different type.\n      if (activeList && activeList.tagName !== listItemBlockType) {\n        // Blocks that were copied into the list are removed and the list is inserted in their place.\n        tree.children.splice(\n          i - activeList.children.length,\n          activeList.children.length,\n          activeList\n        );\n\n        // Updates the current index and number of child elements.\n        const numElementsRemoved = activeList.children.length - 1;\n        i -= numElementsRemoved;\n        numChildElements -= numElementsRemoved;\n\n        activeList = undefined;\n      }\n\n      // Checks if the block represents a list item.\n      if (isListItemBlock) {\n        // Checks if a list isn't already active. We don't have to check if the block and the list are of the same\n        // type as this was already done earlier.\n        if (!activeList) {\n          // Creates a new list element to represent an active list.\n          activeList = fromDom(\n            document.createElement(listItemBlockType!)\n          ) as HASTElement;\n        }\n\n        // Creates a new list item element to represent the block.\n        const listItemElement = fromDom(\n          document.createElement(\"li\")\n        ) as HASTElement;\n\n        // Adds only the content inside the block to the active list.\n        listItemElement.children.push(blockContent.children[0]);\n        // Nested blocks have already been processed in the recursive function call, so the resulting elements are\n        // also added to the active list.\n        if (blockGroup !== null) {\n          listItemElement.children.push(...blockGroup.children);\n        }\n\n        // Adds the list item representing the block to the active list.\n        activeList.children.push(listItemElement);\n      } else if (blockGroup !== null) {\n        // Lifts all children out of the current block, as only list items should allow nesting.\n        tree.children.splice(i + 1, 0, ...blockGroup.children);\n        // Replaces the block with only the content inside it.\n        tree.children[i] = blockContent.children[0];\n\n        // Updates the current index and number of child elements.\n        const numElementsAdded = blockGroup.children.length;\n        i += numElementsAdded;\n        numChildElements += numElementsAdded;\n      } else {\n        // Replaces the block with only the content inside it.\n        tree.children[i] = blockContent.children[0];\n      }\n    }\n\n    // Since the active list is only inserted after encountering a block which can't be added to it, there are cases\n    // where it remains un-inserted after processing all blocks, which are handled here.\n    if (activeList) {\n      tree.children.splice(\n        numChildElements - activeList.children.length,\n        activeList.children.length,\n        activeList\n      );\n    }\n  };\n\n  return simplifyBlocksHelper;\n}\n","import { DOMSerializer, Fragment, Node, Schema } from \"prosemirror-model\";\nimport rehypeParse from \"rehype-parse\";\nimport rehypeStringify from \"rehype-stringify\";\nimport { unified } from \"unified\";\n\nimport { PartialBlock } from \"../../../blocks/defaultBlocks\";\nimport type { BlockNoteEditor } from \"../../../editor/BlockNoteEditor\";\nimport { BlockSchema, InlineContentSchema, StyleSchema } from \"../../../schema\";\nimport { blockToNode } from \"../../nodeConversions/nodeConversions\";\nimport {\n  serializeNodeInner,\n  serializeProseMirrorFragment,\n} from \"./util/sharedHTMLConversion\";\nimport { simplifyBlocks } from \"./util/simplifyBlocksRehypePlugin\";\n\n// Used to export BlockNote blocks and ProseMirror nodes to HTML for use outside\n// the editor. Blocks are exported using the `toExternalHTML` method in their\n// `blockSpec`, or `toInternalHTML` if `toExternalHTML` is not defined.\n//\n// The HTML created by this serializer is different to what's rendered by the\n// editor to the DOM. This also means that data is likely to be lost when\n// converting back to original blocks. The differences in the output HTML are:\n// 1. It doesn't include the `blockGroup` and `blockContainer` wrappers meaning\n// that nesting is not preserved for non-list-item blocks.\n// 2. `li` items in the output HTML are wrapped in `ul` or `ol` elements.\n// 3. While nesting for list items is preserved, other types of blocks nested\n// inside a list are un-nested and a new list is created after them.\n// 4. The HTML is wrapped in a single `div` element.\n//\n// The serializer has 2 main methods:\n// `exportBlocks`: Exports an array of blocks to HTML.\n// `exportFragment`: Exports a ProseMirror fragment to HTML. This is mostly\n// useful if you want to export a selection which may not start/end at the\n// start/end of a block.\nexport interface ExternalHTMLExporter<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n> {\n  exportBlocks: (blocks: PartialBlock<BSchema, I, S>[]) => string;\n  exportProseMirrorFragment: (fragment: Fragment) => string;\n}\n\nexport const createExternalHTMLExporter = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  schema: Schema,\n  editor: BlockNoteEditor<BSchema, I, S>\n): ExternalHTMLExporter<BSchema, I, S> => {\n  const serializer = DOMSerializer.fromSchema(schema) as DOMSerializer & {\n    serializeNodeInner: (\n      node: Node,\n      options: { document?: Document }\n    ) => HTMLElement;\n    // TODO: Should not be async, but is since we're using a rehype plugin to\n    //  convert internal HTML to external HTML.\n    exportProseMirrorFragment: (fragment: Fragment) => string;\n    exportBlocks: (blocks: PartialBlock<BSchema, I, S>[]) => string;\n  };\n\n  serializer.serializeNodeInner = (\n    node: Node,\n    options: { document?: Document }\n  ) => serializeNodeInner(node, options, serializer, editor, true);\n\n  // Like the `internalHTMLSerializer`, also uses `serializeProseMirrorFragment`\n  // but additionally runs it through the `simplifyBlocks` rehype plugin to\n  // convert the internal HTML to external.\n  serializer.exportProseMirrorFragment = (fragment) => {\n    const externalHTML = unified()\n      .use(rehypeParse, { fragment: true })\n      .use(simplifyBlocks, {\n        orderedListItemBlockTypes: new Set<string>([\"numberedListItem\"]),\n        unorderedListItemBlockTypes: new Set<string>([\"bulletListItem\"]),\n      })\n      .use(rehypeStringify)\n      .processSync(serializeProseMirrorFragment(fragment, serializer));\n\n    return externalHTML.value as string;\n  };\n\n  serializer.exportBlocks = (blocks: PartialBlock<BSchema, I, S>[]) => {\n    const nodes = blocks.map((block) =>\n      blockToNode(block, schema, editor.schema.styleSchema)\n    );\n    const blockGroup = schema.nodes[\"blockGroup\"].create(null, nodes);\n\n    return serializer.exportProseMirrorFragment(Fragment.from(blockGroup));\n  };\n\n  return serializer;\n};\n","import { DOMSerializer, Fragment, Node, Schema } from \"prosemirror-model\";\nimport { PartialBlock } from \"../../../blocks/defaultBlocks\";\nimport type { BlockNoteEditor } from \"../../../editor/BlockNoteEditor\";\nimport { BlockSchema, InlineContentSchema, StyleSchema } from \"../../../schema\";\nimport { blockToNode } from \"../../nodeConversions/nodeConversions\";\nimport {\n  serializeNodeInner,\n  serializeProseMirrorFragment,\n} from \"./util/sharedHTMLConversion\";\n\n// Used to serialize BlockNote blocks and ProseMirror nodes to HTML without\n// losing data. Blocks are exported using the `toInternalHTML` method in their\n// `blockSpec`.\n//\n// The HTML created by this serializer is the same as what's rendered by the\n// editor to the DOM. This means that it retains the same structure as the\n// editor, including the `blockGroup` and `blockContainer` wrappers. This also\n// means that it can be converted back to the original blocks without any data\n// loss.\n//\n// The serializer has 2 main methods:\n// `serializeFragment`: Serializes a ProseMirror fragment to HTML. This is\n// mostly useful if you want to serialize a selection which may not start/end at\n// the start/end of a block.\n// `serializeBlocks`: Serializes an array of blocks to HTML.\nexport interface InternalHTMLSerializer<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n> {\n  // TODO: Ideally we would expand the BlockNote API to support partial\n  //  selections so we don't need this.\n  serializeProseMirrorFragment: (fragment: Fragment) => string;\n  serializeBlocks: (blocks: PartialBlock<BSchema, I, S>[]) => string;\n}\n\nexport const createInternalHTMLSerializer = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  schema: Schema,\n  editor: BlockNoteEditor<BSchema, I, S>\n): InternalHTMLSerializer<BSchema, I, S> => {\n  const serializer = DOMSerializer.fromSchema(schema) as DOMSerializer & {\n    serializeNodeInner: (\n      node: Node,\n      options: { document?: Document }\n    ) => HTMLElement;\n    serializeBlocks: (blocks: PartialBlock<BSchema, I, S>[]) => string;\n    serializeProseMirrorFragment: (\n      fragment: Fragment,\n      options?: { document?: Document | undefined } | undefined,\n      target?: HTMLElement | DocumentFragment | undefined\n    ) => string;\n  };\n\n  serializer.serializeNodeInner = (\n    node: Node,\n    options: { document?: Document }\n  ) => serializeNodeInner(node, options, serializer, editor, false);\n\n  serializer.serializeProseMirrorFragment = (fragment: Fragment) =>\n    serializeProseMirrorFragment(fragment, serializer);\n\n  serializer.serializeBlocks = (blocks: PartialBlock<BSchema, I, S>[]) => {\n    const nodes = blocks.map((block) =>\n      blockToNode(block, schema, editor.schema.styleSchema)\n    );\n    const blockGroup = schema.nodes[\"blockGroup\"].create(null, nodes);\n\n    return serializer.serializeProseMirrorFragment(Fragment.from(blockGroup));\n  };\n\n  return serializer;\n};\n","/**\n * Uploads a file to tmpfiles.org and returns the URL to the uploaded file.\n *\n * @warning This function should only be used for development purposes, replace with your own backend!\n */\nexport const uploadToTmpFilesDotOrg_DEV_ONLY = async (\n  file: File\n): Promise<string> => {\n  const body = new FormData();\n  body.append(\"file\", file);\n\n  const ret = await fetch(\"https://tmpfiles.org/api/v1/upload\", {\n    method: \"POST\",\n    body: body,\n  });\n  return (await ret.json()).data.url.replace(\n    \"tmpfiles.org/\",\n    \"tmpfiles.org/dl/\"\n  );\n};\n","export const isAppleOS = () =>\n  typeof navigator !== \"undefined\" &&\n  (/Mac/.test(navigator.platform) ||\n    (/AppleWebKit/.test(navigator.userAgent) &&\n      /Mobile\\/\\w+/.test(navigator.userAgent)));\n\nexport function formatKeyboardShortcut(shortcut: string) {\n  if (isAppleOS()) {\n    return shortcut.replace(\"Mod\", \"⌘\");\n  } else {\n    return shortcut.replace(\"Mod\", \"Ctrl\");\n  }\n}\n\nexport function mergeCSSClasses(...classes: string[]) {\n  return classes.filter((c) => c).join(\" \");\n}\n\nexport const isSafari = () =>\n  /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n","import { blockToNode } from \"../api/nodeConversions/nodeConversions\";\nimport type { BlockNoteEditor } from \"../editor/BlockNoteEditor\";\nimport type {\n  BlockNoDefaults,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../schema\";\nimport { mergeCSSClasses } from \"../util/browser\";\n\n// Function that creates a ProseMirror `DOMOutputSpec` for a default block.\n// Since all default blocks have the same structure (`blockContent` div with a\n// `inlineContent` element inside), this function only needs the block's name\n// for the `data-content-type` attribute of the `blockContent` element and the\n// HTML tag of the `inlineContent` element, as well as any HTML attributes to\n// add to those.\nexport function createDefaultBlockDOMOutputSpec(\n  blockName: string,\n  htmlTag: string,\n  blockContentHTMLAttributes: Record<string, string>,\n  inlineContentHTMLAttributes: Record<string, string>\n) {\n  const blockContent = document.createElement(\"div\");\n  blockContent.className = mergeCSSClasses(\n    \"bn-block-content\",\n    blockContentHTMLAttributes.class\n  );\n  blockContent.setAttribute(\"data-content-type\", blockName);\n  for (const [attribute, value] of Object.entries(blockContentHTMLAttributes)) {\n    if (attribute !== \"class\") {\n      blockContent.setAttribute(attribute, value);\n    }\n  }\n\n  const inlineContent = document.createElement(htmlTag);\n  inlineContent.className = mergeCSSClasses(\n    \"bn-inline-content\",\n    inlineContentHTMLAttributes.class\n  );\n  for (const [attribute, value] of Object.entries(\n    inlineContentHTMLAttributes\n  )) {\n    if (attribute !== \"class\") {\n      inlineContent.setAttribute(attribute, value);\n    }\n  }\n\n  blockContent.appendChild(inlineContent);\n\n  return {\n    dom: blockContent,\n    contentDOM: inlineContent,\n  };\n}\n\n// Function used to convert default blocks to HTML. It uses the corresponding\n// node's `renderHTML` method to do the conversion by using a default\n// `DOMSerializer`.\nexport const defaultBlockToHTML = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  block: BlockNoDefaults<BSchema, I, S>,\n  editor: BlockNoteEditor<BSchema, I, S>\n): {\n  dom: HTMLElement;\n  contentDOM?: HTMLElement;\n} => {\n  const node = blockToNode(\n    block,\n    editor._tiptapEditor.schema,\n    editor.schema.styleSchema\n  ).firstChild!;\n  const toDOM = editor._tiptapEditor.schema.nodes[node.type.name].spec.toDOM;\n\n  if (toDOM === undefined) {\n    throw new Error(\n      \"This block has no default HTML serialization as its corresponding TipTap node doesn't implement `renderHTML`.\"\n    );\n  }\n\n  const renderSpec = toDOM(node);\n\n  if (typeof renderSpec !== \"object\" || !(\"dom\" in renderSpec)) {\n    throw new Error(\n      \"Cannot use this block's default HTML serialization as its corresponding TipTap node's `renderHTML` function does not return an object with the `dom` property.\"\n    );\n  }\n\n  return renderSpec as {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n  };\n};\n","import type { Props, PropSchema } from \"../schema\";\n\n// TODO: this system should probably be moved / refactored.\n// The dependency from schema on this file doesn't make sense\n\nexport const defaultProps = {\n  backgroundColor: {\n    default: \"default\" as const,\n  },\n  textColor: {\n    default: \"default\" as const,\n  },\n  textAlignment: {\n    default: \"left\" as const,\n    values: [\"left\", \"center\", \"right\", \"justify\"] as const,\n  },\n} satisfies PropSchema;\n\nexport type DefaultProps = Props<typeof defaultProps>;\n\n// Default props which are set on `blockContainer` nodes rather than\n// `blockContent` nodes. Ensures that they are not redundantly added to\n// a custom block's TipTap node attributes.\nexport const inheritedProps = [\"backgroundColor\", \"textColor\"];\n","export function camelToDataKebab(str: string): string {\n  return \"data-\" + str.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\n","import {\n  Attribute,\n  Attributes,\n  Editor,\n  Extension,\n  Node,\n  NodeConfig,\n} from \"@tiptap/core\";\nimport { defaultBlockToHTML } from \"../../blocks/defaultBlockHelpers\";\nimport { inheritedProps } from \"../../blocks/defaultProps\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor\";\nimport { mergeCSSClasses } from \"../../util/browser\";\nimport { camelToDataKebab } from \"../../util/string\";\nimport { InlineContentSchema } from \"../inlineContent/types\";\nimport { PropSchema, Props } from \"../propTypes\";\nimport { StyleSchema } from \"../styles/types\";\nimport {\n  BlockConfig,\n  BlockSchemaFromSpecs,\n  BlockSchemaWithBlock,\n  BlockSpec,\n  BlockSpecs,\n  SpecificBlock,\n  TiptapBlockImplementation,\n} from \"./types\";\n\n// Function that uses the 'propSchema' of a blockConfig to create a TipTap\n// node's `addAttributes` property.\n// TODO: extract function\nexport function propsToAttributes(propSchema: PropSchema): Attributes {\n  const tiptapAttributes: Record<string, Attribute> = {};\n\n  Object.entries(propSchema)\n    .filter(([name, _spec]) => !inheritedProps.includes(name))\n    .forEach(([name, spec]) => {\n      tiptapAttributes[name] = {\n        default: spec.default,\n        keepOnSplit: true,\n        // Props are displayed in kebab-case as HTML attributes. If a prop's\n        // value is the same as its default, we don't display an HTML\n        // attribute for it.\n        parseHTML: (element) => {\n          const value = element.getAttribute(camelToDataKebab(name));\n\n          if (value === null) {\n            return null;\n          }\n\n          if (typeof spec.default === \"boolean\") {\n            if (value === \"true\") {\n              return true;\n            }\n\n            if (value === \"false\") {\n              return false;\n            }\n\n            return null;\n          }\n\n          if (typeof spec.default === \"number\") {\n            const asNumber = parseFloat(value);\n            const isNumeric =\n              !Number.isNaN(asNumber) && Number.isFinite(asNumber);\n\n            if (isNumeric) {\n              return asNumber;\n            }\n\n            return null;\n          }\n\n          return value;\n        },\n        renderHTML: (attributes) =>\n          attributes[name] !== spec.default\n            ? {\n                [camelToDataKebab(name)]: attributes[name],\n              }\n            : {},\n      };\n    });\n\n  return tiptapAttributes;\n}\n\n// Used to figure out which block should be rendered. This block is then used to\n// create the node view.\nexport function getBlockFromPos<\n  BType extends string,\n  Config extends BlockConfig,\n  BSchema extends BlockSchemaWithBlock<BType, Config>,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  getPos: (() => number) | boolean,\n  editor: BlockNoteEditor<BSchema, I, S>,\n  tipTapEditor: Editor,\n  type: BType\n) {\n  // Gets position of the node\n  if (typeof getPos === \"boolean\") {\n    throw new Error(\n      \"Cannot find node position as getPos is a boolean, not a function.\"\n    );\n  }\n  const pos = getPos();\n  // Gets parent blockContainer node\n  const blockContainer = tipTapEditor.state.doc.resolve(pos!).node();\n  // Gets block identifier\n  const blockIdentifier = blockContainer.attrs.id;\n  // Gets the block\n  const block = editor.getBlock(blockIdentifier)! as SpecificBlock<\n    BSchema,\n    BType,\n    I,\n    S\n  >;\n  if (block.type !== type) {\n    throw new Error(\"Block type does not match\");\n  }\n\n  return block;\n}\n\n// Function that wraps the `dom` element returned from 'blockConfig.render' in a\n// `blockContent` div, which contains the block type and props as HTML\n// attributes. If `blockConfig.render` also returns a `contentDOM`, it also adds\n// an `inlineContent` class to it.\nexport function wrapInBlockStructure<\n  BType extends string,\n  PSchema extends PropSchema\n>(\n  element: {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n    destroy?: () => void;\n  },\n  blockType: BType,\n  blockProps: Props<PSchema>,\n  propSchema: PSchema,\n  domAttributes?: Record<string, string>\n): {\n  dom: HTMLElement;\n  contentDOM?: HTMLElement;\n  destroy?: () => void;\n} {\n  // Creates `blockContent` element\n  const blockContent = document.createElement(\"div\");\n\n  // Adds custom HTML attributes\n  if (domAttributes !== undefined) {\n    for (const [attr, value] of Object.entries(domAttributes)) {\n      if (attr !== \"class\") {\n        blockContent.setAttribute(attr, value);\n      }\n    }\n  }\n  // Sets blockContent class\n  blockContent.className = mergeCSSClasses(\n    \"bn-block-content\",\n    domAttributes?.class || \"\"\n  );\n  // Sets content type attribute\n  blockContent.setAttribute(\"data-content-type\", blockType);\n  // Adds props as HTML attributes in kebab-case with \"data-\" prefix. Skips props\n  // which are already added as HTML attributes to the parent `blockContent`\n  // element (inheritedProps) and props set to their default values.\n  for (const [prop, value] of Object.entries(blockProps)) {\n    if (!inheritedProps.includes(prop) && value !== propSchema[prop].default) {\n      blockContent.setAttribute(camelToDataKebab(prop), value);\n    }\n  }\n\n  blockContent.appendChild(element.dom);\n\n  if (element.contentDOM !== undefined) {\n    element.contentDOM.className = mergeCSSClasses(\n      \"bn-inline-content\",\n      element.contentDOM.className\n    );\n    element.contentDOM.setAttribute(\"data-editable\", \"\");\n  }\n\n  return {\n    ...element,\n    dom: blockContent,\n  };\n}\n\n// Helper type to keep track of the `name` and `content` properties after calling Node.create.\ntype StronglyTypedTipTapNode<\n  Name extends string,\n  Content extends \"inline*\" | \"tableRow+\" | \"\"\n> = Node & { name: Name; config: { content: Content } };\n\nexport function createStronglyTypedTiptapNode<\n  Name extends string,\n  Content extends \"inline*\" | \"tableRow+\" | \"\"\n>(config: NodeConfig & { name: Name; content: Content }) {\n  return Node.create(config) as StronglyTypedTipTapNode<Name, Content>; // force re-typing (should be safe as it's type-checked from the config)\n}\n\n// This helper function helps to instantiate a blockspec with a\n// config and implementation that conform to the type of Config\nexport function createInternalBlockSpec<T extends BlockConfig>(\n  config: T,\n  implementation: TiptapBlockImplementation<\n    T,\n    any,\n    InlineContentSchema,\n    StyleSchema\n  >\n) {\n  return {\n    config,\n    implementation,\n  } satisfies BlockSpec<T, any, InlineContentSchema, StyleSchema>;\n}\n\nexport function createBlockSpecFromStronglyTypedTiptapNode<\n  T extends Node,\n  P extends PropSchema\n>(node: T, propSchema: P, requiredExtensions?: Array<Extension | Node>) {\n  return createInternalBlockSpec(\n    {\n      type: node.name as T[\"name\"],\n      content: (node.config.content === \"inline*\"\n        ? \"inline\"\n        : node.config.content === \"tableRow+\"\n        ? \"table\"\n        : \"none\") as T[\"config\"][\"content\"] extends \"inline*\"\n        ? \"inline\"\n        : T[\"config\"][\"content\"] extends \"tableRow+\"\n        ? \"table\"\n        : \"none\",\n      propSchema,\n    },\n    {\n      node,\n      requiredExtensions,\n      toInternalHTML: defaultBlockToHTML,\n      toExternalHTML: defaultBlockToHTML,\n      // parse: () => undefined, // parse rules are in node already\n    }\n  );\n}\n\nexport function getBlockSchemaFromSpecs<T extends BlockSpecs>(specs: T) {\n  return Object.fromEntries(\n    Object.entries(specs).map(([key, value]) => [key, value.config])\n  ) as BlockSchemaFromSpecs<T>;\n}\n","import { ParseRule } from \"@tiptap/pm/model\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor\";\nimport { InlineContentSchema } from \"../inlineContent/types\";\nimport { StyleSchema } from \"../styles/types\";\nimport {\n  createInternalBlockSpec,\n  createStronglyTypedTiptapNode,\n  getBlockFromPos,\n  propsToAttributes,\n  wrapInBlockStructure,\n} from \"./internal\";\nimport {\n  BlockConfig,\n  BlockFromConfig,\n  BlockSchemaWithBlock,\n  PartialBlockFromConfig,\n} from \"./types\";\n\n// restrict content to \"inline\" and \"none\" only\nexport type CustomBlockConfig = BlockConfig & {\n  content: \"inline\" | \"none\";\n};\n\nexport type CustomBlockImplementation<\n  T extends CustomBlockConfig,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n> = {\n  render: (\n    /**\n     * The custom block to render\n     */\n    block: BlockFromConfig<T, I, S>,\n    /**\n     * The BlockNote editor instance\n     * This is typed generically. If you want an editor with your custom schema, you need to\n     * cast it manually, e.g.: `const e = editor as BlockNoteEditor<typeof mySchema>;`\n     */\n    editor: BlockNoteEditor<BlockSchemaWithBlock<T[\"type\"], T>, I, S>\n    // (note) if we want to fix the manual cast, we need to prevent circular references and separate block definition and render implementations\n    // or allow manually passing <BSchema>, but that's not possible without passing the other generics because Typescript doesn't support partial inferred generics\n  ) => {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n    destroy?: () => void;\n  };\n  // Exports block to external HTML. If not defined, the output will be the same\n  // as `render(...).dom`. Used to create clipboard data when pasting outside\n  // BlockNote.\n  // TODO: Maybe can return undefined to ignore when serializing?\n  toExternalHTML?: (\n    block: BlockFromConfig<T, I, S>,\n    editor: BlockNoteEditor<BlockSchemaWithBlock<T[\"type\"], T>, I, S>\n  ) => {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n  };\n\n  parse?: (\n    el: HTMLElement\n  ) => PartialBlockFromConfig<T, I, S>[\"props\"] | undefined;\n};\n\n// Function that uses the 'parse' function of a blockConfig to create a\n// TipTap node's `parseHTML` property. This is only used for parsing content\n// from the clipboard.\nexport function getParseRules(\n  config: BlockConfig,\n  customParseFunction: CustomBlockImplementation<any, any, any>[\"parse\"]\n) {\n  const rules: ParseRule[] = [\n    {\n      tag: \"[data-content-type=\" + config.type + \"]\",\n      contentElement: \"[data-editable]\",\n    },\n  ];\n\n  if (customParseFunction) {\n    rules.push({\n      tag: \"*\",\n      getAttrs(node: string | HTMLElement) {\n        if (typeof node === \"string\") {\n          return false;\n        }\n\n        const props = customParseFunction?.(node);\n\n        if (props === undefined) {\n          return false;\n        }\n\n        return props;\n      },\n    });\n  }\n  //     getContent(node, schema) {\n  //       const block = blockConfig.parse?.(node as HTMLElement);\n  //\n  //       if (block !== undefined && block.content !== undefined) {\n  //         return Fragment.from(\n  //           typeof block.content === \"string\"\n  //             ? schema.text(block.content)\n  //             : inlineContentToNodes(block.content, schema)\n  //         );\n  //       }\n  //\n  //       return Fragment.empty;\n  //     },\n  //   });\n  // }\n\n  return rules;\n}\n\n// A function to create custom block for API consumers\n// we want to hide the tiptap node from API consumers and provide a simpler API surface instead\nexport function createBlockSpec<\n  T extends CustomBlockConfig,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(blockConfig: T, blockImplementation: CustomBlockImplementation<T, I, S>) {\n  const node = createStronglyTypedTiptapNode({\n    name: blockConfig.type as T[\"type\"],\n    content: (blockConfig.content === \"inline\"\n      ? \"inline*\"\n      : \"\") as T[\"content\"] extends \"inline\" ? \"inline*\" : \"\",\n    group: \"blockContent\",\n    selectable: true,\n\n    addAttributes() {\n      return propsToAttributes(blockConfig.propSchema);\n    },\n\n    parseHTML() {\n      return getParseRules(blockConfig, blockImplementation.parse);\n    },\n\n    renderHTML() {\n      // renderHTML is not really used, as we always use a nodeView, and we use toExternalHTML / toInternalHTML for serialization\n      // There's an edge case when this gets called nevertheless; before the nodeviews have been mounted\n      // this is why we implement it with a temporary placeholder\n      const div = document.createElement(\"div\");\n      div.setAttribute(\"data-tmp-placeholder\", \"true\");\n      return {\n        dom: div,\n      };\n    },\n\n    addNodeView() {\n      return ({ getPos }) => {\n        // Gets the BlockNote editor instance\n        const editor = this.options.editor;\n        // Gets the block\n        const block = getBlockFromPos(\n          getPos,\n          editor,\n          this.editor,\n          blockConfig.type\n        );\n        // Gets the custom HTML attributes for `blockContent` nodes\n        const blockContentDOMAttributes =\n          this.options.domAttributes?.blockContent || {};\n\n        const output = blockImplementation.render(block as any, editor);\n\n        return wrapInBlockStructure(\n          output,\n          block.type,\n          block.props,\n          blockConfig.propSchema,\n          blockContentDOMAttributes\n        );\n      };\n    },\n  });\n\n  if (node.name !== blockConfig.type) {\n    throw new Error(\n      \"Node name does not match block type. This is a bug in BlockNote.\"\n    );\n  }\n\n  return createInternalBlockSpec(blockConfig, {\n    node,\n    toInternalHTML: (block, editor) => {\n      const blockContentDOMAttributes =\n        node.options.domAttributes?.blockContent || {};\n\n      const output = blockImplementation.render(block as any, editor as any);\n\n      return wrapInBlockStructure(\n        output,\n        block.type,\n        block.props,\n        blockConfig.propSchema,\n        blockContentDOMAttributes\n      );\n    },\n    toExternalHTML: (block, editor) => {\n      const blockContentDOMAttributes =\n        node.options.domAttributes?.blockContent || {};\n\n      let output = blockImplementation.toExternalHTML?.(\n        block as any,\n        editor as any\n      );\n      if (output === undefined) {\n        output = blockImplementation.render(block as any, editor as any);\n      }\n\n      return wrapInBlockStructure(\n        output,\n        block.type,\n        block.props,\n        blockConfig.propSchema,\n        blockContentDOMAttributes\n      );\n    },\n  });\n}\n","import { KeyboardShortcutCommand, Node } from \"@tiptap/core\";\n\nimport { camelToDataKebab } from \"../../util/string\";\nimport { PropSchema, Props } from \"../propTypes\";\nimport {\n  CustomInlineContentConfig,\n  InlineContentConfig,\n  InlineContentImplementation,\n  InlineContentSchemaFromSpecs,\n  InlineContentSpec,\n  InlineContentSpecs,\n} from \"./types\";\n\n// Function that adds necessary classes and attributes to the `dom` element\n// returned from a custom inline content's 'render' function, to ensure no data\n// is lost on internal copy & paste.\nexport function addInlineContentAttributes<\n  IType extends string,\n  PSchema extends PropSchema\n>(\n  element: {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n  },\n  inlineContentType: IType,\n  inlineContentProps: Props<PSchema>,\n  propSchema: PSchema\n): {\n  dom: HTMLElement;\n  contentDOM?: HTMLElement;\n} {\n  // Sets content type attribute\n  element.dom.setAttribute(\"data-inline-content-type\", inlineContentType);\n  // Adds props as HTML attributes in kebab-case with \"data-\" prefix. Skips props\n  // set to their default values.\n  Object.entries(inlineContentProps)\n    .filter(([prop, value]) => value !== propSchema[prop].default)\n    .map(([prop, value]) => {\n      return [camelToDataKebab(prop), value];\n    })\n    .forEach(([prop, value]) => element.dom.setAttribute(prop, value));\n\n  if (element.contentDOM !== undefined) {\n    element.contentDOM.setAttribute(\"data-editable\", \"\");\n  }\n\n  return element;\n}\n\n// see https://github.com/TypeCellOS/BlockNote/pull/435\nexport function addInlineContentKeyboardShortcuts<\n  T extends CustomInlineContentConfig\n>(\n  config: T\n): {\n  [p: string]: KeyboardShortcutCommand;\n} {\n  return {\n    Backspace: ({ editor }) => {\n      const resolvedPos = editor.state.selection.$from;\n\n      return (\n        editor.state.selection.empty &&\n        resolvedPos.node().type.name === config.type &&\n        resolvedPos.parentOffset === 0\n      );\n    },\n  };\n}\n\n// This helper function helps to instantiate a InlineContentSpec with a\n// config and implementation that conform to the type of Config\nexport function createInternalInlineContentSpec<T extends InlineContentConfig>(\n  config: T,\n  implementation: InlineContentImplementation<T>\n) {\n  return {\n    config,\n    implementation,\n  } satisfies InlineContentSpec<T>;\n}\n\nexport function createInlineContentSpecFromTipTapNode<\n  T extends Node,\n  P extends PropSchema\n>(node: T, propSchema: P) {\n  return createInternalInlineContentSpec(\n    {\n      type: node.name as T[\"name\"],\n      propSchema,\n      content: node.config.content === \"inline*\" ? \"styled\" : \"none\",\n    },\n    {\n      node,\n    }\n  );\n}\n\nexport function getInlineContentSchemaFromSpecs<T extends InlineContentSpecs>(\n  specs: T\n) {\n  return Object.fromEntries(\n    Object.entries(specs).map(([key, value]) => [key, value.config])\n  ) as InlineContentSchemaFromSpecs<T>;\n}\n","import { Node } from \"@tiptap/core\";\nimport { ParseRule } from \"@tiptap/pm/model\";\nimport { nodeToCustomInlineContent } from \"../../api/nodeConversions/nodeConversions\";\nimport { propsToAttributes } from \"../blocks/internal\";\nimport { Props } from \"../propTypes\";\nimport { StyleSchema } from \"../styles/types\";\nimport {\n  addInlineContentAttributes,\n  addInlineContentKeyboardShortcuts,\n  createInlineContentSpecFromTipTapNode,\n} from \"./internal\";\nimport {\n  CustomInlineContentConfig,\n  InlineContentConfig,\n  InlineContentFromConfig,\n  InlineContentSpec,\n} from \"./types\";\n\n// TODO: support serialization\n\nexport type CustomInlineContentImplementation<\n  T extends InlineContentConfig,\n  // B extends BlockSchema,\n  // I extends InlineContentSchema,\n  S extends StyleSchema\n> = {\n  render: (\n    /**\n     * The custom inline content to render\n     */\n    inlineContent: InlineContentFromConfig<T, S>\n    /**\n     * The BlockNote editor instance\n     * This is typed generically. If you want an editor with your custom schema, you need to\n     * cast it manually, e.g.: `const e = editor as BlockNoteEditor<typeof mySchema>;`\n     */\n    // editor: BlockNoteEditor<B, I, S>\n    // (note) if we want to fix the manual cast, we need to prevent circular references and separate block definition and render implementations\n    // or allow manually passing <BSchema>, but that's not possible without passing the other generics because Typescript doesn't support partial inferred generics\n  ) => {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n    // destroy?: () => void;\n  };\n};\n\nexport function getInlineContentParseRules(\n  config: CustomInlineContentConfig\n): ParseRule[] {\n  return [\n    {\n      tag: `[data-inline-content-type=\"${config.type}\"]`,\n      contentElement: (element) => {\n        const htmlElement = element as HTMLElement;\n\n        if (htmlElement.matches(\"[data-editable]\")) {\n          return htmlElement;\n        }\n\n        return htmlElement.querySelector(\"[data-editable]\") || htmlElement;\n      },\n    },\n  ];\n}\n\nexport function createInlineContentSpec<\n  T extends CustomInlineContentConfig,\n  S extends StyleSchema\n>(\n  inlineContentConfig: T,\n  inlineContentImplementation: CustomInlineContentImplementation<T, S>\n): InlineContentSpec<T> {\n  const node = Node.create({\n    name: inlineContentConfig.type,\n    inline: true,\n    group: \"inline\",\n    selectable: inlineContentConfig.content === \"styled\",\n    atom: inlineContentConfig.content === \"none\",\n    content: (inlineContentConfig.content === \"styled\"\n      ? \"inline*\"\n      : \"\") as T[\"content\"] extends \"styled\" ? \"inline*\" : \"\",\n\n    addAttributes() {\n      return propsToAttributes(inlineContentConfig.propSchema);\n    },\n\n    addKeyboardShortcuts() {\n      return addInlineContentKeyboardShortcuts(inlineContentConfig);\n    },\n\n    parseHTML() {\n      return getInlineContentParseRules(inlineContentConfig);\n    },\n\n    renderHTML({ node }) {\n      const editor = this.options.editor;\n\n      const output = inlineContentImplementation.render(\n        nodeToCustomInlineContent(\n          node,\n          editor.schema.inlineContentSchema,\n          editor.schema.styleSchema\n        ) as any as InlineContentFromConfig<T, S> // TODO: fix cast\n      );\n\n      return addInlineContentAttributes(\n        output,\n        inlineContentConfig.type,\n        node.attrs as Props<T[\"propSchema\"]>,\n        inlineContentConfig.propSchema\n      );\n    },\n  });\n\n  return createInlineContentSpecFromTipTapNode(\n    node,\n    inlineContentConfig.propSchema\n  ) as InlineContentSpec<T>; // TODO: fix cast\n}\n","import { Attributes, Mark } from \"@tiptap/core\";\nimport {\n  StyleConfig,\n  StyleImplementation,\n  StylePropSchema,\n  StyleSchemaFromSpecs,\n  StyleSpec,\n  StyleSpecs,\n} from \"./types\";\n\nexport function stylePropsToAttributes(\n  propSchema: StylePropSchema\n): Attributes {\n  if (propSchema === \"boolean\") {\n    return {};\n  }\n  return {\n    stringValue: {\n      default: undefined,\n      keepOnSplit: true,\n      parseHTML: (element) => element.getAttribute(\"data-value\"),\n      renderHTML: (attributes) =>\n        attributes.stringValue !== undefined\n          ? {\n              \"data-value\": attributes.stringValue,\n            }\n          : {},\n    },\n  };\n}\n\n// Function that adds necessary classes and attributes to the `dom` element\n// returned from a custom style's 'render' function, to ensure no data is lost\n// on internal copy & paste.\nexport function addStyleAttributes<\n  SType extends string,\n  PSchema extends StylePropSchema\n>(\n  element: {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n  },\n  styleType: SType,\n  styleValue: PSchema extends \"boolean\" ? undefined : string,\n  propSchema: PSchema\n): {\n  dom: HTMLElement;\n  contentDOM?: HTMLElement;\n} {\n  // Sets content type attribute\n  element.dom.setAttribute(\"data-style-type\", styleType);\n  // Adds style value as an HTML attribute in kebab-case with \"data-\" prefix, if\n  // the style takes a string value.\n  if (propSchema === \"string\") {\n    element.dom.setAttribute(\"data-value\", styleValue as string);\n  }\n\n  if (element.contentDOM !== undefined) {\n    element.contentDOM.setAttribute(\"data-editable\", \"\");\n  }\n\n  return element;\n}\n\n// This helper function helps to instantiate a stylespec with a\n// config and implementation that conform to the type of Config\nexport function createInternalStyleSpec<T extends StyleConfig>(\n  config: T,\n  implementation: StyleImplementation\n) {\n  return {\n    config,\n    implementation,\n  } satisfies StyleSpec<T>;\n}\n\nexport function createStyleSpecFromTipTapMark<\n  T extends Mark,\n  P extends StylePropSchema\n>(mark: T, propSchema: P) {\n  return createInternalStyleSpec(\n    {\n      type: mark.name as T[\"name\"],\n      propSchema,\n    },\n    {\n      mark,\n    }\n  );\n}\n\nexport function getStyleSchemaFromSpecs<T extends StyleSpecs>(specs: T) {\n  return Object.fromEntries(\n    Object.entries(specs).map(([key, value]) => [key, value.config])\n  ) as StyleSchemaFromSpecs<T>;\n}\n","import { Mark } from \"@tiptap/core\";\nimport { ParseRule } from \"@tiptap/pm/model\";\nimport {\n  addStyleAttributes,\n  createInternalStyleSpec,\n  stylePropsToAttributes,\n} from \"./internal\";\nimport { StyleConfig, StyleSpec } from \"./types\";\nimport {UnreachableCaseError} from \"../../util/typescript\";\n\nexport type CustomStyleImplementation<T extends StyleConfig> = {\n  render: T[\"propSchema\"] extends \"boolean\"\n    ? () => {\n        dom: HTMLElement;\n        contentDOM?: HTMLElement;\n      }\n    : (value: string) => {\n        dom: HTMLElement;\n        contentDOM?: HTMLElement;\n      };\n};\n\n// TODO: support serialization\n\nexport function getStyleParseRules(config: StyleConfig): ParseRule[] {\n  return [\n    {\n      tag: `[data-style-type=\"${config.type}\"]`,\n      contentElement: (element) => {\n        const htmlElement = element as HTMLElement;\n\n        if (htmlElement.matches(\"[data-editable]\")) {\n          return htmlElement;\n        }\n\n        return htmlElement.querySelector(\"[data-editable]\") || htmlElement;\n      },\n    },\n  ];\n}\n\nexport function createStyleSpec<T extends StyleConfig>(\n  styleConfig: T,\n  styleImplementation: CustomStyleImplementation<T>\n): StyleSpec<T> {\n  const mark = Mark.create({\n    name: styleConfig.type,\n\n    addAttributes() {\n      return stylePropsToAttributes(styleConfig.propSchema);\n    },\n\n    parseHTML() {\n      return getStyleParseRules(styleConfig);\n    },\n\n    renderHTML({ mark }) {\n      let renderResult: {\n        dom: HTMLElement;\n        contentDOM?: HTMLElement;\n      };\n\n      if (styleConfig.propSchema === \"boolean\") {\n        // @ts-ignore not sure why this is complaining\n        renderResult = styleImplementation.render();\n      } else if (styleConfig.propSchema === \"string\") {\n        renderResult = styleImplementation.render(mark.attrs.stringValue);\n      } else {\n        throw new UnreachableCaseError(styleConfig.propSchema);\n      }\n\n      // const renderResult = styleImplementation.render();\n      return addStyleAttributes(\n        renderResult,\n        styleConfig.type,\n        mark.attrs.stringValue,\n        styleConfig.propSchema\n      );\n    },\n  });\n\n  return createInternalStyleSpec(styleConfig, {\n    mark,\n  });\n}\n","import { Mark } from \"@tiptap/core\";\nimport { createStyleSpecFromTipTapMark } from \"../../schema\";\n\nconst BackgroundColorMark = Mark.create({\n  name: \"backgroundColor\",\n\n  addAttributes() {\n    return {\n      stringValue: {\n        default: undefined,\n        parseHTML: (element) => element.getAttribute(\"data-background-color\"),\n        renderHTML: (attributes) => ({\n          \"data-background-color\": attributes.stringValue,\n        }),\n      },\n    };\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: \"span\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          if (element.hasAttribute(\"data-background-color\")) {\n            return {\n              stringValue: element.getAttribute(\"data-background-color\"),\n            };\n          }\n\n          return false;\n        },\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\"span\", HTMLAttributes, 0];\n  },\n});\n\nexport const BackgroundColor = createStyleSpecFromTipTapMark(\n  BackgroundColorMark,\n  \"string\"\n);\n","import { Mark } from \"@tiptap/core\";\nimport { createStyleSpecFromTipTapMark } from \"../../schema\";\n\nconst TextColorMark = Mark.create({\n  name: \"textColor\",\n\n  addAttributes() {\n    return {\n      stringValue: {\n        default: undefined,\n        parseHTML: (element) => element.getAttribute(\"data-text-color\"),\n        renderHTML: (attributes) => ({\n          \"data-text-color\": attributes.stringValue,\n        }),\n      },\n    };\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: \"span\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          if (element.hasAttribute(\"data-text-color\")) {\n            return { stringValue: element.getAttribute(\"data-text-color\") };\n          }\n\n          return false;\n        },\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\"span\", HTMLAttributes, 0];\n  },\n});\n\nexport const TextColor = createStyleSpecFromTipTapMark(TextColorMark, \"string\");\n","import { Editor } from \"@tiptap/core\";\nimport { getBlockInfoFromPos } from \"./getBlockInfoFromPos\";\n\n// Used to get the content type of the block that the text cursor is in. This is\n// a band-aid fix to prevent input rules and keyboard shortcuts from triggering\n// in tables, but really those should be extended to work with block selections.\nexport const getCurrentBlockContentType = (editor: Editor) => {\n  const { contentType } = getBlockInfoFromPos(\n    editor.state.doc,\n    editor.state.selection.from\n  );\n\n  return contentType.spec.content;\n};\n","import { InputRule } from \"@tiptap/core\";\nimport {\n  PropSchema,\n  createBlockSpecFromStronglyTypedTiptapNode,\n  createStronglyTypedTiptapNode,\n} from \"../../schema\";\nimport { createDefaultBlockDOMOutputSpec } from \"../defaultBlockHelpers\";\nimport { defaultProps } from \"../defaultProps\";\nimport { getCurrentBlockContentType } from \"../../api/getCurrentBlockContentType\";\n\nexport const headingPropSchema = {\n  ...defaultProps,\n  level: { default: 1, values: [1, 2, 3] as const },\n} satisfies PropSchema;\n\nconst HeadingBlockContent = createStronglyTypedTiptapNode({\n  name: \"heading\",\n  content: \"inline*\",\n  group: \"blockContent\",\n  addAttributes() {\n    return {\n      level: {\n        default: 1,\n        // instead of \"level\" attributes, use \"data-level\"\n        parseHTML: (element) => {\n          const attr = element.getAttribute(\"data-level\")!;\n          const parsed = parseInt(attr);\n          if (isFinite(parsed)) {\n            return parsed;\n          }\n          return undefined;\n        },\n        renderHTML: (attributes) => {\n          return {\n            \"data-level\": (attributes.level as number).toString(),\n          };\n        },\n      },\n    };\n  },\n\n  addInputRules() {\n    return [\n      ...[1, 2, 3].map((level) => {\n        // Creates a heading of appropriate level when starting with \"#\", \"##\", or \"###\".\n        return new InputRule({\n          find: new RegExp(`^(#{${level}})\\\\s$`),\n          handler: ({ state, chain, range }) => {\n            if (getCurrentBlockContentType(this.editor) !== \"inline*\") {\n              return;\n            }\n\n            chain()\n              .BNUpdateBlock(state.selection.from, {\n                type: \"heading\",\n                props: {\n                  level: level as any,\n                },\n              })\n              // Removes the \"#\" character(s) used to set the heading.\n              .deleteRange({ from: range.from, to: range.to });\n          },\n        });\n      }),\n    ];\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Alt-1\": () => {\n        if (getCurrentBlockContentType(this.editor) !== \"inline*\") {\n          return true;\n        }\n\n        return this.editor.commands.BNUpdateBlock(\n          this.editor.state.selection.anchor,\n          {\n            type: \"heading\",\n            props: {\n              level: 1 as any,\n            },\n          }\n        );\n      },\n      \"Mod-Alt-2\": () => {\n        if (getCurrentBlockContentType(this.editor) !== \"inline*\") {\n          return true;\n        }\n\n        return this.editor.commands.BNUpdateBlock(\n          this.editor.state.selection.anchor,\n          {\n            type: \"heading\",\n            props: {\n              level: 2 as any,\n            },\n          }\n        );\n      },\n      \"Mod-Alt-3\": () => {\n        if (getCurrentBlockContentType(this.editor) !== \"inline*\") {\n          return true;\n        }\n\n        return this.editor.commands.BNUpdateBlock(\n          this.editor.state.selection.anchor,\n          {\n            type: \"heading\",\n            props: {\n              level: 3 as any,\n            },\n          }\n        );\n      },\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"div[data-content-type=\" + this.name + \"]\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          return {\n            level: element.getAttribute(\"data-level\"),\n          };\n        },\n      },\n      {\n        tag: \"h1\",\n        attrs: { level: 1 },\n        node: \"heading\",\n      },\n      {\n        tag: \"h2\",\n        attrs: { level: 2 },\n        node: \"heading\",\n      },\n      {\n        tag: \"h3\",\n        attrs: { level: 3 },\n        node: \"heading\",\n      },\n    ];\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    return createDefaultBlockDOMOutputSpec(\n      this.name,\n      `h${node.attrs.level}`,\n      {\n        ...(this.options.domAttributes?.blockContent || {}),\n        ...HTMLAttributes,\n      },\n      this.options.domAttributes?.inlineContent || {}\n    );\n  },\n});\n\nexport const Heading = createBlockSpecFromStronglyTypedTiptapNode(\n  HeadingBlockContent,\n  headingPropSchema\n);\n","import type { BlockNoteEditor } from \"../../editor/BlockNoteEditor\";\n\nimport {\n  BlockFromConfig,\n  BlockSchemaWithBlock,\n  CustomBlockConfig,\n  InlineContentSchema,\n  PropSchema,\n  StyleSchema,\n  createBlockSpec,\n} from \"../../schema\";\nimport { defaultProps } from \"../defaultProps\";\n\nexport const imagePropSchema = {\n  textAlignment: defaultProps.textAlignment,\n  backgroundColor: defaultProps.backgroundColor,\n  // Image url.\n  url: {\n    default: \"\" as const,\n  },\n  // Image caption.\n  caption: {\n    default: \"\" as const,\n  },\n  // Image width in px.\n  width: {\n    default: 512 as const,\n  },\n} satisfies PropSchema;\n\n// Converts text alignment prop values to the flexbox `align-items` values.\nconst textAlignmentToAlignItems = (\n  textAlignment: \"left\" | \"center\" | \"right\" | \"justify\"\n): \"flex-start\" | \"center\" | \"flex-end\" => {\n  switch (textAlignment) {\n    case \"left\":\n      return \"flex-start\";\n    case \"center\":\n      return \"center\";\n    case \"right\":\n      return \"flex-end\";\n    default:\n      return \"flex-start\";\n  }\n};\n\n// Min image width in px.\nconst minWidth = 64;\n\nconst blockConfig = {\n  type: \"image\" as const,\n  propSchema: imagePropSchema,\n  content: \"none\",\n} satisfies CustomBlockConfig;\n\nexport const renderImage = (\n  block: BlockFromConfig<typeof blockConfig, InlineContentSchema, StyleSchema>,\n  editor: BlockNoteEditor<BlockSchemaWithBlock<\"image\", typeof blockConfig>>\n) => {\n  // Wrapper element to set the image alignment, contains both image/image\n  // upload dashboard and caption.\n  const wrapper = document.createElement(\"div\");\n  wrapper.className = \"bn-image-block-content-wrapper\";\n  wrapper.style.alignItems = textAlignmentToAlignItems(\n    block.props.textAlignment\n  );\n\n  // Button element that acts as a placeholder for images with no src.\n  const addImageButton = document.createElement(\"div\");\n  addImageButton.className = \"bn-add-image-button\";\n\n  // Icon for the add image button.\n  const addImageButtonIcon = document.createElement(\"div\");\n  addImageButtonIcon.className = \"bn-add-image-button-icon\";\n\n  // Text for the add image button.\n  const addImageButtonText = document.createElement(\"p\");\n  addImageButtonText.className = \"bn-add-image-button-text\";\n  addImageButtonText.innerText = \"Add Image\";\n\n  // Wrapper element for the image, resize handles and caption.\n  const imageAndCaptionWrapper = document.createElement(\"div\");\n  imageAndCaptionWrapper.className = \"bn-image-and-caption-wrapper\";\n\n  // Wrapper element for the image and resize handles.\n  const imageWrapper = document.createElement(\"div\");\n  imageWrapper.className = \"bn-image-wrapper\";\n\n  // Image element.\n  const image = document.createElement(\"img\");\n  image.className = \"bn-image\";\n  image.src = block.props.url;\n  image.alt = \"placeholder\";\n  image.contentEditable = \"false\";\n  image.draggable = false;\n  image.style.width = `${Math.min(\n    block.props.width,\n    editor.domElement.firstElementChild!.clientWidth\n  )}px`;\n\n  // Resize handle elements.\n  const leftResizeHandle = document.createElement(\"div\");\n  leftResizeHandle.className = \"bn-image-resize-handle\";\n  leftResizeHandle.style.left = \"4px\";\n  const rightResizeHandle = document.createElement(\"div\");\n  rightResizeHandle.className = \"bn-image-resize-handle\";\n  rightResizeHandle.style.right = \"4px\";\n\n  // Caption element.\n  const caption = document.createElement(\"p\");\n  caption.className = \"bn-image-caption\";\n  caption.innerText = block.props.caption;\n  caption.style.padding = block.props.caption ? \"4px\" : \"\";\n\n  // Adds a light blue outline to selected image blocks.\n  const handleEditorUpdate = () => {\n    const selection = editor.getSelection()?.blocks || [];\n    const currentBlock = editor.getTextCursorPosition().block;\n\n    const isSelected =\n      [currentBlock, ...selection].find(\n        (selectedBlock) => selectedBlock.id === block.id\n      ) !== undefined;\n\n    if (isSelected) {\n      addImageButton.style.outline = \"4px solid rgb(100, 160, 255)\";\n      imageAndCaptionWrapper.style.outline = \"4px solid rgb(100, 160, 255)\";\n    } else {\n      addImageButton.style.outline = \"\";\n      imageAndCaptionWrapper.style.outline = \"\";\n    }\n  };\n  editor.onEditorContentChange(handleEditorUpdate);\n  editor.onEditorSelectionChange(handleEditorUpdate);\n\n  // Temporary parameters set when the user begins resizing the image, used to\n  // calculate the new width of the image.\n  let resizeParams:\n    | {\n        handleUsed: \"left\" | \"right\";\n        initialWidth: number;\n        initialClientX: number;\n      }\n    | undefined;\n\n  // Updates the image width with an updated width depending on the cursor X\n  // offset from when the resize began, and which resize handle is being used.\n  const windowMouseMoveHandler = (event: MouseEvent) => {\n    if (!resizeParams) {\n      if (\n        !editor.isEditable &&\n        imageWrapper.contains(leftResizeHandle) &&\n        imageWrapper.contains(rightResizeHandle)\n      ) {\n        imageWrapper.removeChild(leftResizeHandle);\n        imageWrapper.removeChild(rightResizeHandle);\n      }\n\n      return;\n    }\n\n    let newWidth: number;\n\n    if (textAlignmentToAlignItems(block.props.textAlignment) === \"center\") {\n      if (resizeParams.handleUsed === \"left\") {\n        newWidth =\n          resizeParams.initialWidth +\n          (resizeParams.initialClientX - event.clientX) * 2;\n      } else {\n        newWidth =\n          resizeParams.initialWidth +\n          (event.clientX - resizeParams.initialClientX) * 2;\n      }\n    } else {\n      if (resizeParams.handleUsed === \"left\") {\n        newWidth =\n          resizeParams.initialWidth +\n          resizeParams.initialClientX -\n          event.clientX;\n      } else {\n        newWidth =\n          resizeParams.initialWidth +\n          event.clientX -\n          resizeParams.initialClientX;\n      }\n    }\n\n    // Ensures the image is not wider than the editor and not smaller than a\n    // predetermined minimum width.\n    if (newWidth < minWidth) {\n      image.style.width = `${minWidth}px`;\n    } else if (newWidth > editor.domElement.firstElementChild!.clientWidth) {\n      image.style.width = `${\n        editor.domElement.firstElementChild!.clientWidth\n      }px`;\n    } else {\n      image.style.width = `${newWidth}px`;\n    }\n  };\n  // Stops mouse movements from resizing the image and updates the block's\n  // `width` prop to the new value.\n  const windowMouseUpHandler = (event: MouseEvent) => {\n    // Hides the drag handles if the cursor is no longer over the image.\n    if (\n      (!event.target ||\n        !imageWrapper.contains(event.target as Node) ||\n        !editor.isEditable) &&\n      imageWrapper.contains(leftResizeHandle) &&\n      imageWrapper.contains(rightResizeHandle)\n    ) {\n      imageWrapper.removeChild(leftResizeHandle);\n      imageWrapper.removeChild(rightResizeHandle);\n    }\n\n    if (!resizeParams) {\n      return;\n    }\n\n    resizeParams = undefined;\n\n    editor.updateBlock(block, {\n      type: \"image\",\n      props: {\n        // Removes \"px\" from the end of the width string and converts to float.\n        width: parseFloat(image.style.width.slice(0, -2)) as any,\n      },\n    });\n  };\n\n  // Prevents focus from moving to the button.\n  const addImageButtonMouseDownHandler = (event: MouseEvent) => {\n    event.preventDefault();\n  };\n  // Opens the image toolbar.\n  const addImageButtonClickHandler = () => {\n    editor._tiptapEditor.view.dispatch(\n      editor._tiptapEditor.state.tr.setMeta(editor.imagePanel!.plugin, {\n        block: block,\n      })\n    );\n  };\n\n  // Shows the resize handles when hovering over the image with the cursor.\n  const imageMouseEnterHandler = () => {\n    if (editor.isEditable) {\n      imageWrapper.appendChild(leftResizeHandle);\n      imageWrapper.appendChild(rightResizeHandle);\n    }\n  };\n  // Hides the resize handles when the cursor leaves the image, unless the\n  // cursor moves to one of the resize handles.\n  const imageMouseLeaveHandler = (event: MouseEvent) => {\n    if (\n      event.relatedTarget === leftResizeHandle ||\n      event.relatedTarget === rightResizeHandle\n    ) {\n      return;\n    }\n\n    if (resizeParams) {\n      return;\n    }\n\n    if (\n      editor.isEditable &&\n      imageWrapper.contains(leftResizeHandle) &&\n      imageWrapper.contains(rightResizeHandle)\n    ) {\n      imageWrapper.removeChild(leftResizeHandle);\n      imageWrapper.removeChild(rightResizeHandle);\n    }\n  };\n\n  // Sets the resize params, allowing the user to begin resizing the image by\n  // moving the cursor left or right.\n  const leftResizeHandleMouseDownHandler = (event: MouseEvent) => {\n    event.preventDefault();\n\n    imageWrapper.appendChild(leftResizeHandle);\n    imageWrapper.appendChild(rightResizeHandle);\n\n    resizeParams = {\n      handleUsed: \"left\",\n      initialWidth: block.props.width,\n      initialClientX: event.clientX,\n    };\n  };\n  const rightResizeHandleMouseDownHandler = (event: MouseEvent) => {\n    event.preventDefault();\n\n    imageWrapper.appendChild(leftResizeHandle);\n    imageWrapper.appendChild(rightResizeHandle);\n\n    resizeParams = {\n      handleUsed: \"right\",\n      initialWidth: block.props.width,\n      initialClientX: event.clientX,\n    };\n  };\n\n  addImageButton.appendChild(addImageButtonIcon);\n  addImageButton.appendChild(addImageButtonText);\n\n  imageAndCaptionWrapper.appendChild(imageWrapper);\n  imageWrapper.appendChild(image);\n  imageAndCaptionWrapper.appendChild(caption);\n\n  if (block.props.url === \"\") {\n    wrapper.appendChild(addImageButton);\n  } else {\n    wrapper.appendChild(imageAndCaptionWrapper);\n  }\n\n  window.addEventListener(\"mousemove\", windowMouseMoveHandler);\n  window.addEventListener(\"mouseup\", windowMouseUpHandler);\n  addImageButton.addEventListener(\"mousedown\", addImageButtonMouseDownHandler);\n  addImageButton.addEventListener(\"click\", addImageButtonClickHandler);\n  image.addEventListener(\"mouseenter\", imageMouseEnterHandler);\n  image.addEventListener(\"mouseleave\", imageMouseLeaveHandler);\n  leftResizeHandle.addEventListener(\n    \"mousedown\",\n    leftResizeHandleMouseDownHandler\n  );\n  rightResizeHandle.addEventListener(\n    \"mousedown\",\n    rightResizeHandleMouseDownHandler\n  );\n\n  return {\n    dom: wrapper,\n    destroy: () => {\n      window.removeEventListener(\"mousemove\", windowMouseMoveHandler);\n      window.removeEventListener(\"mouseup\", windowMouseUpHandler);\n      addImageButton.removeEventListener(\n        \"mousedown\",\n        addImageButtonMouseDownHandler\n      );\n      addImageButton.removeEventListener(\"click\", addImageButtonClickHandler);\n      leftResizeHandle.removeEventListener(\n        \"mousedown\",\n        leftResizeHandleMouseDownHandler\n      );\n      rightResizeHandle.removeEventListener(\n        \"mousedown\",\n        rightResizeHandleMouseDownHandler\n      );\n    },\n  };\n};\n\nexport const Image = createBlockSpec(\n  {\n    type: \"image\" as const,\n    propSchema: imagePropSchema,\n    content: \"none\",\n  },\n  {\n    render: renderImage,\n    toExternalHTML: (block) => {\n      if (block.props.url === \"\") {\n        const div = document.createElement(\"p\");\n        div.innerHTML = \"Add Image\";\n\n        return {\n          dom: div,\n        };\n      }\n\n      const figure = document.createElement(\"figure\");\n\n      const img = document.createElement(\"img\");\n      img.src = block.props.url;\n      figure.appendChild(img);\n\n      if (block.props.caption !== \"\") {\n        const figcaption = document.createElement(\"figcaption\");\n        figcaption.innerHTML = block.props.caption;\n        figure.appendChild(figcaption);\n      }\n\n      return {\n        dom: figure,\n      };\n    },\n    parse: (element: HTMLElement) => {\n      if (element.tagName === \"FIGURE\") {\n        const img = element.querySelector(\"img\");\n        const caption = element.querySelector(\"figcaption\");\n        return {\n          url: img?.getAttribute(\"src\") || \"\",\n          caption:\n            caption?.textContent || img?.getAttribute(\"alt\") || undefined,\n        };\n      } else if (element.tagName === \"IMG\") {\n        return {\n          url: element.getAttribute(\"src\") || \"\",\n          caption: element.getAttribute(\"alt\") || undefined,\n        };\n      }\n\n      return undefined;\n    },\n  }\n);\n","import { Editor } from \"@tiptap/core\";\nimport { getBlockInfoFromPos } from \"../../api/getBlockInfoFromPos\";\n\nexport const handleEnter = (editor: Editor) => {\n  const { node, contentType } = getBlockInfoFromPos(\n    editor.state.doc,\n    editor.state.selection.from\n  )!;\n\n  const selectionEmpty =\n    editor.state.selection.anchor === editor.state.selection.head;\n\n  if (\n    !(\n      contentType.name === \"bulletListItem\" ||\n      contentType.name === \"numberedListItem\"\n    ) ||\n    !selectionEmpty\n  ) {\n    return false;\n  }\n\n  return editor.commands.first(({ state, chain, commands }) => [\n    () =>\n      // Changes list item block to a text block if the content is empty.\n      commands.command(() => {\n        if (node.textContent.length === 0) {\n          return commands.BNUpdateBlock(state.selection.from, {\n            type: \"paragraph\",\n            props: {},\n          });\n        }\n\n        return false;\n      }),\n\n    () =>\n      // Splits the current block, moving content inside that's after the cursor to a new block of the same type\n      // below.\n      commands.command(() => {\n        if (node.textContent.length > 0) {\n          chain()\n            .deleteSelection()\n            .BNSplitBlock(state.selection.from, true)\n            .run();\n\n          return true;\n        }\n\n        return false;\n      }),\n  ]);\n};\n","import { InputRule } from \"@tiptap/core\";\nimport {\n  PropSchema,\n  createBlockSpecFromStronglyTypedTiptapNode,\n  createStronglyTypedTiptapNode,\n} from \"../../../schema\";\nimport { createDefaultBlockDOMOutputSpec } from \"../../defaultBlockHelpers\";\nimport { defaultProps } from \"../../defaultProps\";\nimport { handleEnter } from \"../ListItemKeyboardShortcuts\";\nimport { getCurrentBlockContentType } from \"../../../api/getCurrentBlockContentType\";\n\nexport const bulletListItemPropSchema = {\n  ...defaultProps,\n} satisfies PropSchema;\n\nconst BulletListItemBlockContent = createStronglyTypedTiptapNode({\n  name: \"bulletListItem\",\n  content: \"inline*\",\n  group: \"blockContent\",\n  addInputRules() {\n    return [\n      // Creates an unordered list when starting with \"-\", \"+\", or \"*\".\n      new InputRule({\n        find: new RegExp(`^[-+*]\\\\s$`),\n        handler: ({ state, chain, range }) => {\n          if (getCurrentBlockContentType(this.editor) !== \"inline*\") {\n            return;\n          }\n\n          chain()\n            .BNUpdateBlock(state.selection.from, {\n              type: \"bulletListItem\",\n              props: {},\n            })\n            // Removes the \"-\", \"+\", or \"*\" character used to set the list.\n            .deleteRange({ from: range.from, to: range.to });\n        },\n      }),\n    ];\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => handleEnter(this.editor),\n      \"Mod-Shift-8\": () => {\n        if (getCurrentBlockContentType(this.editor) !== \"inline*\") {\n          return true;\n        }\n\n        return this.editor.commands.BNUpdateBlock(\n          this.editor.state.selection.anchor,\n          {\n            type: \"bulletListItem\",\n            props: {},\n          }\n        );\n      },\n    };\n  },\n\n  parseHTML() {\n    return [\n      // Case for regular HTML list structure.\n      {\n        tag: \"div[data-content-type=\" + this.name + \"]\", // TODO: remove if we can't come up with test case that needs this\n      },\n      {\n        tag: \"li\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          const parent = element.parentElement;\n\n          if (parent === null) {\n            return false;\n          }\n\n          if (\n            parent.tagName === \"UL\" ||\n            (parent.tagName === \"DIV\" && parent.parentElement!.tagName === \"UL\")\n          ) {\n            return {};\n          }\n\n          return false;\n        },\n        node: \"bulletListItem\",\n      },\n      // Case for BlockNote list structure.\n      {\n        tag: \"p\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          const parent = element.parentElement;\n\n          if (parent === null) {\n            return false;\n          }\n\n          if (parent.getAttribute(\"data-content-type\") === \"bulletListItem\") {\n            return {};\n          }\n\n          return false;\n        },\n        priority: 300,\n        node: \"bulletListItem\",\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return createDefaultBlockDOMOutputSpec(\n      this.name,\n      // We use a <p> tag, because for <li> tags we'd need a <ul> element to put\n      // them in to be semantically correct, which we can't have due to the\n      // schema.\n      \"p\",\n      {\n        ...(this.options.domAttributes?.blockContent || {}),\n        ...HTMLAttributes,\n      },\n      this.options.domAttributes?.inlineContent || {}\n    );\n  },\n});\n\nexport const BulletListItem = createBlockSpecFromStronglyTypedTiptapNode(\n  BulletListItemBlockContent,\n  bulletListItemPropSchema\n);\n","import { Plugin, PluginKey } from \"prosemirror-state\";\nimport { getBlockInfoFromPos } from \"../../../api/getBlockInfoFromPos\";\n\n// ProseMirror Plugin which automatically assigns indices to ordered list items per nesting level.\nconst PLUGIN_KEY = new PluginKey(`numbered-list-indexing`);\nexport const NumberedListIndexingPlugin = () => {\n  return new Plugin({\n    key: PLUGIN_KEY,\n    appendTransaction: (_transactions, _oldState, newState) => {\n      const tr = newState.tr;\n      tr.setMeta(\"numberedListIndexing\", true);\n\n      let modified = false;\n\n      // Traverses each node the doc using DFS, so blocks which are on the same nesting level will be traversed in the\n      // same order they appear. This means the index of each list item block can be calculated by incrementing the\n      // index of the previous list item block.\n      newState.doc.descendants((node, pos) => {\n        if (\n          node.type.name === \"blockContainer\" &&\n          node.firstChild!.type.name === \"numberedListItem\"\n        ) {\n          let newIndex = \"1\";\n          const isFirstBlockInDoc = pos === 1;\n\n          const blockInfo = getBlockInfoFromPos(tr.doc, pos + 1)!;\n          if (blockInfo === undefined) {\n            return;\n          }\n\n          // Checks if this block is the start of a new ordered list, i.e. if it's the first block in the document, the\n          // first block in its nesting level, or the previous block is not an ordered list item.\n          if (!isFirstBlockInDoc) {\n            const prevBlockInfo = getBlockInfoFromPos(tr.doc, pos - 2)!;\n            if (prevBlockInfo === undefined) {\n              return;\n            }\n\n            const isFirstBlockInNestingLevel =\n              blockInfo.depth !== prevBlockInfo.depth;\n\n            if (!isFirstBlockInNestingLevel) {\n              const prevBlockContentNode = prevBlockInfo.contentNode;\n              const prevBlockContentType = prevBlockInfo.contentType;\n\n              const isPrevBlockOrderedListItem =\n                prevBlockContentType.name === \"numberedListItem\";\n\n              if (isPrevBlockOrderedListItem) {\n                const prevBlockIndex = prevBlockContentNode.attrs[\"index\"];\n\n                newIndex = (parseInt(prevBlockIndex) + 1).toString();\n              }\n            }\n          }\n\n          const contentNode = blockInfo.contentNode;\n          const index = contentNode.attrs[\"index\"];\n\n          if (index !== newIndex) {\n            modified = true;\n\n            tr.setNodeMarkup(pos + 1, undefined, {\n              index: newIndex,\n            });\n          }\n        }\n      });\n\n      return modified ? tr : null;\n    },\n  });\n};\n","import { InputRule } from \"@tiptap/core\";\nimport {\n  PropSchema,\n  createBlockSpecFromStronglyTypedTiptapNode,\n  createStronglyTypedTiptapNode,\n} from \"../../../schema\";\nimport { createDefaultBlockDOMOutputSpec } from \"../../defaultBlockHelpers\";\nimport { defaultProps } from \"../../defaultProps\";\nimport { handleEnter } from \"../ListItemKeyboardShortcuts\";\nimport { NumberedListIndexingPlugin } from \"./NumberedListIndexingPlugin\";\nimport { getCurrentBlockContentType } from \"../../../api/getCurrentBlockContentType\";\n\nexport const numberedListItemPropSchema = {\n  ...defaultProps,\n} satisfies PropSchema;\n\nconst NumberedListItemBlockContent = createStronglyTypedTiptapNode({\n  name: \"numberedListItem\",\n  content: \"inline*\",\n  group: \"blockContent\",\n  addAttributes() {\n    return {\n      index: {\n        default: null,\n        parseHTML: (element) => element.getAttribute(\"data-index\"),\n        renderHTML: (attributes) => {\n          return {\n            \"data-index\": attributes.index,\n          };\n        },\n      },\n    };\n  },\n\n  addInputRules() {\n    return [\n      // Creates an ordered list when starting with \"1.\".\n      new InputRule({\n        find: new RegExp(`^1\\\\.\\\\s$`),\n        handler: ({ state, chain, range }) => {\n          if (getCurrentBlockContentType(this.editor) !== \"inline*\") {\n            return;\n          }\n\n          chain()\n            .BNUpdateBlock(state.selection.from, {\n              type: \"numberedListItem\",\n              props: {},\n            })\n            // Removes the \"1.\" characters used to set the list.\n            .deleteRange({ from: range.from, to: range.to });\n        },\n      }),\n    ];\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => handleEnter(this.editor),\n      \"Mod-Shift-7\": () => {\n        if (getCurrentBlockContentType(this.editor) !== \"inline*\") {\n          return true;\n        }\n\n        return this.editor.commands.BNUpdateBlock(\n          this.editor.state.selection.anchor,\n          {\n            type: \"numberedListItem\",\n            props: {},\n          }\n        );\n      },\n    };\n  },\n\n  addProseMirrorPlugins() {\n    return [NumberedListIndexingPlugin()];\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: \"div[data-content-type=\" + this.name + \"]\", // TODO: remove if we can't come up with test case that needs this\n      },\n      // Case for regular HTML list structure.\n      // (e.g.: when pasting from other apps)\n      {\n        tag: \"li\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          const parent = element.parentElement;\n\n          if (parent === null) {\n            return false;\n          }\n\n          if (\n            parent.tagName === \"OL\" ||\n            (parent.tagName === \"DIV\" && parent.parentElement!.tagName === \"OL\")\n          ) {\n            return {};\n          }\n\n          return false;\n        },\n        node: \"numberedListItem\",\n      },\n      // Case for BlockNote list structure.\n      // (e.g.: when pasting from blocknote)\n      {\n        tag: \"p\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          const parent = element.parentElement;\n\n          if (parent === null) {\n            return false;\n          }\n\n          if (parent.getAttribute(\"data-content-type\") === \"numberedListItem\") {\n            return {};\n          }\n\n          return false;\n        },\n        priority: 300,\n        node: \"numberedListItem\",\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return createDefaultBlockDOMOutputSpec(\n      this.name,\n      // We use a <p> tag, because for <li> tags we'd need an <ol> element to\n      // put them in to be semantically correct, which we can't have due to the\n      // schema.\n      \"p\",\n      {\n        ...(this.options.domAttributes?.blockContent || {}),\n        ...HTMLAttributes,\n      },\n      this.options.domAttributes?.inlineContent || {}\n    );\n  },\n});\n\nexport const NumberedListItem = createBlockSpecFromStronglyTypedTiptapNode(\n  NumberedListItemBlockContent,\n  numberedListItemPropSchema\n);\n","import {\n  createBlockSpecFromStronglyTypedTiptapNode,\n  createStronglyTypedTiptapNode,\n} from \"../../schema\";\nimport { createDefaultBlockDOMOutputSpec } from \"../defaultBlockHelpers\";\nimport { defaultProps } from \"../defaultProps\";\nimport { handleEnter } from \"../ListItemBlockContent/ListItemKeyboardShortcuts\";\nimport { getCurrentBlockContentType } from \"../../api/getCurrentBlockContentType\";\n\nexport const paragraphPropSchema = {\n  ...defaultProps,\n};\n\nexport const ParagraphBlockContent = createStronglyTypedTiptapNode({\n  name: \"paragraph\",\n  content: \"inline*\",\n  group: \"blockContent\",\n\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => handleEnter(this.editor),\n      \"Mod-Alt-0\": () => {\n        if (getCurrentBlockContentType(this.editor) !== \"inline*\") {\n          return true;\n        }\n\n        return this.editor.commands.BNUpdateBlock(\n          this.editor.state.selection.anchor,\n          {\n            type: \"paragraph\",\n            props: {},\n          }\n        );\n      },\n    };\n  },\n\n  parseHTML() {\n    return [\n      { tag: \"div[data-content-type=\" + this.name + \"]\" },\n      {\n        tag: \"p\",\n        priority: 200,\n        node: \"paragraph\",\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return createDefaultBlockDOMOutputSpec(\n      this.name,\n      \"p\",\n      {\n        ...(this.options.domAttributes?.blockContent || {}),\n        ...HTMLAttributes,\n      },\n      this.options.domAttributes?.inlineContent || {}\n    );\n  },\n});\n\nexport const Paragraph = createBlockSpecFromStronglyTypedTiptapNode(\n  ParagraphBlockContent,\n  paragraphPropSchema\n);\n","import { callOrReturn, Extension, getExtensionField } from \"@tiptap/core\";\nimport { columnResizing, tableEditing } from \"prosemirror-tables\";\n\nexport const TableExtension = Extension.create({\n  name: \"BlockNoteTableExtension\",\n\n  addProseMirrorPlugins: () => {\n    return [\n      columnResizing({\n        cellMinWidth: 100,\n      }),\n      tableEditing(),\n    ];\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      // Makes enter create a new line within the cell.\n      Enter: () => {\n        if (\n          this.editor.state.selection.empty &&\n          this.editor.state.selection.$head.parent.type.name ===\n            \"tableParagraph\"\n        ) {\n          this.editor.commands.setHardBreak();\n\n          return true;\n        }\n\n        return false;\n      },\n      // Ensures that backspace won't delete the table if the text cursor is at\n      // the start of a cell and the selection is empty.\n      Backspace: () => {\n        const selection = this.editor.state.selection;\n        const selectionIsEmpty = selection.empty;\n        const selectionIsAtStartOfNode = selection.$head.parentOffset === 0;\n        const selectionIsInTableParagraphNode =\n          selection.$head.node().type.name === \"tableParagraph\";\n\n        return (\n          selectionIsEmpty &&\n          selectionIsAtStartOfNode &&\n          selectionIsInTableParagraphNode\n        );\n      },\n    };\n  },\n\n  extendNodeSchema(extension) {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    };\n\n    return {\n      tableRole: callOrReturn(\n        getExtensionField(extension, \"tableRole\", context)\n      ),\n    };\n  },\n});\n","import { mergeAttributes, Node } from \"@tiptap/core\";\nimport { TableCell } from \"@tiptap/extension-table-cell\";\nimport { TableHeader } from \"@tiptap/extension-table-header\";\nimport { TableRow } from \"@tiptap/extension-table-row\";\nimport {\n  createBlockSpecFromStronglyTypedTiptapNode,\n  createStronglyTypedTiptapNode,\n} from \"../../schema\";\nimport { createDefaultBlockDOMOutputSpec } from \"../defaultBlockHelpers\";\nimport { defaultProps } from \"../defaultProps\";\nimport { TableExtension } from \"./TableExtension\";\n\nexport const tablePropSchema = {\n  ...defaultProps,\n};\n\nexport const TableBlockContent = createStronglyTypedTiptapNode({\n  name: \"table\",\n  content: \"tableRow+\",\n  group: \"blockContent\",\n  tableRole: \"table\",\n\n  isolating: true,\n\n  parseHTML() {\n    return [{ tag: \"table\" }];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return createDefaultBlockDOMOutputSpec(\n      this.name,\n      \"table\",\n      {\n        ...(this.options.domAttributes?.blockContent || {}),\n        ...HTMLAttributes,\n      },\n      this.options.domAttributes?.inlineContent || {}\n    );\n  },\n});\n\nconst TableParagraph = Node.create({\n  name: \"tableParagraph\",\n  group: \"tableContent\",\n  content: \"inline*\",\n\n  parseHTML() {\n    return [{ tag: \"p\" }];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      \"p\",\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n      0,\n    ];\n  },\n});\n\nexport const Table = createBlockSpecFromStronglyTypedTiptapNode(\n  TableBlockContent,\n  tablePropSchema,\n  [\n    TableExtension,\n    TableParagraph,\n    TableHeader.extend({\n      content: \"tableContent\",\n    }),\n    TableCell.extend({\n      content: \"tableContent\",\n    }),\n    TableRow,\n  ]\n);\n","import Bold from \"@tiptap/extension-bold\";\nimport Code from \"@tiptap/extension-code\";\nimport Italic from \"@tiptap/extension-italic\";\nimport Strike from \"@tiptap/extension-strike\";\nimport Underline from \"@tiptap/extension-underline\";\nimport { BackgroundColor } from \"../extensions/BackgroundColor/BackgroundColorMark\";\nimport { TextColor } from \"../extensions/TextColor/TextColorMark\";\nimport {\n  BlockNoDefaults,\n  BlockSchema,\n  BlockSpecs,\n  InlineContentSchema,\n  InlineContentSpecs,\n  PartialBlockNoDefaults,\n  StyleSchema,\n  StyleSpecs,\n  createStyleSpecFromTipTapMark,\n  getBlockSchemaFromSpecs,\n  getInlineContentSchemaFromSpecs,\n  getStyleSchemaFromSpecs,\n} from \"../schema\";\nimport { Heading } from \"./HeadingBlockContent/HeadingBlockContent\";\nimport { Image } from \"./ImageBlockContent/ImageBlockContent\";\nimport { BulletListItem } from \"./ListItemBlockContent/BulletListItemBlockContent/BulletListItemBlockContent\";\nimport { NumberedListItem } from \"./ListItemBlockContent/NumberedListItemBlockContent/NumberedListItemBlockContent\";\nimport { Paragraph } from \"./ParagraphBlockContent/ParagraphBlockContent\";\nimport { Table } from \"./TableBlockContent/TableBlockContent\";\n\nexport const defaultBlockSpecs = {\n  paragraph: Paragraph,\n  heading: Heading,\n  bulletListItem: BulletListItem,\n  numberedListItem: NumberedListItem,\n  image: Image,\n  table: Table,\n} satisfies BlockSpecs;\n\nexport const defaultBlockSchema = getBlockSchemaFromSpecs(defaultBlockSpecs);\n\n// underscore is used that in case a user overrides DefaultBlockSchema,\n// they can still access the original default block schema\nexport type _DefaultBlockSchema = typeof defaultBlockSchema;\nexport type DefaultBlockSchema = _DefaultBlockSchema;\n\nexport const defaultStyleSpecs = {\n  bold: createStyleSpecFromTipTapMark(Bold, \"boolean\"),\n  italic: createStyleSpecFromTipTapMark(Italic, \"boolean\"),\n  underline: createStyleSpecFromTipTapMark(Underline, \"boolean\"),\n  strike: createStyleSpecFromTipTapMark(Strike, \"boolean\"),\n  code: createStyleSpecFromTipTapMark(Code, \"boolean\"),\n  textColor: TextColor,\n  backgroundColor: BackgroundColor,\n} satisfies StyleSpecs;\n\nexport const defaultStyleSchema = getStyleSchemaFromSpecs(defaultStyleSpecs);\n\n// underscore is used that in case a user overrides DefaultStyleSchema,\n// they can still access the original default style schema\nexport type _DefaultStyleSchema = typeof defaultStyleSchema;\nexport type DefaultStyleSchema = _DefaultStyleSchema;\n\nexport const defaultInlineContentSpecs = {\n  text: { config: \"text\", implementation: {} as any },\n  link: { config: \"link\", implementation: {} as any },\n} satisfies InlineContentSpecs;\n\nexport const defaultInlineContentSchema = getInlineContentSchemaFromSpecs(\n  defaultInlineContentSpecs\n);\n\n// underscore is used that in case a user overrides DefaultInlineContentSchema,\n// they can still access the original default inline content schema\nexport type _DefaultInlineContentSchema = typeof defaultInlineContentSchema;\nexport type DefaultInlineContentSchema = _DefaultInlineContentSchema;\n\nexport type PartialBlock<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  I extends InlineContentSchema = DefaultInlineContentSchema,\n  S extends StyleSchema = DefaultStyleSchema\n> = PartialBlockNoDefaults<BSchema, I, S>;\n\nexport type Block<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  I extends InlineContentSchema = DefaultInlineContentSchema,\n  S extends StyleSchema = DefaultStyleSchema\n> = BlockNoDefaults<BSchema, I, S>;\n","import type { BlockNoteEditor } from \"../editor/BlockNoteEditor\";\nimport { BlockFromConfig, InlineContentSchema, StyleSchema } from \"../schema\";\nimport { Block, DefaultBlockSchema, defaultBlockSchema } from \"./defaultBlocks\";\nimport { defaultProps } from \"./defaultProps\";\n\nexport function checkDefaultBlockTypeInSchema<\n  BlockType extends keyof DefaultBlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  blockType: BlockType,\n  editor: BlockNoteEditor<any, I, S>\n): editor is BlockNoteEditor<{ Type: DefaultBlockSchema[BlockType] }, I, S> {\n  return (\n    blockType in editor.schema.blockSchema &&\n    editor.schema.blockSchema[blockType] === defaultBlockSchema[blockType]\n  );\n}\n\nexport function checkBlockIsDefaultType<\n  BlockType extends keyof DefaultBlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  blockType: BlockType,\n  block: Block<any, I, S>,\n  editor: BlockNoteEditor<any, I, S>\n): block is BlockFromConfig<DefaultBlockSchema[BlockType], I, S> {\n  return (\n    block.type === blockType &&\n    block.type in editor.schema.blockSchema &&\n    checkDefaultBlockTypeInSchema(block.type, editor)\n  );\n}\n\nexport function checkBlockTypeHasDefaultProp<\n  Prop extends keyof typeof defaultProps,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  prop: Prop,\n  blockType: string,\n  editor: BlockNoteEditor<any, I, S>\n): editor is BlockNoteEditor<\n  {\n    [BT in string]: {\n      type: BT;\n      propSchema: {\n        [P in Prop]: (typeof defaultProps)[P];\n      };\n      content: \"table\" | \"inline\" | \"none\";\n    };\n  },\n  I,\n  S\n> {\n  return (\n    blockType in editor.schema.blockSchema &&\n    prop in editor.schema.blockSchema[blockType].propSchema &&\n    editor.schema.blockSchema[blockType].propSchema[prop] === defaultProps[prop]\n  );\n}\n\nexport function checkBlockHasDefaultProp<\n  Prop extends keyof typeof defaultProps,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  prop: Prop,\n  block: Block<any, I, S>,\n  editor: BlockNoteEditor<any, I, S>\n): block is BlockFromConfig<\n  {\n    type: string;\n    propSchema: {\n      [P in Prop]: (typeof defaultProps)[P];\n    };\n    content: \"table\" | \"inline\" | \"none\";\n  },\n  I,\n  S\n> {\n  return checkBlockTypeHasDefaultProp(prop, block.type, editor);\n}\n","import { Node } from \"prosemirror-model\";\n\n/**\n * Get a TipTap node by id\n */\nexport function getNodeById(\n  id: string,\n  doc: Node\n): { node: Node; posBeforeNode: number } {\n  let targetNode: Node | undefined = undefined;\n  let posBeforeNode: number | undefined = undefined;\n\n  doc.firstChild!.descendants((node, pos) => {\n    // Skips traversing nodes after node with target ID has been found.\n    if (targetNode) {\n      return false;\n    }\n\n    // Keeps traversing nodes if block with target ID has not been found.\n    if (node.type.name !== \"blockContainer\" || node.attrs.id !== id) {\n      return true;\n    }\n\n    targetNode = node;\n    posBeforeNode = pos + 1;\n\n    return false;\n  });\n\n  if (targetNode === undefined || posBeforeNode === undefined) {\n    throw Error(\"Could not find block in the editor with matching ID.\");\n  }\n\n  return {\n    node: targetNode,\n    posBeforeNode: posBeforeNode,\n  };\n}\n","import { Node } from \"prosemirror-model\";\n\nimport { selectionToInsertionEnd } from \"@tiptap/core\";\nimport { Transaction } from \"prosemirror-state\";\nimport { Block, PartialBlock } from \"../../blocks/defaultBlocks\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor\";\nimport {\n  BlockIdentifier,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema\";\nimport { blockToNode, nodeToBlock } from \"../nodeConversions/nodeConversions\";\nimport { getNodeById } from \"../nodeUtil\";\n\nexport function insertBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  blocksToInsert: PartialBlock<BSchema, I, S>[],\n  referenceBlock: BlockIdentifier,\n  placement: \"before\" | \"after\" | \"nested\" = \"before\",\n  editor: BlockNoteEditor<BSchema, I, S>\n): Block<BSchema, I, S>[] {\n  const ttEditor = editor._tiptapEditor;\n\n  const id =\n    typeof referenceBlock === \"string\" ? referenceBlock : referenceBlock.id;\n\n  const nodesToInsert: Node[] = [];\n  for (const blockSpec of blocksToInsert) {\n    nodesToInsert.push(\n      blockToNode(blockSpec, ttEditor.schema, editor.schema.styleSchema)\n    );\n  }\n\n  const { node, posBeforeNode } = getNodeById(id, ttEditor.state.doc);\n\n  if (placement === \"before\") {\n    ttEditor.view.dispatch(\n      ttEditor.state.tr.insert(posBeforeNode, nodesToInsert)\n    );\n  }\n\n  if (placement === \"after\") {\n    ttEditor.view.dispatch(\n      ttEditor.state.tr.insert(posBeforeNode + node.nodeSize, nodesToInsert)\n    );\n  }\n\n  if (placement === \"nested\") {\n    // Case if block doesn't already have children.\n    if (node.childCount < 2) {\n      const blockGroupNode = ttEditor.state.schema.nodes[\"blockGroup\"].create(\n        {},\n        nodesToInsert\n      );\n\n      ttEditor.view.dispatch(\n        ttEditor.state.tr.insert(\n          posBeforeNode + node.firstChild!.nodeSize + 1,\n          blockGroupNode\n        )\n      );\n    }\n  }\n\n  // Now that the `PartialBlock`s have been converted to nodes, we can\n  // re-convert them into full `Block`s.\n  const insertedBlocks: Block<BSchema, I, S>[] = [];\n  for (const node of nodesToInsert) {\n    insertedBlocks.push(\n      nodeToBlock(\n        node,\n        editor.schema.blockSchema,\n        editor.schema.inlineContentSchema,\n        editor.schema.styleSchema,\n        editor.blockCache\n      )\n    );\n  }\n\n  return insertedBlocks;\n}\n\nexport function updateBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  blockToUpdate: BlockIdentifier,\n  update: PartialBlock<BSchema, I, S>,\n  editor: BlockNoteEditor<BSchema, I, S>\n): Block<BSchema, I, S> {\n  const ttEditor = editor._tiptapEditor;\n\n  const id =\n    typeof blockToUpdate === \"string\" ? blockToUpdate : blockToUpdate.id;\n  const { posBeforeNode } = getNodeById(id, ttEditor.state.doc);\n\n  ttEditor.commands.BNUpdateBlock(posBeforeNode + 1, update);\n\n  const blockContainerNode = ttEditor.state.doc\n    .resolve(posBeforeNode + 1)\n    .node();\n\n  return nodeToBlock(\n    blockContainerNode,\n    editor.schema.blockSchema,\n    editor.schema.inlineContentSchema,\n    editor.schema.styleSchema,\n    editor.blockCache\n  );\n}\n\nfunction removeBlocksWithCallback<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  blocksToRemove: BlockIdentifier[],\n  editor: BlockNoteEditor<BSchema, I, S>,\n  // Should return new removedSize.\n  callback?: (\n    node: Node,\n    pos: number,\n    tr: Transaction,\n    removedSize: number\n  ) => number\n): Block<BSchema, I, S>[] {\n  const ttEditor = editor._tiptapEditor;\n  const tr = ttEditor.state.tr;\n\n  const idsOfBlocksToRemove = new Set<string>(\n    blocksToRemove.map((block) =>\n      typeof block === \"string\" ? block : block.id\n    )\n  );\n  const removedBlocks: Block<BSchema, I, S>[] = [];\n  let removedSize = 0;\n\n  ttEditor.state.doc.descendants((node, pos) => {\n    // Skips traversing nodes after all target blocks have been removed.\n    if (idsOfBlocksToRemove.size === 0) {\n      return false;\n    }\n\n    // Keeps traversing nodes if block with target ID has not been found.\n    if (\n      node.type.name !== \"blockContainer\" ||\n      !idsOfBlocksToRemove.has(node.attrs.id)\n    ) {\n      return true;\n    }\n\n    // Saves the block that is being deleted.\n    removedBlocks.push(\n      nodeToBlock(\n        node,\n        editor.schema.blockSchema,\n        editor.schema.inlineContentSchema,\n        editor.schema.styleSchema,\n        editor.blockCache\n      )\n    );\n    idsOfBlocksToRemove.delete(node.attrs.id);\n\n    // Removes the block and calculates the change in document size.\n    removedSize = callback?.(node, pos, tr, removedSize) || removedSize;\n    const oldDocSize = tr.doc.nodeSize;\n    tr.delete(pos - removedSize - 1, pos - removedSize + node.nodeSize + 1);\n    const newDocSize = tr.doc.nodeSize;\n    removedSize += oldDocSize - newDocSize;\n\n    return false;\n  });\n\n  // Throws an error if now all blocks could be found.\n  if (idsOfBlocksToRemove.size > 0) {\n    const notFoundIds = [...idsOfBlocksToRemove].join(\"\\n\");\n\n    throw Error(\n      \"Blocks with the following IDs could not be found in the editor: \" +\n        notFoundIds\n    );\n  }\n\n  ttEditor.view.dispatch(tr);\n\n  return removedBlocks;\n}\n\nexport function removeBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  blocksToRemove: BlockIdentifier[],\n  editor: BlockNoteEditor<BSchema, I, S>\n): Block<BSchema, I, S>[] {\n  return removeBlocksWithCallback(blocksToRemove, editor);\n}\n\nexport function replaceBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  blocksToRemove: BlockIdentifier[],\n  blocksToInsert: PartialBlock<BSchema, I, S>[],\n  editor: BlockNoteEditor<BSchema, I, S>\n): {\n  insertedBlocks: Block<BSchema, I, S>[];\n  removedBlocks: Block<BSchema, I, S>[];\n} {\n  const ttEditor = editor._tiptapEditor;\n\n  const nodesToInsert: Node[] = [];\n  for (const block of blocksToInsert) {\n    nodesToInsert.push(\n      blockToNode(block, ttEditor.schema, editor.schema.styleSchema)\n    );\n  }\n\n  const idOfFirstBlock =\n    typeof blocksToRemove[0] === \"string\"\n      ? blocksToRemove[0]\n      : blocksToRemove[0].id;\n  const removedBlocks = removeBlocksWithCallback(\n    blocksToRemove,\n    editor,\n    (node, pos, tr, removedSize) => {\n      if (node.attrs.id === idOfFirstBlock) {\n        const oldDocSize = tr.doc.nodeSize;\n        tr.insert(pos, nodesToInsert);\n        const newDocSize = tr.doc.nodeSize;\n\n        return removedSize + oldDocSize - newDocSize;\n      }\n\n      return removedSize;\n    }\n  );\n\n  // Now that the `PartialBlock`s have been converted to nodes, we can\n  // re-convert them into full `Block`s.\n  const insertedBlocks: Block<BSchema, I, S>[] = [];\n  for (const node of nodesToInsert) {\n    insertedBlocks.push(\n      nodeToBlock(\n        node,\n        editor.schema.blockSchema,\n        editor.schema.inlineContentSchema,\n        editor.schema.styleSchema,\n        editor.blockCache\n      )\n    );\n  }\n\n  return { insertedBlocks, removedBlocks };\n}\n\n// similar to tiptap insertContentAt\nexport function insertContentAt<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  position: any,\n  nodes: Node[],\n  editor: BlockNoteEditor<BSchema, I, S>,\n  options: {\n    updateSelection: boolean;\n  } = { updateSelection: true }\n) {\n  const ttEditor = editor._tiptapEditor;\n  const tr = ttEditor.state.tr;\n\n  // don’t dispatch an empty fragment because this can lead to strange errors\n  // if (content.toString() === \"<>\") {\n  //   return true;\n  // }\n\n  let { from, to } =\n    typeof position === \"number\"\n      ? { from: position, to: position }\n      : { from: position.from, to: position.to };\n\n  let isOnlyTextContent = true;\n  let isOnlyBlockContent = true;\n  // const nodes = isFragment(content) ? content : [content];\n\n  let text = \"\";\n\n  nodes.forEach((node) => {\n    // check if added node is valid\n    node.check();\n\n    if (isOnlyTextContent && node.isText && node.marks.length === 0) {\n      text += node.text;\n    } else {\n      isOnlyTextContent = false;\n    }\n\n    isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;\n  });\n\n  // check if we can replace the wrapping node by\n  // the newly inserted content\n  // example:\n  // replace an empty paragraph by an inserted image\n  // instead of inserting the image below the paragraph\n  if (from === to && isOnlyBlockContent) {\n    const { parent } = tr.doc.resolve(from);\n    const isEmptyTextBlock =\n      parent.isTextblock && !parent.type.spec.code && !parent.childCount;\n\n    if (isEmptyTextBlock) {\n      from -= 1;\n      to += 1;\n    }\n  }\n\n  // if there is only plain text we have to use `insertText`\n  // because this will keep the current marks\n  if (isOnlyTextContent) {\n    // if value is string, we can use it directly\n    // otherwise if it is an array, we have to join it\n    // if (Array.isArray(value)) {\n    //   tr.insertText(value.map((v) => v.text || \"\").join(\"\"), from, to);\n    // } else if (typeof value === \"object\" && !!value && !!value.text) {\n    //   tr.insertText(value.text, from, to);\n    // } else {\n    //   tr.insertText(value as string, from, to);\n    // }\n    tr.insertText(text, from, to);\n  } else {\n    tr.replaceWith(from, to, nodes);\n  }\n\n  // set cursor at end of inserted content\n  if (options.updateSelection) {\n    selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\n  }\n\n  ttEditor.view.dispatch(tr);\n\n  return true;\n}\n","import { Element as HASTElement, Parent as HASTParent } from \"hast\";\n\n/**\n * Rehype plugin which removes <u> tags. Used to remove underlines before converting HTML to markdown, as Markdown\n * doesn't support underlines.\n */\nexport function removeUnderlines() {\n  const removeUnderlinesHelper = (tree: HASTParent) => {\n    let numChildElements = tree.children.length;\n\n    for (let i = 0; i < numChildElements; i++) {\n      const node = tree.children[i];\n\n      if (node.type === \"element\") {\n        // Recursively removes underlines from child elements.\n        removeUnderlinesHelper(node);\n\n        if ((node as HASTElement).tagName === \"u\") {\n          // Lifts child nodes outside underline element, deletes the underline element, and updates current index &\n          // the number of child elements.\n          if (node.children.length > 0) {\n            tree.children.splice(i, 1, ...node.children);\n\n            const numElementsAdded = node.children.length - 1;\n            numChildElements += numElementsAdded;\n            i += numElementsAdded;\n          } else {\n            tree.children.splice(i, 1);\n\n            numChildElements--;\n            i--;\n          }\n        }\n      }\n    }\n  };\n\n  return removeUnderlinesHelper;\n}\n","import { Schema } from \"prosemirror-model\";\nimport rehypeParse from \"rehype-parse\";\nimport rehypeRemark from \"rehype-remark\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkStringify from \"remark-stringify\";\nimport { unified } from \"unified\";\nimport { Block } from \"../../../blocks/defaultBlocks\";\nimport type { BlockNoteEditor } from \"../../../editor/BlockNoteEditor\";\nimport { BlockSchema, InlineContentSchema, StyleSchema } from \"../../../schema\";\nimport { createExternalHTMLExporter } from \"../html/externalHTMLExporter\";\nimport { removeUnderlines } from \"./removeUnderlinesRehypePlugin\";\n\nexport function cleanHTMLToMarkdown(cleanHTMLString: string) {\n  const markdownString = unified()\n    .use(rehypeParse, { fragment: true })\n    .use(removeUnderlines)\n    .use(rehypeRemark)\n    .use(remarkGfm)\n    .use(remarkStringify)\n    .processSync(cleanHTMLString);\n\n  return markdownString.value as string;\n}\n\nexport function blocksToMarkdown<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  blocks: Block<BSchema, I, S>[],\n  schema: Schema,\n  editor: BlockNoteEditor<BSchema, I, S>\n): string {\n  const exporter = createExternalHTMLExporter(schema, editor);\n  const externalHTML = exporter.exportBlocks(blocks);\n\n  return cleanHTMLToMarkdown(externalHTML);\n}\n","function getChildIndex(node: Element) {\n  return Array.prototype.indexOf.call(node.parentElement!.childNodes, node);\n}\n\nfunction isWhitespaceNode(node: Node) {\n  return node.nodeType === 3 && !/\\S/.test(node.nodeValue || \"\");\n}\n\n/**\n * Step 1, Turns:\n *\n * <ul>\n *  <li>item</li>\n *  <li>\n *   <ul>\n *      <li>...</li>\n *      <li>...</li>\n *   </ul>\n * </li>\n *\n * Into:\n * <ul>\n *  <li>item</li>\n *  <ul>\n *      <li>...</li>\n *      <li>...</li>\n *  </ul>\n * </ul>\n *\n */\nfunction liftNestedListsToParent(element: HTMLElement) {\n  element.querySelectorAll(\"li > ul, li > ol\").forEach((list) => {\n    const index = getChildIndex(list);\n    const parentListItem = list.parentElement!;\n    const siblingsAfter = Array.from(parentListItem.childNodes).slice(\n      index + 1\n    );\n    list.remove();\n    siblingsAfter.forEach((sibling) => {\n      sibling.remove();\n    });\n\n    parentListItem.insertAdjacentElement(\"afterend\", list);\n\n    siblingsAfter.reverse().forEach((sibling) => {\n      if (isWhitespaceNode(sibling)) {\n        return;\n      }\n      const siblingContainer = document.createElement(\"li\");\n      siblingContainer.append(sibling);\n      list.insertAdjacentElement(\"afterend\", siblingContainer);\n    });\n    if (parentListItem.childNodes.length === 0) {\n      parentListItem.remove();\n    }\n  });\n}\n\n/**\n * Step 2, Turns (output of liftNestedListsToParent):\n *\n * <li>item</li>\n * <ul>\n *   <li>...</li>\n *   <li>...</li>\n * </ul>\n *\n * Into:\n * <div>\n *  <li>item</li>\n *  <div data-node-type=\"blockGroup\">\n *      <ul>\n *          <li>...</li>\n *          <li>...</li>\n *      </ul>\n *  </div>\n * </div>\n *\n * This resulting format is parsed\n */\nfunction createGroups(element: HTMLElement) {\n  element.querySelectorAll(\"li + ul, li + ol\").forEach((list) => {\n    const listItem = list.previousElementSibling as HTMLElement;\n    const blockContainer = document.createElement(\"div\");\n\n    listItem.insertAdjacentElement(\"afterend\", blockContainer);\n    blockContainer.append(listItem);\n\n    const blockGroup = document.createElement(\"div\");\n    blockGroup.setAttribute(\"data-node-type\", \"blockGroup\");\n    blockContainer.append(blockGroup);\n\n    while (\n      blockContainer.nextElementSibling?.nodeName === \"UL\" ||\n      blockContainer.nextElementSibling?.nodeName === \"OL\"\n    ) {\n      blockGroup.append(blockContainer.nextElementSibling);\n    }\n  });\n}\n\n// prevent XSS, similar to https://github.com/ProseMirror/prosemirror-view/blob/1251b2b412656a2a06263e4187574beb43651273/src/clipboard.ts#L204\n// https://github.com/TypeCellOS/BlockNote/issues/601\nlet _detachedDoc: Document | null = null;\nfunction detachedDoc() {\n  return (\n    _detachedDoc ||\n    (_detachedDoc = document.implementation.createHTMLDocument(\"title\"))\n  );\n}\n\nexport function nestedListsToBlockNoteStructure(\n  elementOrHTML: HTMLElement | string\n) {\n  if (typeof elementOrHTML === \"string\") {\n    const element = detachedDoc().createElement(\"div\");\n    element.innerHTML = elementOrHTML;\n    elementOrHTML = element;\n  }\n  liftNestedListsToParent(elementOrHTML);\n  createGroups(elementOrHTML);\n  return elementOrHTML;\n}\n","import { DOMParser, Schema } from \"prosemirror-model\";\nimport { BlockSchema, InlineContentSchema, StyleSchema } from \"../../../schema\";\n\nimport { Block } from \"../../../blocks/defaultBlocks\";\nimport { nodeToBlock } from \"../../nodeConversions/nodeConversions\";\nimport { nestedListsToBlockNoteStructure } from \"./util/nestedLists\";\nexport async function HTMLToBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  html: string,\n  blockSchema: BSchema,\n  icSchema: I,\n  styleSchema: S,\n  pmSchema: Schema\n): Promise<Block<BSchema, I, S>[]> {\n  const htmlNode = nestedListsToBlockNoteStructure(html);\n  const parser = DOMParser.fromSchema(pmSchema);\n\n  // Other approach might be to use\n  // const doc = pmSchema.nodes[\"doc\"].createAndFill()!;\n  // and context: doc.resolve(3),\n\n  const parentNode = parser.parse(htmlNode, {\n    topNode: pmSchema.nodes[\"blockGroup\"].create(),\n  });\n\n  const blocks: Block<BSchema, I, S>[] = [];\n\n  for (let i = 0; i < parentNode.childCount; i++) {\n    blocks.push(\n      nodeToBlock(parentNode.child(i), blockSchema, icSchema, styleSchema)\n    );\n  }\n\n  return blocks;\n}\n","import { Schema } from \"prosemirror-model\";\nimport rehypeStringify from \"rehype-stringify\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkParse from \"remark-parse\";\nimport remarkRehype, { defaultHandlers } from \"remark-rehype\";\nimport { unified } from \"unified\";\nimport { Block } from \"../../../blocks/defaultBlocks\";\nimport { BlockSchema, InlineContentSchema, StyleSchema } from \"../../../schema\";\nimport { HTMLToBlocks } from \"../html/parseHTML\";\n\n// modified version of https://github.com/syntax-tree/mdast-util-to-hast/blob/main/lib/handlers/code.js\n// that outputs a data-language attribute instead of a CSS class (e.g.: language-typescript)\nfunction code(state: any, node: any) {\n  const value = node.value ? node.value + \"\\n\" : \"\";\n  /** @type {Properties} */\n  const properties: any = {};\n\n  if (node.lang) {\n    // changed line\n    properties[\"data-language\"] = node.lang;\n  }\n\n  // Create `<code>`.\n  /** @type {Element} */\n  let result: any = {\n    type: \"element\",\n    tagName: \"code\",\n    properties,\n    children: [{ type: \"text\", value }],\n  };\n\n  if (node.meta) {\n    result.data = { meta: node.meta };\n  }\n\n  state.patch(node, result);\n  result = state.applyData(node, result);\n\n  // Create `<pre>`.\n  result = {\n    type: \"element\",\n    tagName: \"pre\",\n    properties: {},\n    children: [result],\n  };\n  state.patch(node, result);\n  return result;\n}\n\nexport function markdownToBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  markdown: string,\n  blockSchema: BSchema,\n  icSchema: I,\n  styleSchema: S,\n  pmSchema: Schema\n): Promise<Block<BSchema, I, S>[]> {\n  const htmlString = unified()\n    .use(remarkParse)\n    .use(remarkGfm)\n    .use(remarkRehype, {\n      handlers: {\n        ...(defaultHandlers as any),\n        code,\n      },\n    })\n    .use(rehypeStringify)\n    .processSync(markdown);\n\n  return HTMLToBlocks(\n    htmlString.value as string,\n    blockSchema,\n    icSchema,\n    styleSchema,\n    pmSchema\n  );\n}\n","// from https://raw.githubusercontent.com/ueberdosis/tiptap/develop/packages/core/src/EventEmitter.ts (MIT)\n\ntype StringKeyOf<T> = Extract<keyof T, string>;\ntype CallbackType<\n  T extends Record<string, any>,\n  EventName extends StringKeyOf<T>\n> = T[EventName] extends any[] ? T[EventName] : [T[EventName]];\ntype CallbackFunction<\n  T extends Record<string, any>,\n  EventName extends StringKeyOf<T>\n> = (...props: CallbackType<T, EventName>) => any;\n\nexport class EventEmitter<T extends Record<string, any>> {\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  private callbacks: { [key: string]: Function[] } = {};\n\n  public on<EventName extends StringKeyOf<T>>(\n    event: EventName,\n    fn: CallbackFunction<T, EventName>\n  ) {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = [];\n    }\n\n    this.callbacks[event].push(fn);\n\n    return () => this.off(event, fn);\n  }\n\n  protected emit<EventName extends StringKeyOf<T>>(\n    event: EventName,\n    ...args: CallbackType<T, EventName>\n  ) {\n    const callbacks = this.callbacks[event];\n\n    if (callbacks) {\n      callbacks.forEach((callback) => callback.apply(this, args));\n    }\n  }\n\n  public off<EventName extends StringKeyOf<T>>(\n    event: EventName,\n    fn?: CallbackFunction<T, EventName>\n  ) {\n    const callbacks = this.callbacks[event];\n\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter((callback) => callback !== fn);\n      } else {\n        delete this.callbacks[event];\n      }\n    }\n  }\n\n  protected removeAllListeners(): void {\n    this.callbacks = {};\n  }\n}\n","import { isNodeSelection, posToDOMRect } from \"@tiptap/core\";\nimport { EditorState, Plugin, PluginKey } from \"prosemirror-state\";\nimport { EditorView } from \"prosemirror-view\";\n\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor\";\nimport { UiElementPosition } from \"../../extensions-shared/UiElementPosition\";\nimport { BlockSchema, InlineContentSchema, StyleSchema } from \"../../schema\";\nimport { EventEmitter } from \"../../util/EventEmitter\";\n\nexport type FormattingToolbarState = UiElementPosition;\n\nexport class FormattingToolbarView {\n  public state?: FormattingToolbarState;\n  public emitUpdate: () => void;\n\n  public preventHide = false;\n  public preventShow = false;\n  public prevWasEditable: boolean | null = null;\n\n  public shouldShow: (props: {\n    view: EditorView;\n    state: EditorState;\n    from: number;\n    to: number;\n  }) => boolean = ({ state }) => !state.selection.empty;\n\n  constructor(\n    private readonly editor: BlockNoteEditor<\n      BlockSchema,\n      InlineContentSchema,\n      StyleSchema\n    >,\n    private readonly pmView: EditorView,\n    emitUpdate: (state: FormattingToolbarState) => void\n  ) {\n    this.emitUpdate = () => {\n      if (!this.state) {\n        throw new Error(\n          \"Attempting to update uninitialized formatting toolbar\"\n        );\n      }\n\n      emitUpdate(this.state);\n    };\n\n    pmView.dom.addEventListener(\"mousedown\", this.viewMousedownHandler);\n    pmView.dom.addEventListener(\"mouseup\", this.viewMouseupHandler);\n    pmView.dom.addEventListener(\"dragstart\", this.dragHandler);\n    pmView.dom.addEventListener(\"dragover\", this.dragHandler);\n\n    pmView.dom.addEventListener(\"focus\", this.focusHandler);\n    pmView.dom.addEventListener(\"blur\", this.blurHandler);\n\n    document.addEventListener(\"scroll\", this.scrollHandler);\n  }\n\n  viewMousedownHandler = () => {\n    this.preventShow = true;\n  };\n\n  viewMouseupHandler = () => {\n    this.preventShow = false;\n    setTimeout(() => this.update(this.pmView));\n  };\n\n  // For dragging the whole editor.\n  dragHandler = () => {\n    if (this.state?.show) {\n      this.state.show = false;\n      this.emitUpdate();\n    }\n  };\n\n  focusHandler = () => {\n    // we use `setTimeout` to make sure `selection` is already updated\n    setTimeout(() => this.update(this.pmView));\n  };\n\n  blurHandler = (event: FocusEvent) => {\n    if (this.preventHide) {\n      this.preventHide = false;\n\n      return;\n    }\n\n    const editorWrapper = this.pmView.dom.parentElement!;\n\n    // Checks if the focus is moving to an element outside the editor. If it is,\n    // the toolbar is hidden.\n    if (\n      // An element is clicked.\n      event &&\n      event.relatedTarget &&\n      // Element is inside the editor.\n      (editorWrapper === (event.relatedTarget as Node) ||\n        editorWrapper.contains(event.relatedTarget as Node))\n    ) {\n      return;\n    }\n\n    if (this.state?.show) {\n      this.state.show = false;\n      this.emitUpdate();\n    }\n  };\n\n  scrollHandler = () => {\n    if (this.state?.show) {\n      this.state.referencePos = this.getSelectionBoundingBox();\n      this.emitUpdate();\n    }\n  };\n\n  update(view: EditorView, oldState?: EditorState) {\n    const { state, composing } = view;\n    const { doc, selection } = state;\n    const isSame =\n      oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection);\n\n    if (\n      (this.prevWasEditable === null ||\n        this.prevWasEditable === this.editor.isEditable) &&\n      (composing || isSame)\n    ) {\n      return;\n    }\n\n    this.prevWasEditable = this.editor.isEditable;\n\n    // support for CellSelections\n    const { ranges } = selection;\n    const from = Math.min(...ranges.map((range) => range.$from.pos));\n    const to = Math.max(...ranges.map((range) => range.$to.pos));\n\n    const shouldShow = this.shouldShow?.({\n      view,\n      state,\n      from,\n      to,\n    });\n\n    // Checks if menu should be shown/updated.\n    if (\n      this.editor.isEditable &&\n      !this.preventShow &&\n      (shouldShow || this.preventHide)\n    ) {\n      this.state = {\n        show: true,\n        referencePos: this.getSelectionBoundingBox(),\n      };\n\n      this.emitUpdate();\n\n      return;\n    }\n\n    // Checks if menu should be hidden.\n    if (\n      this.state?.show &&\n      !this.preventHide &&\n      (!shouldShow || this.preventShow || !this.editor.isEditable)\n    ) {\n      this.state.show = false;\n      this.emitUpdate();\n\n      return;\n    }\n  }\n\n  destroy() {\n    this.pmView.dom.removeEventListener(\"mousedown\", this.viewMousedownHandler);\n    this.pmView.dom.removeEventListener(\"mouseup\", this.viewMouseupHandler);\n    this.pmView.dom.removeEventListener(\"dragstart\", this.dragHandler);\n    this.pmView.dom.removeEventListener(\"dragover\", this.dragHandler);\n\n    this.pmView.dom.removeEventListener(\"focus\", this.focusHandler);\n    this.pmView.dom.removeEventListener(\"blur\", this.blurHandler);\n\n    document.removeEventListener(\"scroll\", this.scrollHandler);\n  }\n\n  getSelectionBoundingBox() {\n    const { state } = this.pmView;\n    const { selection } = state;\n\n    // support for CellSelections\n    const { ranges } = selection;\n    const from = Math.min(...ranges.map((range) => range.$from.pos));\n    const to = Math.max(...ranges.map((range) => range.$to.pos));\n\n    if (isNodeSelection(selection)) {\n      const node = this.pmView.nodeDOM(from) as HTMLElement;\n\n      if (node) {\n        return node.getBoundingClientRect();\n      }\n    }\n\n    return posToDOMRect(this.pmView, from, to);\n  }\n}\n\nexport const formattingToolbarPluginKey = new PluginKey(\n  \"FormattingToolbarPlugin\"\n);\n\nexport class FormattingToolbarProsemirrorPlugin extends EventEmitter<any> {\n  private view: FormattingToolbarView | undefined;\n  public readonly plugin: Plugin;\n\n  constructor(editor: BlockNoteEditor<any, any, any>) {\n    super();\n    this.plugin = new Plugin({\n      key: formattingToolbarPluginKey,\n      view: (editorView) => {\n        this.view = new FormattingToolbarView(editor, editorView, (state) => {\n          this.emit(\"update\", state);\n        });\n        return this.view;\n      },\n    });\n  }\n\n  public onUpdate(callback: (state: FormattingToolbarState) => void) {\n    return this.on(\"update\", callback);\n  }\n}\n","import { getMarkRange, posToDOMRect, Range } from \"@tiptap/core\";\nimport { EditorView } from \"@tiptap/pm/view\";\nimport { Mark } from \"prosemirror-model\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\n\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor\";\nimport { BlockSchema, InlineContentSchema, StyleSchema } from \"../../schema\";\nimport { UiElementPosition } from \"../../extensions-shared/UiElementPosition\";\nimport { EventEmitter } from \"../../util/EventEmitter\";\n\nexport type LinkToolbarState = UiElementPosition & {\n  // The hovered link's URL, and the text it's displayed with in the\n  // editor.\n  url: string;\n  text: string;\n};\n\nclass LinkToolbarView {\n  public state?: LinkToolbarState;\n  public emitUpdate: () => void;\n\n  menuUpdateTimer: ReturnType<typeof setTimeout> | undefined;\n  startMenuUpdateTimer: () => void;\n  stopMenuUpdateTimer: () => void;\n\n  mouseHoveredLinkMark: Mark | undefined;\n  mouseHoveredLinkMarkRange: Range | undefined;\n\n  keyboardHoveredLinkMark: Mark | undefined;\n  keyboardHoveredLinkMarkRange: Range | undefined;\n\n  linkMark: Mark | undefined;\n  linkMarkRange: Range | undefined;\n\n  constructor(\n    private readonly editor: BlockNoteEditor<any, any, any>,\n    private readonly pmView: EditorView,\n    emitUpdate: (state: LinkToolbarState) => void\n  ) {\n    this.emitUpdate = () => {\n      if (!this.state) {\n        throw new Error(\"Attempting to update uninitialized link toolbar\");\n      }\n\n      emitUpdate(this.state);\n    };\n\n    this.startMenuUpdateTimer = () => {\n      this.menuUpdateTimer = setTimeout(() => {\n        this.update();\n      }, 250);\n    };\n\n    this.stopMenuUpdateTimer = () => {\n      if (this.menuUpdateTimer) {\n        clearTimeout(this.menuUpdateTimer);\n        this.menuUpdateTimer = undefined;\n      }\n\n      return false;\n    };\n\n    this.pmView.dom.addEventListener(\"mouseover\", this.mouseOverHandler);\n    document.addEventListener(\"click\", this.clickHandler, true);\n    document.addEventListener(\"scroll\", this.scrollHandler);\n  }\n\n  mouseOverHandler = (event: MouseEvent) => {\n    // Resets the link mark currently hovered by the mouse cursor.\n    this.mouseHoveredLinkMark = undefined;\n    this.mouseHoveredLinkMarkRange = undefined;\n\n    this.stopMenuUpdateTimer();\n\n    if (\n      event.target instanceof HTMLAnchorElement &&\n      event.target.nodeName === \"A\"\n    ) {\n      // Finds link mark at the hovered element's position to update mouseHoveredLinkMark and\n      // mouseHoveredLinkMarkRange.\n      const hoveredLinkElement = event.target;\n      const posInHoveredLinkMark =\n        this.pmView.posAtDOM(hoveredLinkElement, 0) + 1;\n      const resolvedPosInHoveredLinkMark =\n        this.pmView.state.doc.resolve(posInHoveredLinkMark);\n      const marksAtPos = resolvedPosInHoveredLinkMark.marks();\n\n      for (const mark of marksAtPos) {\n        if (\n          mark.type.name === this.pmView.state.schema.mark(\"link\").type.name\n        ) {\n          this.mouseHoveredLinkMark = mark;\n          this.mouseHoveredLinkMarkRange =\n            getMarkRange(resolvedPosInHoveredLinkMark, mark.type, mark.attrs) ||\n            undefined;\n\n          break;\n        }\n      }\n    }\n\n    this.startMenuUpdateTimer();\n\n    return false;\n  };\n\n  clickHandler = (event: MouseEvent) => {\n    const editorWrapper = this.pmView.dom.parentElement!;\n\n    if (\n      // Toolbar is open.\n      this.linkMark &&\n      // An element is clicked.\n      event &&\n      event.target &&\n      // The clicked element is not the editor.\n      !(\n        editorWrapper === (event.target as Node) ||\n        editorWrapper.contains(event.target as Node)\n      )\n    ) {\n      if (this.state?.show) {\n        this.state.show = false;\n        this.emitUpdate();\n      }\n    }\n  };\n\n  scrollHandler = () => {\n    if (this.linkMark !== undefined) {\n      if (this.state?.show) {\n        this.state.referencePos = posToDOMRect(\n          this.pmView,\n          this.linkMarkRange!.from,\n          this.linkMarkRange!.to\n        );\n        this.emitUpdate();\n      }\n    }\n  };\n\n  editLink(url: string, text: string) {\n    const tr = this.pmView.state.tr.insertText(\n      text,\n      this.linkMarkRange!.from,\n      this.linkMarkRange!.to\n    );\n    tr.addMark(\n      this.linkMarkRange!.from,\n      this.linkMarkRange!.from + text.length,\n      this.pmView.state.schema.mark(\"link\", { href: url })\n    );\n    this.pmView.dispatch(tr);\n    this.pmView.focus();\n\n    if (this.state?.show) {\n      this.state.show = false;\n      this.emitUpdate();\n    }\n  }\n\n  deleteLink() {\n    this.pmView.dispatch(\n      this.pmView.state.tr\n        .removeMark(\n          this.linkMarkRange!.from,\n          this.linkMarkRange!.to,\n          this.linkMark!.type\n        )\n        .setMeta(\"preventAutolink\", true)\n    );\n    this.pmView.focus();\n\n    if (this.state?.show) {\n      this.state.show = false;\n      this.emitUpdate();\n    }\n  }\n\n  update() {\n    if (!this.pmView.hasFocus()) {\n      return;\n    }\n\n    // Saves the currently hovered link mark before it's updated.\n    const prevLinkMark = this.linkMark;\n\n    // Resets the currently hovered link mark.\n    this.linkMark = undefined;\n    this.linkMarkRange = undefined;\n\n    // Resets the link mark currently hovered by the keyboard cursor.\n    this.keyboardHoveredLinkMark = undefined;\n    this.keyboardHoveredLinkMarkRange = undefined;\n\n    // Finds link mark at the editor selection's position to update keyboardHoveredLinkMark and\n    // keyboardHoveredLinkMarkRange.\n    if (this.pmView.state.selection.empty) {\n      const marksAtPos = this.pmView.state.selection.$from.marks();\n\n      for (const mark of marksAtPos) {\n        if (\n          mark.type.name === this.pmView.state.schema.mark(\"link\").type.name\n        ) {\n          this.keyboardHoveredLinkMark = mark;\n          this.keyboardHoveredLinkMarkRange =\n            getMarkRange(\n              this.pmView.state.selection.$from,\n              mark.type,\n              mark.attrs\n            ) || undefined;\n\n          break;\n        }\n      }\n    }\n\n    if (this.mouseHoveredLinkMark) {\n      this.linkMark = this.mouseHoveredLinkMark;\n      this.linkMarkRange = this.mouseHoveredLinkMarkRange;\n    }\n\n    // Keyboard cursor position takes precedence over mouse hovered link.\n    if (this.keyboardHoveredLinkMark) {\n      this.linkMark = this.keyboardHoveredLinkMark;\n      this.linkMarkRange = this.keyboardHoveredLinkMarkRange;\n    }\n\n    if (this.linkMark && this.editor.isEditable) {\n      this.state = {\n        show: true,\n        referencePos: posToDOMRect(\n          this.pmView,\n          this.linkMarkRange!.from,\n          this.linkMarkRange!.to\n        ),\n        url: this.linkMark!.attrs.href,\n        text: this.pmView.state.doc.textBetween(\n          this.linkMarkRange!.from,\n          this.linkMarkRange!.to\n        ),\n      };\n      this.emitUpdate();\n\n      return;\n    }\n\n    // Hides menu.\n    if (\n      this.state?.show &&\n      prevLinkMark &&\n      (!this.linkMark || !this.editor.isEditable)\n    ) {\n      this.state.show = false;\n      this.emitUpdate();\n\n      return;\n    }\n  }\n\n  destroy() {\n    this.pmView.dom.removeEventListener(\"mouseover\", this.mouseOverHandler);\n    document.removeEventListener(\"scroll\", this.scrollHandler);\n    document.removeEventListener(\"click\", this.clickHandler, true);\n  }\n}\n\nexport const linkToolbarPluginKey = new PluginKey(\"LinkToolbarPlugin\");\n\nexport class LinkToolbarProsemirrorPlugin<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n> extends EventEmitter<any> {\n  private view: LinkToolbarView | undefined;\n  public readonly plugin: Plugin;\n\n  constructor(editor: BlockNoteEditor<BSchema, I, S>) {\n    super();\n    this.plugin = new Plugin({\n      key: linkToolbarPluginKey,\n      view: (editorView) => {\n        this.view = new LinkToolbarView(editor, editorView, (state) => {\n          this.emit(\"update\", state);\n        });\n        return this.view;\n      },\n    });\n  }\n\n  public onUpdate(callback: (state: LinkToolbarState) => void) {\n    return this.on(\"update\", callback);\n  }\n\n  /**\n   * Edit the currently hovered link.\n   */\n  public editLink = (url: string, text: string) => {\n    this.view!.editLink(url, text);\n  };\n\n  /**\n   * Delete the currently hovered link.\n   */\n  public deleteLink = () => {\n    this.view!.deleteLink();\n  };\n\n  /**\n   * When hovering on/off links using the mouse cursor, the link toolbar will\n   * open & close with a delay.\n   *\n   * This function starts the delay timer, and should be used for when the mouse\n   * cursor enters the link toolbar.\n   */\n  public startHideTimer = () => {\n    this.view!.startMenuUpdateTimer();\n  };\n\n  /**\n   * When hovering on/off links using the mouse cursor, the link toolbar will\n   * open & close with a delay.\n   *\n   * This function stops the delay timer, and should be used for when the mouse\n   * cursor exits the link toolbar.\n   */\n  public stopHideTimer = () => {\n    this.view!.stopMenuUpdateTimer();\n  };\n}\n","import { findParentNode } from \"@tiptap/core\";\nimport { EditorState, Plugin, PluginKey } from \"prosemirror-state\";\nimport { Decoration, DecorationSet, EditorView } from \"prosemirror-view\";\n\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor\";\nimport { BlockSchema, InlineContentSchema, StyleSchema } from \"../../schema\";\nimport { UiElementPosition } from \"../../extensions-shared/UiElementPosition\";\nimport { EventEmitter } from \"../../util/EventEmitter\";\n\nconst findBlock = findParentNode((node) => node.type.name === \"blockContainer\");\n\nexport type SuggestionMenuState = UiElementPosition & {\n  query: string;\n};\n\nclass SuggestionMenuView<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n> {\n  private state?: SuggestionMenuState;\n  public emitUpdate: (triggerCharacter: string) => void;\n\n  pluginState: SuggestionPluginState;\n\n  constructor(\n    private readonly editor: BlockNoteEditor<BSchema, I, S>,\n    emitUpdate: (menuName: string, state: SuggestionMenuState) => void\n  ) {\n    this.pluginState = undefined;\n\n    this.emitUpdate = (menuName: string) => {\n      if (!this.state) {\n        throw new Error(\"Attempting to update uninitialized suggestions menu\");\n      }\n\n      emitUpdate(menuName, this.state);\n    };\n\n    document.addEventListener(\"scroll\", this.handleScroll);\n  }\n\n  handleScroll = () => {\n    if (this.state?.show) {\n      const decorationNode = document.querySelector(\n        `[data-decoration-id=\"${this.pluginState!.decorationId}\"]`\n      );\n      this.state.referencePos = decorationNode!.getBoundingClientRect();\n      this.emitUpdate(this.pluginState!.triggerCharacter!);\n    }\n  };\n\n  update(view: EditorView, prevState: EditorState) {\n    const prev: SuggestionPluginState =\n      suggestionMenuPluginKey.getState(prevState);\n    const next: SuggestionPluginState = suggestionMenuPluginKey.getState(\n      view.state\n    );\n\n    // See how the state changed\n    const started = prev === undefined && next !== undefined;\n    const stopped = prev !== undefined && next === undefined;\n    const changed = prev !== undefined && next !== undefined;\n\n    // Cancel when suggestion isn't active\n    if (!started && !changed && !stopped) {\n      return;\n    }\n\n    this.pluginState = stopped ? prev : next;\n\n    if (stopped || !this.editor.isEditable) {\n      this.state!.show = false;\n      this.emitUpdate(this.pluginState!.triggerCharacter);\n\n      return;\n    }\n\n    const decorationNode = document.querySelector(\n      `[data-decoration-id=\"${this.pluginState!.decorationId}\"]`\n    );\n\n    if (this.editor.isEditable) {\n      this.state = {\n        show: true,\n        referencePos: decorationNode!.getBoundingClientRect(),\n        query: this.pluginState!.query,\n      };\n\n      this.emitUpdate(this.pluginState!.triggerCharacter!);\n    }\n  }\n\n  destroy() {\n    document.removeEventListener(\"scroll\", this.handleScroll);\n  }\n\n  closeMenu = () => {\n    this.editor._tiptapEditor.view.dispatch(\n      this.editor._tiptapEditor.view.state.tr.setMeta(\n        suggestionMenuPluginKey,\n        null\n      )\n    );\n  };\n\n  clearQuery = () => {\n    if (this.pluginState === undefined) {\n      return;\n    }\n\n    this.editor._tiptapEditor\n      .chain()\n      .focus()\n      .deleteRange({\n        from:\n          this.pluginState.queryStartPos! -\n          (this.pluginState.fromUserInput\n            ? this.pluginState.triggerCharacter!.length\n            : 0),\n        to: this.editor._tiptapEditor.state.selection.from,\n      })\n      .run();\n  };\n}\n\ntype SuggestionPluginState =\n  | {\n      triggerCharacter: string;\n      fromUserInput: boolean;\n      queryStartPos: number;\n      query: string;\n      decorationId: string;\n    }\n  | undefined;\n\nexport const suggestionMenuPluginKey = new PluginKey(\"SuggestionMenuPlugin\");\n\n/**\n * A ProseMirror plugin for suggestions, designed to make '/'-commands possible as well as mentions.\n *\n * This is basically a simplified version of TipTap's [Suggestions](https://github.com/ueberdosis/tiptap/tree/db92a9b313c5993b723c85cd30256f1d4a0b65e1/packages/suggestion) plugin.\n *\n * This version is adapted from the aforementioned version in the following ways:\n * - This version supports generic items instead of only strings (to allow for more advanced filtering for example)\n * - This version hides some unnecessary complexity from the user of the plugin.\n * - This version handles key events differently\n */\nexport class SuggestionMenuProseMirrorPlugin<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n> extends EventEmitter<any> {\n  private view: SuggestionMenuView<BSchema, I, S> | undefined;\n  public readonly plugin: Plugin;\n\n  private triggerCharacters: string[] = [];\n\n  constructor(editor: BlockNoteEditor<BSchema, I, S>) {\n    super();\n    const triggerCharacters = this.triggerCharacters;\n    this.plugin = new Plugin({\n      key: suggestionMenuPluginKey,\n\n      view: () => {\n        this.view = new SuggestionMenuView<BSchema, I, S>(\n          editor,\n          (triggerCharacter, state) => {\n            this.emit(`update ${triggerCharacter}`, state);\n          }\n        );\n        return this.view;\n      },\n\n      state: {\n        // Initialize the plugin's internal state.\n        init(): SuggestionPluginState {\n          return undefined;\n        },\n\n        // Apply changes to the plugin state from an editor transaction.\n        apply(transaction, prev, _oldState, newState): SuggestionPluginState {\n          // TODO: More clearly define which transactions should be ignored.\n          if (transaction.getMeta(\"orderedListIndexing\") !== undefined) {\n            return prev;\n          }\n\n          // Either contains the trigger character if the menu should be shown,\n          // or null if it should be hidden.\n          const suggestionPluginTransactionMeta: {\n            triggerCharacter: string;\n            fromUserInput?: boolean;\n          } | null = transaction.getMeta(suggestionMenuPluginKey);\n\n          // Only opens a menu of no menu is already open\n          if (\n            typeof suggestionPluginTransactionMeta === \"object\" &&\n            suggestionPluginTransactionMeta !== null &&\n            prev === undefined\n          ) {\n            return {\n              triggerCharacter:\n                suggestionPluginTransactionMeta.triggerCharacter,\n              fromUserInput:\n                suggestionPluginTransactionMeta.fromUserInput !== false,\n              queryStartPos: newState.selection.from,\n              query: \"\",\n              decorationId: `id_${Math.floor(Math.random() * 0xffffffff)}`,\n            };\n          }\n\n          // Checks if the menu is hidden, in which case it doesn't need to be hidden or updated.\n          if (prev === undefined) {\n            return prev;\n          }\n\n          // Checks if the menu should be hidden.\n          if (\n            // Highlighting text should hide the menu.\n            newState.selection.from !== newState.selection.to ||\n            // Transactions with plugin metadata should hide the menu.\n            suggestionPluginTransactionMeta === null ||\n            // Certain mouse events should hide the menu.\n            // TODO: Change to global mousedown listener.\n            transaction.getMeta(\"focus\") ||\n            transaction.getMeta(\"blur\") ||\n            transaction.getMeta(\"pointer\") ||\n            // Moving the caret before the character which triggered the menu should hide it.\n            (prev.triggerCharacter !== undefined &&\n              newState.selection.from < prev.queryStartPos!)\n          ) {\n            return undefined;\n          }\n\n          const next = { ...prev };\n\n          // Updates the current query.\n          next.query = newState.doc.textBetween(\n            prev.queryStartPos!,\n            newState.selection.from\n          );\n\n          return next;\n        },\n      },\n\n      props: {\n        handleTextInput(view, _from, _to, text) {\n          const suggestionPluginState: SuggestionPluginState = (\n            this as Plugin\n          ).getState(view.state);\n\n          if (\n            triggerCharacters.includes(text) &&\n            suggestionPluginState === undefined\n          ) {\n            view.dispatch(\n              view.state.tr\n                .insertText(text)\n                .scrollIntoView()\n                .setMeta(suggestionMenuPluginKey, {\n                  triggerCharacter: text,\n                })\n            );\n\n            return true;\n          }\n          return false;\n        },\n\n        // Setup decorator on the currently active suggestion.\n        decorations(state) {\n          const suggestionPluginState: SuggestionPluginState = (\n            this as Plugin\n          ).getState(state);\n\n          if (suggestionPluginState === undefined) {\n            return null;\n          }\n\n          // If the menu was opened programmatically by another extension, it may not use a trigger character. In this\n          // case, the decoration is set on the whole block instead, as the decoration range would otherwise be empty.\n          if (!suggestionPluginState.fromUserInput) {\n            const blockNode = findBlock(state.selection);\n            if (blockNode) {\n              return DecorationSet.create(state.doc, [\n                Decoration.node(\n                  blockNode.pos,\n                  blockNode.pos + blockNode.node.nodeSize,\n                  {\n                    nodeName: \"span\",\n                    class: \"bn-suggestion-decorator\",\n                    \"data-decoration-id\": suggestionPluginState.decorationId,\n                  }\n                ),\n              ]);\n            }\n          }\n          // Creates an inline decoration around the trigger character.\n          return DecorationSet.create(state.doc, [\n            Decoration.inline(\n              suggestionPluginState.queryStartPos! -\n                suggestionPluginState.triggerCharacter!.length,\n              suggestionPluginState.queryStartPos!,\n              {\n                nodeName: \"span\",\n                class: \"bn-suggestion-decorator\",\n                \"data-decoration-id\": suggestionPluginState.decorationId,\n              }\n            ),\n          ]);\n        },\n      },\n    });\n  }\n\n  public onUpdate(\n    triggerCharacter: string,\n    callback: (state: SuggestionMenuState) => void\n  ) {\n    if (!this.triggerCharacters.includes(triggerCharacter)) {\n      this.addTriggerCharacter(triggerCharacter);\n    }\n    // TODO: be able to remove the triggerCharacter\n    return this.on(`update ${triggerCharacter}`, callback);\n  }\n\n  addTriggerCharacter = (triggerCharacter: string) => {\n    this.triggerCharacters.push(triggerCharacter);\n  };\n\n  // TODO: Should this be called automatically when listeners are removed?\n  removeTriggerCharacter = (triggerCharacter: string) => {\n    this.triggerCharacters = this.triggerCharacters.filter(\n      (c) => c !== triggerCharacter\n    );\n  };\n\n  closeMenu = () => this.view!.closeMenu();\n\n  clearQuery = () => this.view!.clearQuery();\n}\n\nexport function createSuggestionMenu<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(editor: BlockNoteEditor<BSchema, I, S>, triggerCharacter: string) {\n  editor.suggestionMenus.addTriggerCharacter(triggerCharacter);\n}\n","import { Fragment, Node, ResolvedPos, Slice } from \"prosemirror-model\";\nimport { Selection } from \"prosemirror-state\";\nimport { Mappable } from \"prosemirror-transform\";\n\n/**\n * This class represents an editor selection which spans multiple nodes/blocks. It's currently only used to allow users\n * to drag multiple blocks at the same time. Expects the selection anchor and head to be between nodes, i.e. just before\n * the first target node and just after the last, and that anchor and head are at the same nesting level.\n *\n * Partially based on ProseMirror's NodeSelection implementation:\n * (https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.ts)\n * MultipleNodeSelection differs from NodeSelection in the following ways:\n * 1. Stores which nodes are included in the selection instead of just a single node.\n * 2. Already expects the selection to start just before the first target node and ends just after the last, while a\n * NodeSelection automatically sets both anchor and head to just before the single target node.\n */\nexport class MultipleNodeSelection extends Selection {\n  nodes: Array<Node>;\n\n  constructor($anchor: ResolvedPos, $head: ResolvedPos) {\n    super($anchor, $head);\n\n    // Parent is at the same nesting level as anchor/head since they are just before/ just after target nodes.\n    const parentNode = $anchor.node();\n\n    this.nodes = [];\n    $anchor.doc.nodesBetween($anchor.pos, $head.pos, (node, _pos, parent) => {\n      if (parent !== null && parent.eq(parentNode)) {\n        this.nodes.push(node);\n        return false;\n      }\n      return;\n    });\n  }\n\n  static create(doc: Node, from: number, to = from): MultipleNodeSelection {\n    return new MultipleNodeSelection(doc.resolve(from), doc.resolve(to));\n  }\n\n  content(): Slice {\n    return new Slice(Fragment.from(this.nodes), 0, 0);\n  }\n\n  eq(selection: Selection): boolean {\n    if (!(selection instanceof MultipleNodeSelection)) {\n      return false;\n    }\n\n    if (this.nodes.length !== selection.nodes.length) {\n      return false;\n    }\n\n    if (this.from !== selection.from || this.to !== selection.to) {\n      return false;\n    }\n\n    for (let i = 0; i < this.nodes.length; i++) {\n      if (!this.nodes[i].eq(selection.nodes[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  map(doc: Node, mapping: Mappable): Selection {\n    const fromResult = mapping.mapResult(this.from);\n    const toResult = mapping.mapResult(this.to);\n\n    if (toResult.deleted) {\n      return Selection.near(doc.resolve(fromResult.pos));\n    }\n\n    if (fromResult.deleted) {\n      return Selection.near(doc.resolve(toResult.pos));\n    }\n\n    return new MultipleNodeSelection(\n      doc.resolve(fromResult.pos),\n      doc.resolve(toResult.pos)\n    );\n  }\n\n  toJSON(): any {\n    return { type: \"node\", anchor: this.anchor, head: this.head };\n  }\n}\n","import { PluginView } from \"@tiptap/pm/state\";\nimport { Node } from \"prosemirror-model\";\nimport { NodeSelection, Plugin, PluginKey, Selection } from \"prosemirror-state\";\nimport { EditorView } from \"prosemirror-view\";\n\nimport { createExternalHTMLExporter } from \"../../api/exporters/html/externalHTMLExporter\";\nimport { createInternalHTMLSerializer } from \"../../api/exporters/html/internalHTMLSerializer\";\nimport { cleanHTMLToMarkdown } from \"../../api/exporters/markdown/markdownExporter\";\nimport { getBlockInfoFromPos } from \"../../api/getBlockInfoFromPos\";\nimport { Block } from \"../../blocks/defaultBlocks\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor\";\nimport { UiElementPosition } from \"../../extensions-shared/UiElementPosition\";\nimport { BlockSchema, InlineContentSchema, StyleSchema } from \"../../schema\";\nimport { EventEmitter } from \"../../util/EventEmitter\";\nimport { suggestionMenuPluginKey } from \"../SuggestionMenu/SuggestionPlugin\";\nimport { MultipleNodeSelection } from \"./MultipleNodeSelection\";\n\nlet dragImageElement: Element | undefined;\n\nexport type SideMenuState<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n> = UiElementPosition & {\n  // The block that the side menu is attached to.\n  block: Block<BSchema, I, S>;\n};\n\nexport function getDraggableBlockFromCoords(\n  coords: { left: number; top: number },\n  view: EditorView\n) {\n  if (!view.dom.isConnected) {\n    // view is not connected to the DOM, this can cause posAtCoords to fail\n    // (Cannot read properties of null (reading 'nearestDesc'), https://github.com/TypeCellOS/BlockNote/issues/123)\n    return undefined;\n  }\n\n  const pos = view.posAtCoords(coords);\n  if (!pos) {\n    return undefined;\n  }\n  let node = view.domAtPos(pos.pos).node as HTMLElement;\n\n  if (node === view.dom) {\n    // mouse over root\n    return undefined;\n  }\n\n  while (\n    node &&\n    node.parentNode &&\n    node.parentNode !== view.dom &&\n    !node.hasAttribute?.(\"data-id\")\n  ) {\n    node = node.parentNode as HTMLElement;\n  }\n  if (!node) {\n    return undefined;\n  }\n  return { node, id: node.getAttribute(\"data-id\")! };\n}\n\nfunction blockPositionFromCoords(\n  coords: { left: number; top: number },\n  view: EditorView\n) {\n  const block = getDraggableBlockFromCoords(coords, view);\n\n  if (block && block.node.nodeType === 1) {\n    // TODO: this uses undocumented PM APIs? do we need this / let's add docs?\n    const docView = (view as any).docView;\n    const desc = docView.nearestDesc(block.node, true);\n    if (!desc || desc === docView) {\n      return null;\n    }\n    return desc.posBefore;\n  }\n  return null;\n}\n\nfunction blockPositionsFromSelection(selection: Selection, doc: Node) {\n  // Absolute positions just before the first block spanned by the selection, and just after the last block. Having the\n  // selection start and end just before and just after the target blocks ensures no whitespace/line breaks are left\n  // behind after dragging & dropping them.\n  let beforeFirstBlockPos: number;\n  let afterLastBlockPos: number;\n\n  // Even the user starts dragging blocks but drops them in the same place, the selection will still be moved just\n  // before & just after the blocks spanned by the selection, and therefore doesn't need to change if they try to drag\n  // the same blocks again. If this happens, the anchor & head move out of the block content node they were originally\n  // in. If the anchor should update but the head shouldn't and vice versa, it means the user selection is outside a\n  // block content node, which should never happen.\n  const selectionStartInBlockContent =\n    doc.resolve(selection.from).node().type.spec.group === \"blockContent\";\n  const selectionEndInBlockContent =\n    doc.resolve(selection.to).node().type.spec.group === \"blockContent\";\n\n  // Ensures that entire outermost nodes are selected if the selection spans multiple nesting levels.\n  const minDepth = Math.min(selection.$anchor.depth, selection.$head.depth);\n\n  if (selectionStartInBlockContent && selectionEndInBlockContent) {\n    // Absolute positions at the start of the first block in the selection and at the end of the last block. User\n    // selections will always start and end in block content nodes, but we want the start and end positions of their\n    // parent block nodes, which is why minDepth - 1 is used.\n    const startFirstBlockPos = selection.$from.start(minDepth - 1);\n    const endLastBlockPos = selection.$to.end(minDepth - 1);\n\n    // Shifting start and end positions by one moves them just outside the first and last selected blocks.\n    beforeFirstBlockPos = doc.resolve(startFirstBlockPos - 1).pos;\n    afterLastBlockPos = doc.resolve(endLastBlockPos + 1).pos;\n  } else {\n    beforeFirstBlockPos = selection.from;\n    afterLastBlockPos = selection.to;\n  }\n\n  return { from: beforeFirstBlockPos, to: afterLastBlockPos };\n}\n\nfunction setDragImage(view: EditorView, from: number, to = from) {\n  if (from === to) {\n    // Moves to position to be just after the first (and only) selected block.\n    to += view.state.doc.resolve(from + 1).node().nodeSize;\n  }\n\n  // Parent element is cloned to remove all unselected children without affecting the editor content.\n  const parentClone = view.domAtPos(from).node.cloneNode(true) as Element;\n  const parent = view.domAtPos(from).node as Element;\n\n  const getElementIndex = (parentElement: Element, targetElement: Element) =>\n    Array.prototype.indexOf.call(parentElement.children, targetElement);\n\n  const firstSelectedBlockIndex = getElementIndex(\n    parent,\n    // Expects from position to be just before the first selected block.\n    view.domAtPos(from + 1).node.parentElement!\n  );\n  const lastSelectedBlockIndex = getElementIndex(\n    parent,\n    // Expects to position to be just after the last selected block.\n    view.domAtPos(to - 1).node.parentElement!\n  );\n\n  for (let i = parent.childElementCount - 1; i >= 0; i--) {\n    if (i > lastSelectedBlockIndex || i < firstSelectedBlockIndex) {\n      parentClone.removeChild(parentClone.children[i]);\n    }\n  }\n\n  // dataTransfer.setDragImage(element) only works if element is attached to the DOM.\n  unsetDragImage();\n  dragImageElement = parentClone;\n\n  // TODO: This is hacky, need a better way of assigning classes to the editor so that they can also be applied to the\n  //  drag preview.\n  const classes = view.dom.className.split(\" \");\n  const inheritedClasses = classes\n    .filter(\n      (className) =>\n        className !== \"ProseMirror\" &&\n        className !== \"bn-root\" &&\n        className !== \"bn-editor\"\n    )\n    .join(\" \");\n\n  dragImageElement.className =\n    dragImageElement.className + \" bn-drag-preview \" + inheritedClasses;\n\n  document.body.appendChild(dragImageElement);\n}\n\nfunction unsetDragImage() {\n  if (dragImageElement !== undefined) {\n    document.body.removeChild(dragImageElement);\n    dragImageElement = undefined;\n  }\n}\n\nfunction dragStart<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  e: { dataTransfer: DataTransfer | null; clientY: number },\n  editor: BlockNoteEditor<BSchema, I, S>\n) {\n  if (!e.dataTransfer) {\n    return;\n  }\n\n  const view = editor.prosemirrorView;\n\n  const editorBoundingBox = view.dom.getBoundingClientRect();\n\n  const coords = {\n    left: editorBoundingBox.left + editorBoundingBox.width / 2, // take middle of editor\n    top: e.clientY,\n  };\n\n  const pos = blockPositionFromCoords(coords, view);\n  if (pos != null) {\n    const selection = view.state.selection;\n    const doc = view.state.doc;\n\n    const { from, to } = blockPositionsFromSelection(selection, doc);\n\n    const draggedBlockInSelection = from <= pos && pos < to;\n    const multipleBlocksSelected =\n      selection.$anchor.node() !== selection.$head.node() ||\n      selection instanceof MultipleNodeSelection;\n\n    if (draggedBlockInSelection && multipleBlocksSelected) {\n      view.dispatch(\n        view.state.tr.setSelection(MultipleNodeSelection.create(doc, from, to))\n      );\n      setDragImage(view, from, to);\n    } else {\n      view.dispatch(\n        view.state.tr.setSelection(NodeSelection.create(view.state.doc, pos))\n      );\n      setDragImage(view, pos);\n    }\n\n    const selectedSlice = view.state.selection.content();\n    const schema = editor._tiptapEditor.schema;\n\n    const internalHTMLSerializer = createInternalHTMLSerializer(schema, editor);\n    const internalHTML = internalHTMLSerializer.serializeProseMirrorFragment(\n      selectedSlice.content\n    );\n\n    const externalHTMLExporter = createExternalHTMLExporter(schema, editor);\n    const externalHTML = externalHTMLExporter.exportProseMirrorFragment(\n      selectedSlice.content\n    );\n\n    const plainText = cleanHTMLToMarkdown(externalHTML);\n\n    e.dataTransfer.clearData();\n    e.dataTransfer.setData(\"blocknote/html\", internalHTML);\n    e.dataTransfer.setData(\"text/html\", externalHTML);\n    e.dataTransfer.setData(\"text/plain\", plainText);\n    e.dataTransfer.effectAllowed = \"move\";\n    e.dataTransfer.setDragImage(dragImageElement!, 0, 0);\n    view.dragging = { slice: selectedSlice, move: true };\n  }\n}\n\nexport class SideMenuView<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n> implements PluginView\n{\n  private state?: SideMenuState<BSchema, I, S>;\n  private readonly emitUpdate: (state: SideMenuState<BSchema, I, S>) => void;\n\n  // When true, the drag handle with be anchored at the same level as root elements\n  // When false, the drag handle with be just to the left of the element\n  // TODO: Is there any case where we want this to be false?\n  private horizontalPosAnchoredAtRoot: boolean;\n  private horizontalPosAnchor: number;\n\n  private hoveredBlock: HTMLElement | undefined;\n\n  // Used to check if currently dragged content comes from this editor instance.\n  public isDragging = false;\n\n  public menuFrozen = false;\n\n  constructor(\n    private readonly editor: BlockNoteEditor<BSchema, I, S>,\n    private readonly pmView: EditorView,\n    emitUpdate: (state: SideMenuState<BSchema, I, S>) => void\n  ) {\n    this.emitUpdate = () => {\n      if (!this.state) {\n        throw new Error(\"Attempting to update uninitialized side menu\");\n      }\n\n      emitUpdate(this.state);\n    };\n\n    this.horizontalPosAnchoredAtRoot = true;\n    this.horizontalPosAnchor = (\n      this.pmView.dom.firstChild! as HTMLElement\n    ).getBoundingClientRect().x;\n\n    document.body.addEventListener(\"drop\", this.onDrop, true);\n    document.body.addEventListener(\"dragover\", this.onDragOver);\n    this.pmView.dom.addEventListener(\"dragstart\", this.onDragStart);\n\n    // Shows or updates menu position whenever the cursor moves, if the menu isn't frozen.\n    document.body.addEventListener(\"mousemove\", this.onMouseMove, true);\n\n    // Makes menu scroll with the page.\n    document.addEventListener(\"scroll\", this.onScroll);\n\n    // Unfreezes the menu whenever the user clicks anywhere.\n    document.body.addEventListener(\"mousedown\", this.onMouseDown, true);\n    // Hides and unfreezes the menu whenever the user presses a key.\n    document.body.addEventListener(\"keydown\", this.onKeyDown, true);\n  }\n\n  /**\n   * Sets isDragging when dragging text.\n   */\n  onDragStart = () => {\n    this.isDragging = true;\n  };\n\n  /**\n   * If the event is outside the editor contents,\n   * we dispatch a fake event, so that we can still drop the content\n   * when dragging / dropping to the side of the editor\n   */\n  onDrop = (event: DragEvent) => {\n    this.editor._tiptapEditor.commands.blur();\n\n    if ((event as any).synthetic || !this.isDragging) {\n      return;\n    }\n\n    const pos = this.pmView.posAtCoords({\n      left: event.clientX,\n      top: event.clientY,\n    });\n\n    this.isDragging = false;\n\n    if (!pos || pos.inside === -1) {\n      const evt = new Event(\"drop\", event) as any;\n      const editorBoundingBox = (\n        this.pmView.dom.firstChild! as HTMLElement\n      ).getBoundingClientRect();\n      evt.clientX = editorBoundingBox.left + editorBoundingBox.width / 2;\n      evt.clientY = event.clientY;\n      evt.dataTransfer = event.dataTransfer;\n      evt.preventDefault = () => event.preventDefault();\n      evt.synthetic = true; // prevent recursion\n      // console.log(\"dispatch fake drop\");\n      this.pmView.dom.dispatchEvent(evt);\n    }\n  };\n\n  /**\n   * If the event is outside the editor contents,\n   * we dispatch a fake event, so that we can still drop the content\n   * when dragging / dropping to the side of the editor\n   */\n  onDragOver = (event: DragEvent) => {\n    if ((event as any).synthetic || !this.isDragging) {\n      return;\n    }\n    const pos = this.pmView.posAtCoords({\n      left: event.clientX,\n      top: event.clientY,\n    });\n\n    if (!pos || pos.inside === -1) {\n      const evt = new Event(\"dragover\", event) as any;\n      const editorBoundingBox = (\n        this.pmView.dom.firstChild! as HTMLElement\n      ).getBoundingClientRect();\n      evt.clientX = editorBoundingBox.left + editorBoundingBox.width / 2;\n      evt.clientY = event.clientY;\n      evt.dataTransfer = event.dataTransfer;\n      evt.preventDefault = () => event.preventDefault();\n      evt.synthetic = true; // prevent recursion\n      // console.log(\"dispatch fake dragover\");\n      this.pmView.dom.dispatchEvent(evt);\n    }\n  };\n\n  onKeyDown = (_event: KeyboardEvent) => {\n    if (this.state?.show) {\n      this.state.show = false;\n      this.emitUpdate(this.state);\n    }\n    this.menuFrozen = false;\n  };\n\n  onMouseDown = (_event: MouseEvent) => {\n    if (this.state && !this.state.show) {\n      this.state.show = true;\n      this.emitUpdate(this.state);\n    }\n    this.menuFrozen = false;\n  };\n\n  onMouseMove = (event: MouseEvent) => {\n    if (this.menuFrozen) {\n      return;\n    }\n\n    // Editor itself may have padding or other styling which affects\n    // size/position, so we get the boundingRect of the first child (i.e. the\n    // blockGroup that wraps all blocks in the editor) for more accurate side\n    // menu placement.\n    const editorBoundingBox = (\n      this.pmView.dom.firstChild! as HTMLElement\n    ).getBoundingClientRect();\n    // We want the full area of the editor to check if the cursor is hovering\n    // above it though.\n    const editorOuterBoundingBox = this.pmView.dom.getBoundingClientRect();\n    const cursorWithinEditor =\n      event.clientX >= editorOuterBoundingBox.left &&\n      event.clientX <= editorOuterBoundingBox.right &&\n      event.clientY >= editorOuterBoundingBox.top &&\n      event.clientY <= editorOuterBoundingBox.bottom;\n\n    const editorWrapper = this.pmView.dom.parentElement!;\n\n    // Doesn't update if the mouse hovers an element that's over the editor but\n    // isn't a part of it or the side menu.\n    if (\n      // Cursor is within the editor area\n      cursorWithinEditor &&\n      // An element is hovered\n      event &&\n      event.target &&\n      // Element is outside the editor\n      !(\n        editorWrapper === event.target ||\n        editorWrapper.contains(event.target as HTMLElement)\n      )\n    ) {\n      if (this.state?.show) {\n        this.state.show = false;\n        this.emitUpdate(this.state);\n      }\n\n      return;\n    }\n\n    this.horizontalPosAnchor = editorBoundingBox.x;\n\n    // Gets block at mouse cursor's vertical position.\n    const coords = {\n      left: editorBoundingBox.left + editorBoundingBox.width / 2, // take middle of editor\n      top: event.clientY,\n    };\n    const block = getDraggableBlockFromCoords(coords, this.pmView);\n\n    // Closes the menu if the mouse cursor is beyond the editor vertically.\n    if (!block || !this.editor.isEditable) {\n      if (this.state?.show) {\n        this.state.show = false;\n        this.emitUpdate(this.state);\n      }\n\n      return;\n    }\n\n    // Doesn't update if the menu is already open and the mouse cursor is still hovering the same block.\n    if (\n      this.state?.show &&\n      this.hoveredBlock?.hasAttribute(\"data-id\") &&\n      this.hoveredBlock?.getAttribute(\"data-id\") === block.id\n    ) {\n      return;\n    }\n\n    this.hoveredBlock = block.node;\n\n    // Gets the block's content node, which lets to ignore child blocks when determining the block menu's position.\n    const blockContent = block.node.firstChild as HTMLElement;\n\n    if (!blockContent) {\n      return;\n    }\n\n    // Shows or updates elements.\n    if (this.editor.isEditable) {\n      const blockContentBoundingBox = blockContent.getBoundingClientRect();\n\n      this.state = {\n        show: true,\n        referencePos: new DOMRect(\n          this.horizontalPosAnchoredAtRoot\n            ? this.horizontalPosAnchor\n            : blockContentBoundingBox.x,\n          blockContentBoundingBox.y,\n          blockContentBoundingBox.width,\n          blockContentBoundingBox.height\n        ),\n        block: this.editor.getBlock(\n          this.hoveredBlock!.getAttribute(\"data-id\")!\n        )!,\n      };\n\n      this.emitUpdate(this.state);\n    }\n  };\n\n  onScroll = () => {\n    if (this.state?.show) {\n      const blockContent = this.hoveredBlock!.firstChild as HTMLElement;\n      const blockContentBoundingBox = blockContent.getBoundingClientRect();\n\n      this.state.referencePos = new DOMRect(\n        this.horizontalPosAnchoredAtRoot\n          ? this.horizontalPosAnchor\n          : blockContentBoundingBox.x,\n        blockContentBoundingBox.y,\n        blockContentBoundingBox.width,\n        blockContentBoundingBox.height\n      );\n      this.emitUpdate(this.state);\n    }\n  };\n\n  destroy() {\n    if (this.state?.show) {\n      this.state.show = false;\n      this.emitUpdate(this.state);\n    }\n    document.body.removeEventListener(\"mousemove\", this.onMouseMove, true);\n    document.body.removeEventListener(\"dragover\", this.onDragOver);\n    this.pmView.dom.removeEventListener(\"dragstart\", this.onDragStart);\n    document.body.removeEventListener(\"drop\", this.onDrop, true);\n    document.removeEventListener(\"scroll\", this.onScroll);\n    document.body.removeEventListener(\"mousedown\", this.onMouseDown, true);\n    document.body.removeEventListener(\"keydown\", this.onKeyDown, true);\n  }\n\n  addBlock() {\n    if (this.state?.show) {\n      this.state.show = false;\n      this.emitUpdate(this.state);\n    }\n\n    this.menuFrozen = true;\n\n    const blockContent = this.hoveredBlock!.firstChild! as HTMLElement;\n    const blockContentBoundingBox = blockContent.getBoundingClientRect();\n\n    const pos = this.pmView.posAtCoords({\n      left: blockContentBoundingBox.left + blockContentBoundingBox.width / 2,\n      top: blockContentBoundingBox.top + blockContentBoundingBox.height / 2,\n    });\n    if (!pos) {\n      return;\n    }\n\n    const blockInfo = getBlockInfoFromPos(\n      this.editor._tiptapEditor.state.doc,\n      pos.pos\n    );\n    if (blockInfo === undefined) {\n      return;\n    }\n\n    const { contentNode, startPos, endPos } = blockInfo;\n\n    // Creates a new block if current one is not empty for the suggestion menu to open in.\n    if (\n      contentNode.type.spec.content !== \"inline*\" ||\n      contentNode.textContent.length !== 0\n    ) {\n      const newBlockInsertionPos = endPos + 1;\n      const newBlockContentPos = newBlockInsertionPos + 2;\n\n      this.editor._tiptapEditor\n        .chain()\n        .BNCreateBlock(newBlockInsertionPos)\n        // .BNUpdateBlock(newBlockContentPos, { type: \"paragraph\", props: {} })\n        .setTextSelection(newBlockContentPos)\n        .run();\n    } else {\n      this.editor._tiptapEditor.commands.setTextSelection(startPos + 1);\n    }\n\n    // Focuses and activates the suggestion menu.\n    this.pmView.focus();\n    this.pmView.dispatch(\n      this.pmView.state.tr.scrollIntoView().setMeta(suggestionMenuPluginKey, {\n        triggerCharacter: \"/\",\n        fromUserInput: false,\n      })\n    );\n  }\n}\n\nexport const sideMenuPluginKey = new PluginKey(\"SideMenuPlugin\");\n\nexport class SideMenuProsemirrorPlugin<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n> extends EventEmitter<any> {\n  public view: SideMenuView<BSchema, I, S> | undefined;\n  public readonly plugin: Plugin;\n\n  constructor(private readonly editor: BlockNoteEditor<BSchema, I, S>) {\n    super();\n    this.plugin = new Plugin({\n      key: sideMenuPluginKey,\n      view: (editorView) => {\n        this.view = new SideMenuView(editor, editorView, (state) => {\n          this.emit(\"update\", state);\n        });\n        return this.view;\n      },\n    });\n  }\n\n  public onUpdate(callback: (state: SideMenuState<BSchema, I, S>) => void) {\n    return this.on(\"update\", callback);\n  }\n\n  /**\n   * If the block is empty, opens the slash menu. If the block has content,\n   * creates a new block below and opens the slash menu in it.\n   */\n  addBlock = () => this.view!.addBlock();\n\n  /**\n   * Handles drag & drop events for blocks.\n   */\n  blockDragStart = (event: {\n    dataTransfer: DataTransfer | null;\n    clientY: number;\n  }) => {\n    this.view!.isDragging = true;\n    dragStart(event, this.editor);\n  };\n\n  /**\n   * Handles drag & drop events for blocks.\n   */\n  blockDragEnd = () => unsetDragImage();\n  /**\n   * Freezes the side menu. When frozen, the side menu will stay\n   * attached to the same block regardless of which block is hovered by the\n   * mouse cursor.\n   */\n  freezeMenu = () => (this.view!.menuFrozen = true);\n  /**\n   * Unfreezes the side menu. When frozen, the side menu will stay\n   * attached to the same block regardless of which block is hovered by the\n   * mouse cursor.\n   */\n  unfreezeMenu = () => (this.view!.menuFrozen = false);\n}\n","import { EditorState, Plugin, PluginKey } from \"prosemirror-state\";\nimport { EditorView } from \"prosemirror-view\";\n\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor\";\nimport type {\n  BlockFromConfig,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema\";\nimport { UiElementPosition } from \"../../extensions-shared/UiElementPosition\";\nimport { EventEmitter } from \"../../util/EventEmitter\";\nimport { DefaultBlockSchema } from \"../../blocks/defaultBlocks\";\n\nexport type ImagePanelState<\n  I extends InlineContentSchema,\n  S extends StyleSchema\n> = UiElementPosition & {\n  // TODO: This typing is not quite right (children should be from BSchema)\n  block: BlockFromConfig<DefaultBlockSchema[\"image\"], I, S>;\n};\n\nexport class ImagePanelView<\n  I extends InlineContentSchema,\n  S extends StyleSchema\n> {\n  public state?: ImagePanelState<I, S>;\n  public emitUpdate: () => void;\n\n  public prevWasEditable: boolean | null = null;\n\n  constructor(\n    private readonly pluginKey: PluginKey,\n    private readonly pmView: EditorView,\n    emitUpdate: (state: ImagePanelState<I, S>) => void\n  ) {\n    this.emitUpdate = () => {\n      if (!this.state) {\n        throw new Error(\"Attempting to update uninitialized image panel\");\n      }\n\n      emitUpdate(this.state);\n    };\n\n    pmView.dom.addEventListener(\"mousedown\", this.mouseDownHandler);\n\n    pmView.dom.addEventListener(\"dragstart\", this.dragstartHandler);\n\n    pmView.dom.addEventListener(\"blur\", this.blurHandler);\n\n    document.addEventListener(\"scroll\", this.scrollHandler);\n  }\n\n  mouseDownHandler = () => {\n    if (this.state?.show) {\n      this.state.show = false;\n      this.emitUpdate();\n    }\n  };\n\n  // For dragging the whole editor.\n  dragstartHandler = () => {\n    if (this.state?.show) {\n      this.state.show = false;\n      this.emitUpdate();\n    }\n  };\n\n  blurHandler = (event: FocusEvent) => {\n    const editorWrapper = this.pmView.dom.parentElement!;\n\n    // Checks if the focus is moving to an element outside the editor. If it is,\n    // the panel is hidden.\n    if (\n      // An element is clicked.\n      event &&\n      event.relatedTarget &&\n      // Element is inside the editor.\n      (editorWrapper === (event.relatedTarget as Node) ||\n        editorWrapper.contains(event.relatedTarget as Node))\n    ) {\n      return;\n    }\n\n    if (this.state?.show) {\n      this.state.show = false;\n      this.emitUpdate();\n    }\n  };\n\n  scrollHandler = () => {\n    if (this.state?.show) {\n      const blockElement = document.querySelector(\n        `[data-node-type=\"blockContainer\"][data-id=\"${this.state.block.id}\"]`\n      )!;\n\n      this.state.referencePos = blockElement.getBoundingClientRect();\n      this.emitUpdate();\n    }\n  };\n\n  update(view: EditorView, prevState: EditorState) {\n    const pluginState: {\n      block: BlockFromConfig<DefaultBlockSchema[\"image\"], I, S>;\n    } = this.pluginKey.getState(view.state);\n\n    if (!this.state?.show && pluginState.block) {\n      const blockElement = document.querySelector(\n        `[data-node-type=\"blockContainer\"][data-id=\"${pluginState.block.id}\"]`\n      )!;\n\n      this.state = {\n        show: true,\n        referencePos: blockElement.getBoundingClientRect(),\n        block: pluginState.block,\n      };\n\n      this.emitUpdate();\n\n      return;\n    }\n\n    if (\n      !view.state.selection.eq(prevState.selection) ||\n      !view.state.doc.eq(prevState.doc)\n    ) {\n      if (this.state?.show) {\n        this.state.show = false;\n\n        this.emitUpdate();\n      }\n    }\n  }\n\n  destroy() {\n    this.pmView.dom.removeEventListener(\"mousedown\", this.mouseDownHandler);\n\n    this.pmView.dom.removeEventListener(\"dragstart\", this.dragstartHandler);\n\n    this.pmView.dom.removeEventListener(\"blur\", this.blurHandler);\n\n    document.removeEventListener(\"scroll\", this.scrollHandler);\n  }\n}\n\nconst imagePanelPluginKey = new PluginKey(\"ImagePanelPlugin\");\n\nexport class ImagePanelProsemirrorPlugin<\n  I extends InlineContentSchema,\n  S extends StyleSchema\n> extends EventEmitter<any> {\n  private view: ImagePanelView<I, S> | undefined;\n  public readonly plugin: Plugin;\n\n  constructor(\n    _editor: BlockNoteEditor<{ image: DefaultBlockSchema[\"image\"] }, I, S>\n  ) {\n    super();\n    this.plugin = new Plugin<{\n      block: BlockFromConfig<DefaultBlockSchema[\"image\"], I, S> | undefined;\n    }>({\n      key: imagePanelPluginKey,\n      view: (editorView) => {\n        this.view = new ImagePanelView(\n          // editor,\n          imagePanelPluginKey,\n          editorView,\n          (state) => {\n            this.emit(\"update\", state);\n          }\n        );\n        return this.view;\n      },\n      state: {\n        init: () => {\n          return {\n            block: undefined,\n          };\n        },\n        apply: (transaction) => {\n          const block:\n            | BlockFromConfig<DefaultBlockSchema[\"image\"], I, S>\n            | undefined = transaction.getMeta(imagePanelPluginKey)?.block;\n\n          return {\n            block,\n          };\n        },\n      },\n    });\n  }\n\n  public onUpdate(callback: (state: ImagePanelState<I, S>) => void) {\n    return this.on(\"update\", callback);\n  }\n}\n","import { Plugin, PluginKey, PluginView } from \"prosemirror-state\";\nimport { Decoration, DecorationSet, EditorView } from \"prosemirror-view\";\nimport { nodeToBlock } from \"../../api/nodeConversions/nodeConversions\";\nimport { Block, DefaultBlockSchema } from \"../../blocks/defaultBlocks\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor\";\nimport {\n  BlockFromConfigNoChildren,\n  BlockSchemaWithBlock,\n  InlineContentSchema,\n  SpecificBlock,\n  StyleSchema,\n} from \"../../schema\";\nimport { EventEmitter } from \"../../util/EventEmitter\";\nimport { getDraggableBlockFromCoords } from \"../SideMenu/SideMenuPlugin\";\n\nlet dragImageElement: HTMLElement | undefined;\n\nexport type TableHandlesState<\n  I extends InlineContentSchema,\n  S extends StyleSchema\n> = {\n  show: boolean;\n  referencePosCell: DOMRect;\n  referencePosTable: DOMRect;\n\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], I, S>;\n  colIndex: number;\n  rowIndex: number;\n\n  draggingState:\n    | {\n        draggedCellOrientation: \"row\" | \"col\";\n        originalIndex: number;\n        mousePos: number;\n      }\n    | undefined;\n};\n\nfunction setHiddenDragImage() {\n  if (dragImageElement) {\n    return;\n  }\n\n  dragImageElement = document.createElement(\"div\");\n  dragImageElement.innerHTML = \"_\";\n  dragImageElement.style.opacity = \"0\";\n  dragImageElement.style.height = \"1px\";\n  dragImageElement.style.width = \"1px\";\n  document.body.appendChild(dragImageElement);\n}\n\nfunction unsetHiddenDragImage() {\n  if (dragImageElement) {\n    document.body.removeChild(dragImageElement);\n    dragImageElement = undefined;\n  }\n}\n\nfunction getChildIndex(node: Element) {\n  return Array.prototype.indexOf.call(node.parentElement!.childNodes, node);\n}\n\n// Finds the DOM element corresponding to the table cell that the target element\n// is currently in. If the target element is not in a table cell, returns null.\nfunction domCellAround(target: Element | null): Element | null {\n  while (target && target.nodeName !== \"TD\" && target.nodeName !== \"TH\") {\n    target =\n      target.classList && target.classList.contains(\"ProseMirror\")\n        ? null\n        : (target.parentNode as Element);\n  }\n  return target;\n}\n\n// Hides elements in the DOMwith the provided class names.\nfunction hideElementsWithClassNames(classNames: string[]) {\n  classNames.forEach((className) => {\n    const elementsToHide = document.getElementsByClassName(className);\n    for (let i = 0; i < elementsToHide.length; i++) {\n      (elementsToHide[i] as HTMLElement).style.visibility = \"hidden\";\n    }\n  });\n}\n\nexport class TableHandlesView<\n  BSchema extends BlockSchemaWithBlock<\"table\", DefaultBlockSchema[\"table\"]>,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n> implements PluginView\n{\n  public state?: TableHandlesState<I, S>;\n  public emitUpdate: () => void;\n\n  public tableId: string | undefined;\n  public tablePos: number | undefined;\n\n  public menuFrozen = false;\n\n  public prevWasEditable: boolean | null = null;\n\n  constructor(\n    private readonly editor: BlockNoteEditor<\n      BlockSchemaWithBlock<\"table\", DefaultBlockSchema[\"table\"]>,\n      I,\n      S\n    >,\n    private readonly pmView: EditorView,\n    emitUpdate: (state: TableHandlesState<I, S>) => void\n  ) {\n    this.emitUpdate = () => {\n      if (!this.state) {\n        throw new Error(\"Attempting to update uninitialized image toolbar\");\n      }\n\n      emitUpdate(this.state);\n    };\n\n    pmView.dom.addEventListener(\"mousemove\", this.mouseMoveHandler);\n\n    document.addEventListener(\"dragover\", this.dragOverHandler);\n    document.addEventListener(\"drop\", this.dropHandler);\n\n    document.addEventListener(\"scroll\", this.scrollHandler);\n  }\n\n  mouseMoveHandler = (event: MouseEvent) => {\n    if (this.menuFrozen) {\n      return;\n    }\n\n    const target = domCellAround(event.target as HTMLElement);\n\n    if (!target || !this.editor.isEditable) {\n      if (this.state?.show) {\n        this.state.show = false;\n        this.emitUpdate();\n      }\n      return;\n    }\n\n    const colIndex = getChildIndex(target);\n    const rowIndex = getChildIndex(target.parentElement!);\n    const cellRect = target.getBoundingClientRect();\n    const tableRect =\n      target.parentElement!.parentElement!.getBoundingClientRect();\n\n    const blockEl = getDraggableBlockFromCoords(cellRect, this.pmView);\n    if (!blockEl) {\n      throw new Error(\n        \"Found table cell element, but could not find surrounding blockContent element.\"\n      );\n    }\n    this.tableId = blockEl.id;\n\n    if (\n      this.state !== undefined &&\n      this.state.show &&\n      this.tableId === blockEl.id &&\n      this.state.rowIndex === rowIndex &&\n      this.state.colIndex === colIndex\n    ) {\n      return;\n    }\n\n    let block: Block<any, any, any> | undefined = undefined;\n\n    // Copied from `getBlock`. We don't use `getBlock` since we also need the PM\n    // node for the table, so we would effectively be doing the same work twice.\n    this.editor._tiptapEditor.state.doc.descendants((node, pos) => {\n      if (typeof block !== \"undefined\") {\n        return false;\n      }\n\n      if (node.type.name !== \"blockContainer\" || node.attrs.id !== blockEl.id) {\n        return true;\n      }\n\n      block = nodeToBlock(\n        node,\n        this.editor.schema.blockSchema,\n        this.editor.schema.inlineContentSchema,\n        this.editor.schema.styleSchema,\n        this.editor.blockCache\n      );\n      this.tablePos = pos + 1;\n\n      return false;\n    });\n\n    this.state = {\n      show: true,\n      referencePosCell: cellRect,\n      referencePosTable: tableRect,\n\n      block: block! as SpecificBlock<BSchema, \"table\", I, S>,\n      colIndex: colIndex,\n      rowIndex: rowIndex,\n\n      draggingState: undefined,\n    };\n    this.emitUpdate();\n\n    return false;\n  };\n\n  dragOverHandler = (event: DragEvent) => {\n    if (this.state?.draggingState === undefined) {\n      return;\n    }\n\n    event.preventDefault();\n    event.dataTransfer!.dropEffect = \"move\";\n\n    hideElementsWithClassNames([\n      \"column-resize-handle\",\n      \"prosemirror-dropcursor-block\",\n      \"prosemirror-dropcursor-inline\",\n    ]);\n\n    // The mouse cursor coordinates, bounded to the table's bounding box. The\n    // bounding box is shrunk by 1px on each side to ensure that the bounded\n    // coordinates are always inside a table cell.\n    const boundedMouseCoords = {\n      left: Math.min(\n        Math.max(event.clientX, this.state.referencePosTable.left + 1),\n        this.state.referencePosTable.right - 1\n      ),\n      top: Math.min(\n        Math.max(event.clientY, this.state.referencePosTable.top + 1),\n        this.state.referencePosTable.bottom - 1\n      ),\n    };\n\n    // Gets the table cell element that the bounded mouse cursor coordinates lie\n    // in.\n    const tableCellElements = document\n      .elementsFromPoint(boundedMouseCoords.left, boundedMouseCoords.top)\n      .filter(\n        (element) => element.tagName === \"TD\" || element.tagName === \"TH\"\n      );\n    if (tableCellElements.length === 0) {\n      throw new Error(\n        \"Could not find table cell element that the mouse cursor is hovering over.\"\n      );\n    }\n    const tableCellElement = tableCellElements[0];\n\n    let emitStateUpdate = false;\n\n    // Gets current row and column index.\n    const rowIndex = getChildIndex(tableCellElement.parentElement!);\n    const colIndex = getChildIndex(tableCellElement);\n\n    // Checks if the drop cursor needs to be updated. This affects decorations\n    // only so it doesn't trigger a state update.\n    const oldIndex =\n      this.state.draggingState.draggedCellOrientation === \"row\"\n        ? this.state.rowIndex\n        : this.state.colIndex;\n    const newIndex =\n      this.state.draggingState.draggedCellOrientation === \"row\"\n        ? rowIndex\n        : colIndex;\n    const dispatchDecorationsTransaction = newIndex !== oldIndex;\n\n    // Checks if either the hovered cell has changed and updates the row and\n    // column index. Also updates the reference DOMRect.\n    if (this.state.rowIndex !== rowIndex || this.state.colIndex !== colIndex) {\n      this.state.rowIndex = rowIndex;\n      this.state.colIndex = colIndex;\n\n      this.state.referencePosCell = tableCellElement.getBoundingClientRect();\n\n      emitStateUpdate = true;\n    }\n\n    // Checks if the mouse cursor position along the axis that the user is\n    // dragging on has changed and updates it.\n    const mousePos =\n      this.state.draggingState.draggedCellOrientation === \"row\"\n        ? boundedMouseCoords.top\n        : boundedMouseCoords.left;\n    if (this.state.draggingState.mousePos !== mousePos) {\n      this.state.draggingState.mousePos = mousePos;\n\n      emitStateUpdate = true;\n    }\n\n    // Emits a state update if any of the fields have changed.\n    if (emitStateUpdate) {\n      this.emitUpdate();\n    }\n\n    // Dispatches a dummy transaction to force a decorations update if\n    // necessary.\n    if (dispatchDecorationsTransaction) {\n      this.pmView.dispatch(\n        this.pmView.state.tr.setMeta(tableHandlesPluginKey, true)\n      );\n    }\n  };\n\n  dropHandler = (event: DragEvent) => {\n    if (this.state === undefined || this.state.draggingState === undefined) {\n      return;\n    }\n\n    event.preventDefault();\n\n    const rows = this.state.block.content.rows;\n\n    if (this.state.draggingState.draggedCellOrientation === \"row\") {\n      const rowToMove = rows[this.state.draggingState.originalIndex];\n      rows.splice(this.state.draggingState.originalIndex, 1);\n      rows.splice(this.state.rowIndex, 0, rowToMove);\n    } else {\n      const cellsToMove = rows.map(\n        (row) => row.cells[this.state!.draggingState!.originalIndex]\n      );\n      rows.forEach((row, rowIndex) => {\n        row.cells.splice(this.state!.draggingState!.originalIndex, 1);\n        row.cells.splice(this.state!.colIndex, 0, cellsToMove[rowIndex]);\n      });\n    }\n\n    this.editor.updateBlock(this.state.block, {\n      type: \"table\",\n      content: {\n        type: \"tableContent\",\n        rows: rows,\n      },\n    });\n  };\n\n  scrollHandler = () => {\n    if (this.state?.show) {\n      const tableElement = document.querySelector(\n        `[data-node-type=\"blockContainer\"][data-id=\"${this.tableId}\"] table`\n      )!;\n      const cellElement = tableElement.querySelector(\n        `tr:nth-child(${this.state.rowIndex + 1}) > td:nth-child(${\n          this.state.colIndex + 1\n        })`\n      )!;\n\n      this.state.referencePosTable = tableElement.getBoundingClientRect();\n      this.state.referencePosCell = cellElement.getBoundingClientRect();\n      this.emitUpdate();\n    }\n  };\n\n  destroy() {\n    this.pmView.dom.removeEventListener(\"mousedown\", this.mouseMoveHandler);\n\n    document.removeEventListener(\"dragover\", this.dragOverHandler);\n    document.removeEventListener(\"drop\", this.dropHandler);\n\n    document.removeEventListener(\"scroll\", this.scrollHandler);\n  }\n}\n\nexport const tableHandlesPluginKey = new PluginKey(\"TableHandlesPlugin\");\n\nexport class TableHandlesProsemirrorPlugin<\n  I extends InlineContentSchema,\n  S extends StyleSchema\n> extends EventEmitter<any> {\n  private view:\n    | TableHandlesView<\n        BlockSchemaWithBlock<\"table\", DefaultBlockSchema[\"table\"]>,\n        I,\n        S\n      >\n    | undefined;\n  public readonly plugin: Plugin;\n\n  constructor(\n    private readonly editor: BlockNoteEditor<\n      BlockSchemaWithBlock<\"table\", DefaultBlockSchema[\"table\"]>,\n      I,\n      S\n    >\n  ) {\n    super();\n    this.plugin = new Plugin({\n      key: tableHandlesPluginKey,\n      view: (editorView) => {\n        this.view = new TableHandlesView(editor, editorView, (state) => {\n          this.emit(\"update\", state);\n        });\n        return this.view;\n      },\n      // We use decorations to render the drop cursor when dragging a table row\n      // or column. The decorations are updated in the `dragOverHandler` method.\n      props: {\n        decorations: (state) => {\n          if (\n            this.view === undefined ||\n            this.view.state === undefined ||\n            this.view.state.draggingState === undefined ||\n            this.view.tablePos === undefined\n          ) {\n            return;\n          }\n\n          const newIndex =\n            this.view.state.draggingState.draggedCellOrientation === \"row\"\n              ? this.view.state.rowIndex\n              : this.view.state.colIndex;\n\n          const decorations: Decoration[] = [];\n\n          if (newIndex === this.view.state.draggingState.originalIndex) {\n            return DecorationSet.create(state.doc, decorations);\n          }\n\n          // Gets the table to show the drop cursor in.\n          const tableResolvedPos = state.doc.resolve(this.view.tablePos + 1);\n          const tableNode = tableResolvedPos.node();\n\n          if (this.view.state.draggingState.draggedCellOrientation === \"row\") {\n            // Gets the row at the new index.\n            const rowResolvedPos = state.doc.resolve(\n              tableResolvedPos.posAtIndex(newIndex) + 1\n            );\n            const rowNode = rowResolvedPos.node();\n\n            // Iterates over all cells in the row.\n            for (let i = 0; i < rowNode.childCount; i++) {\n              // Gets each cell in the row.\n              const cellResolvedPos = state.doc.resolve(\n                rowResolvedPos.posAtIndex(i) + 1\n              );\n              const cellNode = cellResolvedPos.node();\n\n              // Creates a decoration at the start or end of each cell,\n              // depending on whether the new index is before or after the\n              // original index.\n              const decorationPos =\n                cellResolvedPos.pos +\n                (newIndex > this.view.state.draggingState.originalIndex\n                  ? cellNode.nodeSize - 2\n                  : 0);\n              decorations.push(\n                // The widget is a small bar which spans the width of the cell.\n                Decoration.widget(decorationPos, () => {\n                  const widget = document.createElement(\"div\");\n                  widget.className = \"bn-table-drop-cursor\";\n                  widget.style.left = \"0\";\n                  widget.style.right = \"0\";\n                  // This is only necessary because the drop indicator's height\n                  // is an even number of pixels, whereas the border between\n                  // table cells is an odd number of pixels. So this makes the\n                  // positioning slightly more consistent regardless of where\n                  // the row is being dropped.\n                  if (\n                    newIndex > this.view!.state!.draggingState!.originalIndex\n                  ) {\n                    widget.style.bottom = \"-2px\";\n                  } else {\n                    widget.style.top = \"-3px\";\n                  }\n                  widget.style.height = \"4px\";\n\n                  return widget;\n                })\n              );\n            }\n          } else {\n            // Iterates over all rows in the table.\n            for (let i = 0; i < tableNode.childCount; i++) {\n              // Gets each row in the table.\n              const rowResolvedPos = state.doc.resolve(\n                tableResolvedPos.posAtIndex(i) + 1\n              );\n\n              // Gets the cell at the new index in the row.\n              const cellResolvedPos = state.doc.resolve(\n                rowResolvedPos.posAtIndex(newIndex) + 1\n              );\n              const cellNode = cellResolvedPos.node();\n\n              // Creates a decoration at the start or end of each cell,\n              // depending on whether the new index is before or after the\n              // original index.\n              const decorationPos =\n                cellResolvedPos.pos +\n                (newIndex > this.view.state.draggingState.originalIndex\n                  ? cellNode.nodeSize - 2\n                  : 0);\n              decorations.push(\n                // The widget is a small bar which spans the height of the cell.\n                Decoration.widget(decorationPos, () => {\n                  const widget = document.createElement(\"div\");\n                  widget.className = \"bn-table-drop-cursor\";\n                  widget.style.top = \"0\";\n                  widget.style.bottom = \"0\";\n                  // This is only necessary because the drop indicator's width\n                  // is an even number of pixels, whereas the border between\n                  // table cells is an odd number of pixels. So this makes the\n                  // positioning slightly more consistent regardless of where\n                  // the column is being dropped.\n                  if (\n                    newIndex > this.view!.state!.draggingState!.originalIndex\n                  ) {\n                    widget.style.right = \"-2px\";\n                  } else {\n                    widget.style.left = \"-3px\";\n                  }\n                  widget.style.width = \"4px\";\n\n                  return widget;\n                })\n              );\n            }\n          }\n\n          return DecorationSet.create(state.doc, decorations);\n        },\n      },\n    });\n  }\n\n  public onUpdate(callback: (state: TableHandlesState<I, S>) => void) {\n    return this.on(\"update\", callback);\n  }\n\n  /**\n   * Callback that should be set on the `dragStart` event for whichever element\n   * is used as the column drag handle.\n   */\n  colDragStart = (event: {\n    dataTransfer: DataTransfer | null;\n    clientX: number;\n  }) => {\n    if (this.view!.state === undefined) {\n      throw new Error(\n        \"Attempted to drag table column, but no table block was hovered prior.\"\n      );\n    }\n\n    this.view!.state.draggingState = {\n      draggedCellOrientation: \"col\",\n      originalIndex: this.view!.state.colIndex,\n      mousePos: event.clientX,\n    };\n    this.view!.emitUpdate();\n\n    this.editor._tiptapEditor.view.dispatch(\n      this.editor._tiptapEditor.state.tr.setMeta(tableHandlesPluginKey, {\n        draggedCellOrientation:\n          this.view!.state.draggingState.draggedCellOrientation,\n        originalIndex: this.view!.state.colIndex,\n        newIndex: this.view!.state.colIndex,\n        tablePos: this.view!.tablePos,\n      })\n    );\n\n    setHiddenDragImage();\n    event.dataTransfer!.setDragImage(dragImageElement!, 0, 0);\n    event.dataTransfer!.effectAllowed = \"move\";\n  };\n\n  /**\n   * Callback that should be set on the `dragStart` event for whichever element\n   * is used as the row drag handle.\n   */\n  rowDragStart = (event: {\n    dataTransfer: DataTransfer | null;\n    clientY: number;\n  }) => {\n    if (this.view!.state === undefined) {\n      throw new Error(\n        \"Attempted to drag table row, but no table block was hovered prior.\"\n      );\n    }\n\n    this.view!.state.draggingState = {\n      draggedCellOrientation: \"row\",\n      originalIndex: this.view!.state.rowIndex,\n      mousePos: event.clientY,\n    };\n    this.view!.emitUpdate();\n\n    this.editor._tiptapEditor.view.dispatch(\n      this.editor._tiptapEditor.state.tr.setMeta(tableHandlesPluginKey, {\n        draggedCellOrientation:\n          this.view!.state.draggingState.draggedCellOrientation,\n        originalIndex: this.view!.state.rowIndex,\n        newIndex: this.view!.state.rowIndex,\n        tablePos: this.view!.tablePos,\n      })\n    );\n\n    setHiddenDragImage();\n    event.dataTransfer!.setDragImage(dragImageElement!, 0, 0);\n    event.dataTransfer!.effectAllowed = \"copyMove\";\n  };\n\n  /**\n   * Callback that should be set on the `dragEnd` event for both the element\n   * used as the row drag handle, and the one used as the column drag handle.\n   */\n  dragEnd = () => {\n    if (this.view!.state === undefined) {\n      throw new Error(\n        \"Attempted to drag table row, but no table block was hovered prior.\"\n      );\n    }\n\n    this.view!.state.draggingState = undefined;\n    this.view!.emitUpdate();\n\n    this.editor._tiptapEditor.view.dispatch(\n      this.editor._tiptapEditor.state.tr.setMeta(tableHandlesPluginKey, null)\n    );\n\n    unsetHiddenDragImage();\n  };\n\n  /**\n   * Freezes the drag handles. When frozen, they will stay attached to the same\n   * cell regardless of which cell is hovered by the mouse cursor.\n   */\n  freezeHandles = () => {\n    this.view!.menuFrozen = true;\n  };\n\n  /**\n   * Unfreezes the drag handles. When frozen, they will stay attached to the\n   * same cell regardless of which cell is hovered by the mouse cursor.\n   */\n  unfreezeHandles = () => {\n    this.view!.menuFrozen = false;\n  };\n}\n","import { Extension } from \"@tiptap/core\";\nimport { NodeSelection, Plugin } from \"prosemirror-state\";\nimport { Node } from \"prosemirror-model\";\n\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor\";\nimport { BlockSchema, InlineContentSchema, StyleSchema } from \"../../schema\";\nimport { createExternalHTMLExporter } from \"./html/externalHTMLExporter\";\nimport { createInternalHTMLSerializer } from \"./html/internalHTMLSerializer\";\nimport { cleanHTMLToMarkdown } from \"./markdown/markdownExporter\";\nimport { EditorView } from \"prosemirror-view\";\n\nfunction selectedFragmentToHTML<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  view: EditorView,\n  editor: BlockNoteEditor<BSchema, I, S>\n): {\n  internalHTML: string;\n  externalHTML: string;\n  plainText: string;\n} {\n  const selectedFragment = view.state.selection.content().content;\n\n  const internalHTMLSerializer = createInternalHTMLSerializer(\n    view.state.schema,\n    editor\n  );\n  const internalHTML =\n    internalHTMLSerializer.serializeProseMirrorFragment(selectedFragment);\n\n  const externalHTMLExporter = createExternalHTMLExporter(\n    view.state.schema,\n    editor\n  );\n  const externalHTML =\n    externalHTMLExporter.exportProseMirrorFragment(selectedFragment);\n\n  const plainText = cleanHTMLToMarkdown(externalHTML);\n\n  return { internalHTML, externalHTML, plainText };\n}\n\nexport const createCopyToClipboardExtension = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  editor: BlockNoteEditor<BSchema, I, S>\n) =>\n  Extension.create<{ editor: BlockNoteEditor<BSchema, I, S> }, undefined>({\n    name: \"copyToClipboard\",\n    addProseMirrorPlugins() {\n      return [\n        new Plugin({\n          props: {\n            handleDOMEvents: {\n              copy(view, event) {\n                // Stops the default browser copy behaviour.\n                event.preventDefault();\n                event.clipboardData!.clearData();\n\n                // Checks if a `blockContent` node is being copied and expands\n                // the selection to the parent `blockContainer` node. This is\n                // for the use-case in which only a block without content is\n                // selected, e.g. an image block.\n                if (\n                  \"node\" in view.state.selection &&\n                  (view.state.selection.node as Node).type.spec.group ===\n                    \"blockContent\"\n                ) {\n                  view.dispatch(\n                    view.state.tr.setSelection(\n                      new NodeSelection(\n                        view.state.doc.resolve(view.state.selection.from - 1)\n                      )\n                    )\n                  );\n                }\n\n                const { internalHTML, externalHTML, plainText } =\n                  selectedFragmentToHTML(view, editor);\n\n                // TODO: Writing to other MIME types not working in Safari for\n                //  some reason.\n                event.clipboardData!.setData(\"blocknote/html\", internalHTML);\n                event.clipboardData!.setData(\"text/html\", externalHTML);\n                event.clipboardData!.setData(\"text/plain\", plainText);\n\n                // Prevent default PM handler to be called\n                return true;\n              },\n              // This is for the use-case in which only a block without content\n              // is selected, e.g. an image block, and dragged (not using the\n              // drag handle).\n              dragstart(view, event) {\n                // Checks if a `NodeSelection` is active.\n                if (!(\"node\" in view.state.selection)) {\n                  return;\n                }\n\n                // Checks if a `blockContent` node is being dragged.\n                if (\n                  (view.state.selection.node as Node).type.spec.group !==\n                  \"blockContent\"\n                ) {\n                  return;\n                }\n\n                // Expands the selection to the parent `blockContainer` node.\n                view.dispatch(\n                  view.state.tr.setSelection(\n                    new NodeSelection(\n                      view.state.doc.resolve(view.state.selection.from - 1)\n                    )\n                  )\n                );\n\n                // Stops the default browser drag start behaviour.\n                event.preventDefault();\n                event.dataTransfer!.clearData();\n\n                const { internalHTML, externalHTML, plainText } =\n                  selectedFragmentToHTML(view, editor);\n\n                // TODO: Writing to other MIME types not working in Safari for\n                //  some reason.\n                event.dataTransfer!.setData(\"blocknote/html\", internalHTML);\n                event.dataTransfer!.setData(\"text/html\", externalHTML);\n                event.dataTransfer!.setData(\"text/plain\", plainText);\n\n                // Prevent default PM handler to be called\n                return true;\n              },\n            },\n          },\n        }),\n      ];\n    },\n  });\n","import { Extension } from \"@tiptap/core\";\nimport { Plugin } from \"prosemirror-state\";\n\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor\";\nimport { BlockSchema, InlineContentSchema, StyleSchema } from \"../../schema\";\nimport { nestedListsToBlockNoteStructure } from \"./html/util/nestedLists\";\n\nconst acceptedMIMETypes = [\n  \"blocknote/html\",\n  \"text/html\",\n  \"text/plain\",\n] as const;\n\nexport const createPasteFromClipboardExtension = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  editor: BlockNoteEditor<BSchema, I, S>\n) =>\n  Extension.create<{ editor: BlockNoteEditor<BSchema, I, S> }, undefined>({\n    name: \"pasteFromClipboard\",\n    addProseMirrorPlugins() {\n      return [\n        new Plugin({\n          props: {\n            handleDOMEvents: {\n              paste(_view, event) {\n                event.preventDefault();\n                let format: (typeof acceptedMIMETypes)[number] | null = null;\n\n                for (const mimeType of acceptedMIMETypes) {\n                  if (event.clipboardData!.types.includes(mimeType)) {\n                    format = mimeType;\n                    break;\n                  }\n                }\n\n                if (format !== null) {\n                  let data = event.clipboardData!.getData(format);\n                  if (format === \"text/html\") {\n                    const htmlNode = nestedListsToBlockNoteStructure(\n                      data.trim()\n                    );\n\n                    data = htmlNode.innerHTML;\n                  }\n                  editor._tiptapEditor.view.pasteHTML(data);\n                }\n\n                return true;\n              },\n            },\n          },\n        }),\n      ];\n    },\n  });\n","import { Extension } from \"@tiptap/core\";\nimport { defaultProps } from \"../../blocks/defaultProps\";\n\nexport const BackgroundColorExtension = Extension.create({\n  name: \"blockBackgroundColor\",\n\n  addGlobalAttributes() {\n    return [\n      {\n        types: [\"blockContainer\"],\n        attributes: {\n          backgroundColor: {\n            default: defaultProps.backgroundColor.default,\n            parseHTML: (element) =>\n              element.hasAttribute(\"data-background-color\")\n                ? element.getAttribute(\"data-background-color\")\n                : defaultProps.backgroundColor.default,\n            renderHTML: (attributes) =>\n              attributes.backgroundColor !==\n                defaultProps.backgroundColor.default && {\n                \"data-background-color\": attributes.backgroundColor,\n              },\n          },\n        },\n      },\n    ];\n  },\n});\n","import { Extension } from \"@tiptap/core\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\n\nconst PLUGIN_KEY = new PluginKey(`blocknote-placeholder`);\n\n/**\n * This is a modified version of the tiptap\n * placeholder plugin, that also sets hasAnchorClass\n *\n * It does not set a data-placeholder (text is currently done in css)\n *\n */\nexport interface PlaceholderOptions {\n  placeholders: Record<string | \"default\", string>;\n}\n\nexport const Placeholder = Extension.create<PlaceholderOptions>({\n  name: \"placeholder\",\n\n  addOptions() {\n    return {\n      placeholders: {\n        default: \"Enter text or type '/' for commands\",\n        heading: \"Heading\",\n        bulletListItem: \"List\",\n        numberedListItem: \"List\",\n      },\n    };\n  },\n\n  addProseMirrorPlugins() {\n    const placeholders = this.options.placeholders;\n    return [\n      new Plugin({\n        key: PLUGIN_KEY,\n        view: () => {\n          const styleEl = document.createElement(\"style\");\n          document.head.appendChild(styleEl);\n          const styleSheet = styleEl.sheet!;\n\n          const getBaseSelector = (additionalSelectors = \"\") =>\n            `.bn-block-content${additionalSelectors} .bn-inline-content:has(> .ProseMirror-trailingBreak):before`;\n\n          const getSelector = (\n            blockType: string | \"default\",\n            mustBeFocused = true\n          ) => {\n            const mustBeFocusedSelector = mustBeFocused\n              ? `[data-is-empty-and-focused]`\n              : ``;\n\n            if (blockType === \"default\") {\n              return getBaseSelector(mustBeFocusedSelector);\n            }\n\n            const blockTypeSelector = `[data-content-type=\"${blockType}\"]`;\n            return getBaseSelector(mustBeFocusedSelector + blockTypeSelector);\n          };\n\n          for (const [blockType, placeholder] of Object.entries(placeholders)) {\n            const mustBeFocused = blockType === \"default\";\n\n            styleSheet.insertRule(\n              `${getSelector(\n                blockType,\n                mustBeFocused\n              )}{ content: ${JSON.stringify(placeholder)}; }`\n            );\n\n            // For some reason, the placeholders which show when the block is focused\n            // take priority over ones which show depending on block type, so we need\n            // to make sure the block specific ones are also used when the block is\n            // focused.\n            if (!mustBeFocused) {\n              styleSheet.insertRule(\n                `${getSelector(blockType, true)}{ content: ${JSON.stringify(\n                  placeholder\n                )}; }`\n              );\n            }\n          }\n\n          return {\n            destroy: () => {\n              document.head.removeChild(styleEl);\n            },\n          };\n        },\n        props: {\n          // TODO: maybe also add placeholder for empty document (\"e.g.: start writing..\")\n          decorations: (state) => {\n            const { doc, selection } = state;\n\n            const active = this.editor.isEditable;\n\n            if (!active) {\n              return;\n            }\n\n            if (!selection.empty) {\n              return;\n            }\n\n            const $pos = selection.$anchor;\n            const node = $pos.parent;\n\n            if (node.content.size > 0) {\n              return null;\n            }\n\n            const before = $pos.before();\n\n            const dec = Decoration.node(before, before + node.nodeSize, {\n              \"data-is-empty-and-focused\": \"true\",\n            });\n\n            return DecorationSet.create(doc, [dec]);\n          },\n        },\n      }),\n    ];\n  },\n});\n","import { Extension } from \"@tiptap/core\";\n\nexport const TextAlignmentExtension = Extension.create({\n  name: \"textAlignment\",\n\n  addGlobalAttributes() {\n    return [\n      {\n        // Attribute is applied to block content instead of container so that child blocks don't inherit the text\n        // alignment styling.\n        types: [\"paragraph\", \"heading\", \"bulletListItem\", \"numberedListItem\"],\n        attributes: {\n          textAlignment: {\n            default: \"left\",\n            parseHTML: (element) => {\n              return element.getAttribute(\"data-text-alignment\");\n            },\n            renderHTML: (attributes) =>\n              attributes.textAlignment !== \"left\" && {\n                \"data-text-alignment\": attributes.textAlignment,\n              },\n          },\n        },\n      },\n    ];\n  },\n});\n","import { Extension } from \"@tiptap/core\";\nimport { defaultProps } from \"../../blocks/defaultProps\";\n\nexport const TextColorExtension = Extension.create({\n  name: \"blockTextColor\",\n\n  addGlobalAttributes() {\n    return [\n      {\n        types: [\"blockContainer\"],\n        attributes: {\n          textColor: {\n            default: defaultProps.textColor.default,\n            parseHTML: (element) =>\n              element.hasAttribute(\"data-text-color\")\n                ? element.getAttribute(\"data-text-color\")\n                : defaultProps.textColor.default,\n            renderHTML: (attributes) =>\n              attributes.textColor !== defaultProps.textColor.default && {\n                \"data-text-color\": attributes.textColor,\n              },\n          },\n        },\n      },\n    ];\n  },\n});\n","import { Extension } from \"@tiptap/core\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\n\n// based on https://github.com/ueberdosis/tiptap/blob/40a9404c94c7fef7900610c195536384781ae101/demos/src/Experiments/TrailingNode/Vue/trailing-node.ts\n\n/**\n * Extension based on:\n * - https://github.com/ueberdosis/tiptap/blob/v1/packages/tiptap-extensions/src/extensions/TrailingNode.js\n * - https://github.com/remirror/remirror/blob/e0f1bec4a1e8073ce8f5500d62193e52321155b9/packages/prosemirror-trailing-node/src/trailing-node-plugin.ts\n */\n\nexport interface TrailingNodeOptions {\n  node: string;\n}\n\n/**\n * Add a trailing node to the document so the user can always click at the bottom of the document and start typing\n */\nexport const TrailingNode = Extension.create<TrailingNodeOptions>({\n  name: \"trailingNode\",\n\n  addProseMirrorPlugins() {\n    const plugin = new PluginKey(this.name);\n    // const disabledNodes = Object.entries(this.editor.schema.nodes)\n    //   .map(([, value]) => value)\n    //   .filter((node) => this.options.notAfter.includes(node.name));\n\n    return [\n      new Plugin({\n        key: plugin,\n        appendTransaction: (_, __, state) => {\n          const { doc, tr, schema } = state;\n          const shouldInsertNodeAtEnd = plugin.getState(state);\n          const endPosition = doc.content.size - 2;\n          const type = schema.nodes[\"blockContainer\"];\n          const contentType = schema.nodes[\"paragraph\"];\n          if (!shouldInsertNodeAtEnd) {\n            return;\n          }\n\n          return tr.insert(\n            endPosition,\n            type.create(undefined, contentType.create())\n          );\n        },\n        state: {\n          init: (_, _state) => {\n            // (maybe fix): use same logic as apply() here\n            // so it works when initializing\n          },\n          apply: (tr, value) => {\n            if (!tr.docChanged) {\n              return value;\n            }\n\n            let lastNode = tr.doc.lastChild;\n\n            if (!lastNode || lastNode.type.name !== \"blockGroup\") {\n              throw new Error(\"Expected blockGroup\");\n            }\n\n            lastNode = lastNode.lastChild;\n\n            if (!lastNode || lastNode.type.name !== \"blockContainer\") {\n              throw new Error(\"Expected blockContainer\");\n            }\n\n            const lastContentNode = lastNode.firstChild;\n\n            if (!lastContentNode) {\n              throw new Error(\"Expected blockContent\");\n            }\n\n            // If last node is not empty (size > 4) or it doesn't contain\n            // inline content, we need to add a trailing node.\n            return (\n              lastNode.nodeSize > 4 ||\n              lastContentNode.type.spec.content !== \"inline*\"\n            );\n          },\n        },\n      }),\n    ];\n  },\n});\n","import { Plugin, PluginKey } from \"prosemirror-state\";\n\nconst PLUGIN_KEY = new PluginKey(\"non-editable-block\");\n// Prevent typing for blocks without inline content, as this would otherwise\n// convert them into paragraph blocks.\nexport const NonEditableBlockPlugin = () => {\n  return new Plugin({\n    key: PLUGIN_KEY,\n    props: {\n      handleKeyDown: (view, event) => {\n        // Checks for node selection\n        if (\"node\" in view.state.selection) {\n          // Checks if key input will insert a character - we want to block this\n          // as it will convert the block into a paragraph.\n          if (\n            event.key.length === 1 &&\n            !event.ctrlKey &&\n            !event.altKey &&\n            !event.metaKey &&\n            !event.shiftKey\n          ) {\n            event.preventDefault();\n          }\n        }\n      },\n    },\n  });\n};\n","import { findChildren } from \"@tiptap/core\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\n\nconst PLUGIN_KEY = new PluginKey(`previous-blocks`);\n\nconst nodeAttributes: Record<string, string> = {\n  // Numbered List Items\n  index: \"index\",\n  // Headings\n  level: \"level\",\n  // All Blocks\n  type: \"type\",\n  depth: \"depth\",\n  \"depth-change\": \"depth-change\",\n};\n\n/**\n * This plugin tracks transformation of Block node attributes, so we can support CSS transitions.\n *\n * Problem it solves: ProseMirror recreates the DOM when transactions happen. So when a transaction changes a Node attribute,\n * it results in a completely new DOM element. This means CSS transitions don't work.\n *\n * Solution: When attributes change on a node, this plugin sets a data-* attribute with the \"previous\" value. This way we can still use CSS transitions. (See block.module.css)\n */\nexport const PreviousBlockTypePlugin = () => {\n  let timeout: any;\n  return new Plugin({\n    key: PLUGIN_KEY,\n    view(_editorView) {\n      return {\n        update: async (view, _prevState) => {\n          if (this.key?.getState(view.state).updatedBlocks.size > 0) {\n            // use setTimeout 0 to clear the decorations so that at least\n            // for one DOM-render the decorations have been applied\n            timeout = setTimeout(() => {\n              view.dispatch(\n                view.state.tr.setMeta(PLUGIN_KEY, { clearUpdate: true })\n              );\n            }, 0);\n          }\n        },\n        destroy: () => {\n          if (timeout) {\n            clearTimeout(timeout);\n          }\n        },\n      };\n    },\n    state: {\n      init() {\n        return {\n          // Block attributes, by block ID, from just before the previous transaction.\n          prevTransactionOldBlockAttrs: {} as any,\n          // Block attributes, by block ID, from just before the current transaction.\n          currentTransactionOldBlockAttrs: {} as any,\n          // Set of IDs of blocks whose attributes changed from the current transaction.\n          updatedBlocks: new Set<string>(),\n        };\n      },\n\n      apply(transaction, prev, oldState, newState) {\n        prev.currentTransactionOldBlockAttrs = {};\n        prev.updatedBlocks.clear();\n\n        if (!transaction.docChanged || oldState.doc.eq(newState.doc)) {\n          return prev;\n        }\n\n        // TODO: Instead of iterating through the entire document, only check nodes affected by the transactions. Will\n        //  also probably require checking nodes affected by the previous transaction too.\n        // We didn't get this to work yet:\n        // const transform = combineTransactionSteps(oldState.doc, [transaction]);\n        // // const { mapping } = transform;\n        // const changes = getChangedRanges(transform);\n        //\n        // changes.forEach(({ oldRange, newRange }) => {\n        // const oldNodes = findChildrenInRange(\n        //   oldState.doc,\n        //   oldRange,\n        //   (node) => node.attrs.id\n        // );\n        //\n        // const newNodes = findChildrenInRange(\n        //   newState.doc,\n        //   newRange,\n        //   (node) => node.attrs.id\n        // );\n\n        const currentTransactionOriginalOldBlockAttrs = {} as any;\n\n        const oldNodes = findChildren(oldState.doc, (node) => node.attrs.id);\n        const oldNodesById = new Map(\n          oldNodes.map((node) => [node.node.attrs.id, node])\n        );\n        const newNodes = findChildren(newState.doc, (node) => node.attrs.id);\n\n        // Traverses all block containers in the new editor state.\n        for (const node of newNodes) {\n          const oldNode = oldNodesById.get(node.node.attrs.id);\n\n          const oldContentNode = oldNode?.node.firstChild;\n          const newContentNode = node.node.firstChild;\n\n          if (oldNode && oldContentNode && newContentNode) {\n            const newAttrs = {\n              index: newContentNode.attrs.index,\n              level: newContentNode.attrs.level,\n              type: newContentNode.type.name,\n              depth: newState.doc.resolve(node.pos).depth,\n            };\n\n            let oldAttrs = {\n              index: oldContentNode.attrs.index,\n              level: oldContentNode.attrs.level,\n              type: oldContentNode.type.name,\n              depth: oldState.doc.resolve(oldNode.pos).depth,\n            };\n\n            currentTransactionOriginalOldBlockAttrs[node.node.attrs.id] =\n              oldAttrs;\n\n            // Whenever a transaction is appended by the OrderedListItemIndexPlugin, it's given the metadata:\n            // { \"orderedListIndexing\": true }\n            // These appended transactions happen immediately after any transaction which causes ordered list item\n            // indices to require updating, including those which trigger animations. Therefore, these animations are\n            // immediately overridden when the PreviousBlockTypePlugin processes the appended transaction, despite only\n            // the listItemIndex attribute changing. To solve this, oldAttrs must be edited for transactions with the\n            // \"orderedListIndexing\" metadata, so the correct animation can be re-triggered.\n            if (transaction.getMeta(\"numberedListIndexing\")) {\n              // If the block existed before the transaction, gets the attributes from before the previous transaction\n              // (i.e. the transaction that caused list item indices to need updating).\n              if (node.node.attrs.id in prev.prevTransactionOldBlockAttrs) {\n                oldAttrs =\n                  prev.prevTransactionOldBlockAttrs[node.node.attrs.id];\n              }\n\n              // Stops list item indices themselves being animated (looks smoother), unless the block's content type is\n              // changing from a numbered list item to something else.\n              if (newAttrs.type === \"numberedListItem\") {\n                oldAttrs.index = newAttrs.index;\n              }\n            }\n\n            prev.currentTransactionOldBlockAttrs[node.node.attrs.id] = oldAttrs;\n\n            // TODO: faster deep equal?\n            if (JSON.stringify(oldAttrs) !== JSON.stringify(newAttrs)) {\n              (oldAttrs as any)[\"depth-change\"] =\n                oldAttrs.depth - newAttrs.depth;\n\n              // for debugging:\n              // console.log(\n              //   \"id:\",\n              //   node.node.attrs.id,\n              //   \"previousBlockTypePlugin changes detected, oldAttrs\",\n              //   oldAttrs,\n              //   \"new\",\n              //   newAttrs\n              // );\n\n              prev.updatedBlocks.add(node.node.attrs.id);\n            }\n          }\n        }\n\n        prev.prevTransactionOldBlockAttrs =\n          currentTransactionOriginalOldBlockAttrs;\n\n        return prev;\n      },\n    },\n    props: {\n      decorations(state) {\n        const pluginState = (this as Plugin).getState(state);\n        if (pluginState.updatedBlocks.size === 0) {\n          return undefined;\n        }\n\n        const decorations: Decoration[] = [];\n\n        state.doc.descendants((node, pos) => {\n          if (!node.attrs.id) {\n            return;\n          }\n\n          if (!pluginState.updatedBlocks.has(node.attrs.id)) {\n            return;\n          }\n\n          const prevAttrs =\n            pluginState.currentTransactionOldBlockAttrs[node.attrs.id];\n          const decorationAttrs: any = {};\n\n          for (const [nodeAttr, val] of Object.entries(prevAttrs)) {\n            decorationAttrs[\"data-prev-\" + nodeAttributes[nodeAttr]] =\n              val || \"none\";\n          }\n\n          // for debugging:\n          // console.log(\n          //   \"previousBlockTypePlugin committing decorations\",\n          //   decorationAttrs\n          // );\n\n          const decoration = Decoration.node(pos, pos + node.nodeSize, {\n            ...decorationAttrs,\n          });\n\n          decorations.push(decoration);\n        });\n\n        return DecorationSet.create(state.doc, decorations);\n      },\n    },\n  });\n};\n","import { Node } from \"@tiptap/core\";\nimport { Fragment, Node as PMNode, Slice } from \"prosemirror-model\";\nimport { NodeSelection, TextSelection } from \"prosemirror-state\";\n\nimport { getBlockInfoFromPos } from \"../api/getBlockInfoFromPos\";\nimport {\n  blockToNode,\n  inlineContentToNodes,\n  tableContentToNodes,\n} from \"../api/nodeConversions/nodeConversions\";\nimport { PartialBlock } from \"../blocks/defaultBlocks\";\nimport type { BlockNoteEditor } from \"../editor/BlockNoteEditor\";\nimport { NonEditableBlockPlugin } from \"../extensions/NonEditableBlocks/NonEditableBlockPlugin\";\nimport { PreviousBlockTypePlugin } from \"../extensions/PreviousBlockType/PreviousBlockTypePlugin\";\nimport {\n  BlockNoteDOMAttributes,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../schema\";\nimport { mergeCSSClasses } from \"../util/browser\";\nimport { UnreachableCaseError } from \"../util/typescript\";\n\n// Object containing all possible block attributes.\nconst BlockAttributes: Record<string, string> = {\n  blockColor: \"data-block-color\",\n  blockStyle: \"data-block-style\",\n  id: \"data-id\",\n  depth: \"data-depth\",\n  depthChange: \"data-depth-change\",\n};\n\ndeclare module \"@tiptap/core\" {\n  interface Commands<ReturnType> {\n    block: {\n      BNCreateBlock: (pos: number) => ReturnType;\n      BNDeleteBlock: (posInBlock: number) => ReturnType;\n      BNMergeBlocks: (posBetweenBlocks: number) => ReturnType;\n      BNSplitBlock: (posInBlock: number, keepType: boolean) => ReturnType;\n      BNUpdateBlock: <\n        BSchema extends BlockSchema,\n        I extends InlineContentSchema,\n        S extends StyleSchema\n      >(\n        posInBlock: number,\n        block: PartialBlock<BSchema, I, S>\n      ) => ReturnType;\n      BNCreateOrUpdateBlock: <\n        BSchema extends BlockSchema,\n        I extends InlineContentSchema,\n        S extends StyleSchema\n      >(\n        posInBlock: number,\n        block: PartialBlock<BSchema, I, S>\n      ) => ReturnType;\n    };\n  }\n}\n\n/**\n * The main \"Block node\" documents consist of\n */\nexport const BlockContainer = Node.create<{\n  domAttributes?: BlockNoteDOMAttributes;\n  editor: BlockNoteEditor<BlockSchema, InlineContentSchema, StyleSchema>;\n}>({\n  name: \"blockContainer\",\n  group: \"blockContainer\",\n  // A block always contains content, and optionally a blockGroup which contains nested blocks\n  content: \"blockContent blockGroup?\",\n  // Ensures content-specific keyboard handlers trigger first.\n  priority: 50,\n  defining: true,\n\n  parseHTML() {\n    return [\n      {\n        tag: \"div\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          const attrs: Record<string, string> = {};\n          for (const [nodeAttr, HTMLAttr] of Object.entries(BlockAttributes)) {\n            if (element.getAttribute(HTMLAttr)) {\n              attrs[nodeAttr] = element.getAttribute(HTMLAttr)!;\n            }\n          }\n\n          if (element.getAttribute(\"data-node-type\") === \"blockContainer\") {\n            return attrs;\n          }\n\n          return false;\n        },\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    const blockOuter = document.createElement(\"div\");\n    blockOuter.className = \"bn-block-outer\";\n    blockOuter.setAttribute(\"data-node-type\", \"blockOuter\");\n    for (const [attribute, value] of Object.entries(HTMLAttributes)) {\n      if (attribute !== \"class\") {\n        blockOuter.setAttribute(attribute, value);\n      }\n    }\n\n    const blockHTMLAttributes = {\n      ...(this.options.domAttributes?.block || {}),\n      ...HTMLAttributes,\n    };\n    const block = document.createElement(\"div\");\n    block.className = mergeCSSClasses(\"bn-block\", blockHTMLAttributes.class);\n    block.setAttribute(\"data-node-type\", this.name);\n    for (const [attribute, value] of Object.entries(blockHTMLAttributes)) {\n      if (attribute !== \"class\") {\n        block.setAttribute(attribute, value);\n      }\n    }\n\n    blockOuter.appendChild(block);\n\n    return {\n      dom: blockOuter,\n      contentDOM: block,\n    };\n  },\n\n  addCommands() {\n    return {\n      // Creates a new text block at a given position.\n      BNCreateBlock:\n        (pos) =>\n        ({ state, dispatch }) => {\n          const newBlock =\n            state.schema.nodes[\"blockContainer\"].createAndFill()!;\n\n          if (dispatch) {\n            state.tr.insert(pos, newBlock);\n          }\n\n          return true;\n        },\n      // Deletes a block at a given position.\n      BNDeleteBlock:\n        (posInBlock) =>\n        ({ state, dispatch }) => {\n          const blockInfo = getBlockInfoFromPos(state.doc, posInBlock);\n          if (blockInfo === undefined) {\n            return false;\n          }\n\n          const { startPos, endPos } = blockInfo;\n\n          if (dispatch) {\n            state.tr.deleteRange(startPos, endPos);\n          }\n\n          return true;\n        },\n      // Updates a block at a given position.\n      BNUpdateBlock:\n        (posInBlock, block) =>\n        ({ state, dispatch }) => {\n          const blockInfo = getBlockInfoFromPos(state.doc, posInBlock);\n          if (blockInfo === undefined) {\n            return false;\n          }\n\n          const { startPos, endPos, node, contentNode } = blockInfo;\n\n          if (dispatch) {\n            // Adds blockGroup node with child blocks if necessary.\n            if (block.children !== undefined) {\n              const childNodes = [];\n\n              // Creates ProseMirror nodes for each child block, including their descendants.\n              for (const child of block.children) {\n                childNodes.push(\n                  blockToNode(\n                    child,\n                    state.schema,\n                    this.options.editor.schema.styleSchema\n                  )\n                );\n              }\n\n              // Checks if a blockGroup node already exists.\n              if (node.childCount === 2) {\n                // Replaces all child nodes in the existing blockGroup with the ones created earlier.\n                state.tr.replace(\n                  startPos + contentNode.nodeSize + 1,\n                  endPos - 1,\n                  new Slice(Fragment.from(childNodes), 0, 0)\n                );\n              } else {\n                // Inserts a new blockGroup containing the child nodes created earlier.\n                state.tr.insert(\n                  startPos + contentNode.nodeSize,\n                  state.schema.nodes[\"blockGroup\"].create({}, childNodes)\n                );\n              }\n            }\n\n            const oldType = contentNode.type.name;\n            const newType = block.type || oldType;\n\n            // The code below determines the new content of the block.\n            // or \"keep\" to keep as-is\n            let content: PMNode[] | \"keep\" = \"keep\";\n\n            // Has there been any custom content provided?\n            if (block.content) {\n              if (typeof block.content === \"string\") {\n                // Adds a single text node with no marks to the content.\n                content = [state.schema.text(block.content)];\n              } else if (Array.isArray(block.content)) {\n                // Adds a text node with the provided styles converted into marks to the content,\n                // for each InlineContent object.\n                content = inlineContentToNodes(\n                  block.content,\n                  state.schema,\n                  this.options.editor.schema.styleSchema\n                );\n              } else if (block.content.type === \"tableContent\") {\n                content = tableContentToNodes(\n                  block.content,\n                  state.schema,\n                  this.options.editor.schema.styleSchema\n                );\n              } else {\n                throw new UnreachableCaseError(block.content.type);\n              }\n            } else {\n              // no custom content has been provided, use existing content IF possible\n\n              // Since some block types contain inline content and others don't,\n              // we either need to call setNodeMarkup to just update type &\n              // attributes, or replaceWith to replace the whole blockContent.\n              const oldContentType = state.schema.nodes[oldType].spec.content;\n              const newContentType = state.schema.nodes[newType].spec.content;\n\n              if (oldContentType === \"\") {\n                // keep old content, because it's empty anyway and should be compatible with\n                // any newContentType\n              } else if (newContentType !== oldContentType) {\n                // the content type changed, replace the previous content\n                content = [];\n              } else {\n                // keep old content, because the content type is the same and should be compatible\n              }\n            }\n\n            // Now, changes the blockContent node type and adds the provided props\n            // as attributes. Also preserves all existing attributes that are\n            // compatible with the new type.\n            //\n            // Use either setNodeMarkup or replaceWith depending on whether the\n            // content is being replaced or not.\n            if (content === \"keep\") {\n              // use setNodeMarkup to only update the type and attributes\n              state.tr.setNodeMarkup(\n                startPos,\n                block.type === undefined\n                  ? undefined\n                  : state.schema.nodes[block.type],\n                {\n                  ...contentNode.attrs,\n                  ...block.props,\n                }\n              );\n            } else {\n              // use replaceWith to replace the content and the block itself\n              // also  reset the selection since replacing the block content\n              // sets it to the next block.\n              state.tr\n                .replaceWith(\n                  startPos,\n                  endPos,\n                  state.schema.nodes[newType].create(\n                    {\n                      ...contentNode.attrs,\n                      ...block.props,\n                    },\n                    content\n                  )\n                )\n                // If the node doesn't contain editable content, we want to\n                // select the whole node. But if it does have editable content,\n                // we want to set the selection to the start of it.\n                .setSelection(\n                  state.schema.nodes[newType].spec.content === \"\"\n                    ? new NodeSelection(state.tr.doc.resolve(startPos))\n                    : state.schema.nodes[newType].spec.content === \"inline*\"\n                    ? new TextSelection(state.tr.doc.resolve(startPos))\n                    : // Need to offset the position as we have to get through the\n                      // `tableRow` and `tableCell` nodes to get to the\n                      // `tableParagraph` node we want to set the selection in.\n                      new TextSelection(state.tr.doc.resolve(startPos + 4))\n                );\n            }\n\n            // Adds all provided props as attributes to the parent blockContainer node too, and also preserves existing\n            // attributes.\n            state.tr.setNodeMarkup(startPos - 1, undefined, {\n              ...node.attrs,\n              ...block.props,\n            });\n          }\n\n          return true;\n        },\n      // Appends the text contents of a block to the nearest previous block, given a position between them. Children of\n      // the merged block are moved out of it first, rather than also being merged.\n      //\n      // In the example below, the position passed into the function is between Block1 and Block2.\n      //\n      // Block1\n      //    Block2\n      // Block3\n      //    Block4\n      //        Block5\n      //\n      // Becomes:\n      //\n      // Block1\n      //    Block2Block3\n      // Block4\n      //     Block5\n      BNMergeBlocks:\n        (posBetweenBlocks) =>\n        ({ state, dispatch }) => {\n          const nextNodeIsBlock =\n            state.doc.resolve(posBetweenBlocks + 1).node().type.name ===\n            \"blockContainer\";\n          const prevNodeIsBlock =\n            state.doc.resolve(posBetweenBlocks - 1).node().type.name ===\n            \"blockContainer\";\n\n          if (!nextNodeIsBlock || !prevNodeIsBlock) {\n            return false;\n          }\n\n          const nextBlockInfo = getBlockInfoFromPos(\n            state.doc,\n            posBetweenBlocks + 1\n          );\n\n          const { node, contentNode, startPos, endPos, depth } = nextBlockInfo!;\n\n          // Removes a level of nesting all children of the next block by 1 level, if it contains both content and block\n          // group nodes.\n          if (node.childCount === 2) {\n            const childBlocksStart = state.doc.resolve(\n              startPos + contentNode.nodeSize + 1\n            );\n            const childBlocksEnd = state.doc.resolve(endPos - 1);\n            const childBlocksRange =\n              childBlocksStart.blockRange(childBlocksEnd);\n\n            // Moves the block group node inside the block into the block group node that the current block is in.\n            if (dispatch) {\n              state.tr.lift(childBlocksRange!, depth - 1);\n            }\n          }\n\n          let prevBlockEndPos = posBetweenBlocks - 1;\n          let prevBlockInfo = getBlockInfoFromPos(state.doc, prevBlockEndPos);\n\n          // Finds the nearest previous block, regardless of nesting level.\n          while (prevBlockInfo!.numChildBlocks > 0) {\n            prevBlockEndPos--;\n            prevBlockInfo = getBlockInfoFromPos(state.doc, prevBlockEndPos);\n            if (prevBlockInfo === undefined) {\n              return false;\n            }\n          }\n\n          // Deletes next block and adds its text content to the nearest previous block.\n\n          if (dispatch) {\n            dispatch(\n              state.tr\n                .deleteRange(startPos, startPos + contentNode.nodeSize)\n                .replace(\n                  prevBlockEndPos - 1,\n                  startPos,\n                  new Slice(contentNode.content, 0, 0)\n                )\n                .scrollIntoView()\n            );\n\n            state.tr.setSelection(\n              new TextSelection(state.doc.resolve(prevBlockEndPos - 1))\n            );\n          }\n\n          return true;\n        },\n      // Splits a block at a given position. Content after the position is moved to a new block below, at the same\n      // nesting level.\n      BNSplitBlock:\n        (posInBlock, keepType) =>\n        ({ state, dispatch }) => {\n          const blockInfo = getBlockInfoFromPos(state.doc, posInBlock);\n          if (blockInfo === undefined) {\n            return false;\n          }\n\n          const { contentNode, contentType, startPos, endPos, depth } =\n            blockInfo;\n\n          const originalBlockContent = state.doc.cut(startPos + 1, posInBlock);\n          const newBlockContent = state.doc.cut(posInBlock, endPos - 1);\n\n          const newBlock =\n            state.schema.nodes[\"blockContainer\"].createAndFill()!;\n\n          const newBlockInsertionPos = endPos + 1;\n          const newBlockContentPos = newBlockInsertionPos + 2;\n\n          if (dispatch) {\n            // Creates a new block. Since the schema requires it to have a content node, a paragraph node is created\n            // automatically, spanning newBlockContentPos to newBlockContentPos + 1.\n            state.tr.insert(newBlockInsertionPos, newBlock);\n\n            // Replaces the content of the newly created block's content node. Doesn't replace the whole content node so\n            // its type doesn't change.\n            state.tr.replace(\n              newBlockContentPos,\n              newBlockContentPos + 1,\n              newBlockContent.content.size > 0\n                ? new Slice(\n                    Fragment.from(newBlockContent),\n                    depth + 2,\n                    depth + 2\n                  )\n                : undefined\n            );\n\n            // Changes the type of the content node. The range doesn't matter as long as both from and to positions are\n            // within the content node.\n            if (keepType) {\n              state.tr.setBlockType(\n                newBlockContentPos,\n                newBlockContentPos,\n                state.schema.node(contentType).type,\n                contentNode.attrs\n              );\n            }\n\n            // Sets the selection to the start of the new block's content node.\n            state.tr.setSelection(\n              new TextSelection(state.doc.resolve(newBlockContentPos))\n            );\n\n            // Replaces the content of the original block's content node. Doesn't replace the whole content node so its\n            // type doesn't change.\n            state.tr.replace(\n              startPos + 1,\n              endPos - 1,\n              originalBlockContent.content.size > 0\n                ? new Slice(\n                    Fragment.from(originalBlockContent),\n                    depth + 2,\n                    depth + 2\n                  )\n                : undefined\n            );\n          }\n\n          return true;\n        },\n    };\n  },\n\n  addProseMirrorPlugins() {\n    return [PreviousBlockTypePlugin(), NonEditableBlockPlugin()];\n  },\n\n  addKeyboardShortcuts() {\n    // handleBackspace is partially adapted from https://github.com/ueberdosis/tiptap/blob/ed56337470efb4fd277128ab7ef792b37cfae992/packages/core/src/extensions/keymap.ts\n    const handleBackspace = () =>\n      this.editor.commands.first(({ commands }) => [\n        // Deletes the selection if it's not empty.\n        () => commands.deleteSelection(),\n        // Undoes an input rule if one was triggered in the last editor state change.\n        () => commands.undoInputRule(),\n        // Reverts block content type to a paragraph if the selection is at the start of the block.\n        () =>\n          commands.command(({ state }) => {\n            const { contentType, startPos } = getBlockInfoFromPos(\n              state.doc,\n              state.selection.from\n            )!;\n\n            const selectionAtBlockStart = state.selection.from === startPos + 1;\n            const isParagraph = contentType.name === \"paragraph\";\n\n            if (selectionAtBlockStart && !isParagraph) {\n              return commands.BNUpdateBlock(state.selection.from, {\n                type: \"paragraph\",\n                props: {},\n              });\n            }\n\n            return false;\n          }),\n        // Removes a level of nesting if the block is indented if the selection is at the start of the block.\n        () =>\n          commands.command(({ state }) => {\n            const { startPos } = getBlockInfoFromPos(\n              state.doc,\n              state.selection.from\n            )!;\n\n            const selectionAtBlockStart = state.selection.from === startPos + 1;\n\n            if (selectionAtBlockStart) {\n              return commands.liftListItem(\"blockContainer\");\n            }\n\n            return false;\n          }),\n        // Merges block with the previous one if it isn't indented, isn't the first block in the doc, and the selection\n        // is at the start of the block.\n        () =>\n          commands.command(({ state }) => {\n            const { depth, startPos } = getBlockInfoFromPos(\n              state.doc,\n              state.selection.from\n            )!;\n\n            const selectionAtBlockStart = state.selection.from === startPos + 1;\n            const selectionEmpty = state.selection.empty;\n            const blockAtDocStart = startPos === 2;\n\n            const posBetweenBlocks = startPos - 1;\n\n            if (\n              !blockAtDocStart &&\n              selectionAtBlockStart &&\n              selectionEmpty &&\n              depth === 2\n            ) {\n              return commands.BNMergeBlocks(posBetweenBlocks);\n            }\n\n            return false;\n          }),\n      ]);\n\n    const handleDelete = () =>\n      this.editor.commands.first(({ commands }) => [\n        // Deletes the selection if it's not empty.\n        () => commands.deleteSelection(),\n        // Merges block with the next one (at the same nesting level or lower),\n        // if one exists, the block has no children, and the selection is at the\n        // end of the block.\n        () =>\n          commands.command(({ state }) => {\n            const { node, depth, endPos } = getBlockInfoFromPos(\n              state.doc,\n              state.selection.from\n            )!;\n\n            const blockAtDocEnd = endPos === state.doc.nodeSize - 4;\n            const selectionAtBlockEnd = state.selection.from === endPos - 1;\n            const selectionEmpty = state.selection.empty;\n            const hasChildBlocks = node.childCount === 2;\n\n            if (\n              !blockAtDocEnd &&\n              selectionAtBlockEnd &&\n              selectionEmpty &&\n              !hasChildBlocks\n            ) {\n              let oldDepth = depth;\n              let newPos = endPos + 2;\n              let newDepth = state.doc.resolve(newPos).depth;\n\n              while (newDepth < oldDepth) {\n                oldDepth = newDepth;\n                newPos += 2;\n                newDepth = state.doc.resolve(newPos).depth;\n              }\n\n              return commands.BNMergeBlocks(newPos - 1);\n            }\n\n            return false;\n          }),\n      ]);\n\n    const handleEnter = () =>\n      this.editor.commands.first(({ commands }) => [\n        // Removes a level of nesting if the block is empty & indented, while the selection is also empty & at the start\n        // of the block.\n        () =>\n          commands.command(({ state }) => {\n            const { node, depth } = getBlockInfoFromPos(\n              state.doc,\n              state.selection.from\n            )!;\n\n            const selectionAtBlockStart =\n              state.selection.$anchor.parentOffset === 0;\n            const selectionEmpty =\n              state.selection.anchor === state.selection.head;\n            const blockEmpty = node.textContent.length === 0;\n            const blockIndented = depth > 2;\n\n            if (\n              selectionAtBlockStart &&\n              selectionEmpty &&\n              blockEmpty &&\n              blockIndented\n            ) {\n              return commands.liftListItem(\"blockContainer\");\n            }\n\n            return false;\n          }),\n        // Creates a new block and moves the selection to it if the current one is empty, while the selection is also\n        // empty & at the start of the block.\n        () =>\n          commands.command(({ state, chain }) => {\n            const { node, endPos } = getBlockInfoFromPos(\n              state.doc,\n              state.selection.from\n            )!;\n\n            const selectionAtBlockStart =\n              state.selection.$anchor.parentOffset === 0;\n            const selectionEmpty =\n              state.selection.anchor === state.selection.head;\n            const blockEmpty = node.textContent.length === 0;\n\n            if (selectionAtBlockStart && selectionEmpty && blockEmpty) {\n              const newBlockInsertionPos = endPos + 1;\n              const newBlockContentPos = newBlockInsertionPos + 2;\n\n              chain()\n                .BNCreateBlock(newBlockInsertionPos)\n                .setTextSelection(newBlockContentPos)\n                .run();\n\n              return true;\n            }\n\n            return false;\n          }),\n        // Splits the current block, moving content inside that's after the cursor to a new text block below. Also\n        // deletes the selection beforehand, if it's not empty.\n        () =>\n          commands.command(({ state, chain }) => {\n            const { node } = getBlockInfoFromPos(\n              state.doc,\n              state.selection.from\n            )!;\n\n            const selectionAtBlockStart =\n              state.selection.$anchor.parentOffset === 0;\n            const blockEmpty = node.textContent.length === 0;\n\n            if (!blockEmpty) {\n              chain()\n                .deleteSelection()\n                .BNSplitBlock(state.selection.from, selectionAtBlockStart)\n                .run();\n\n              return true;\n            }\n\n            return false;\n          }),\n      ]);\n\n    return {\n      Backspace: handleBackspace,\n      Delete: handleDelete,\n      Enter: handleEnter,\n      // Always returning true for tab key presses ensures they're not captured by the browser. Otherwise, they blur the\n      // editor since the browser will try to use tab for keyboard navigation.\n      Tab: () => {\n        this.editor.commands.sinkListItem(\"blockContainer\");\n        return true;\n      },\n      \"Shift-Tab\": () => {\n        this.editor.commands.liftListItem(\"blockContainer\");\n        return true;\n      },\n    };\n  },\n});\n","import { Node } from \"@tiptap/core\";\nimport { BlockNoteDOMAttributes } from \"../schema\";\nimport { mergeCSSClasses } from \"../util/browser\";\n\nexport const BlockGroup = Node.create<{\n  domAttributes?: BlockNoteDOMAttributes;\n}>({\n  name: \"blockGroup\",\n  group: \"blockGroup\",\n  content: \"blockContainer+\",\n\n  parseHTML() {\n    return [\n      {\n        tag: \"div\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          if (element.getAttribute(\"data-node-type\") === \"blockGroup\") {\n            // Null means the element matches, but we don't want to add any attributes to the node.\n            return null;\n          }\n\n          return false;\n        },\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    const blockGroupHTMLAttributes = {\n      ...(this.options.domAttributes?.blockGroup || {}),\n      ...HTMLAttributes,\n    };\n    const blockGroup = document.createElement(\"div\");\n    blockGroup.className = mergeCSSClasses(\n      \"bn-block-group\",\n      blockGroupHTMLAttributes.class\n    );\n    blockGroup.setAttribute(\"data-node-type\", \"blockGroup\");\n    for (const [attribute, value] of Object.entries(blockGroupHTMLAttributes)) {\n      if (attribute !== \"class\") {\n        blockGroup.setAttribute(attribute, value);\n      }\n    }\n\n    return {\n      dom: blockGroup,\n      contentDOM: blockGroup,\n    };\n  },\n});\n","import {Node} from \"@tiptap/core\";\n\nexport const Doc = Node.create({\n    name: \"doc\",\n    topNode: true,\n    content: \"blockGroup\",\n});\n","import { Extensions, extensions } from \"@tiptap/core\";\n\nimport type { BlockNoteEditor } from \"./BlockNoteEditor\";\n\nimport Collaboration from \"@tiptap/extension-collaboration\";\nimport CollaborationCursor from \"@tiptap/extension-collaboration-cursor\";\nimport { Dropcursor } from \"@tiptap/extension-dropcursor\";\nimport { Gapcursor } from \"@tiptap/extension-gapcursor\";\nimport { HardBreak } from \"@tiptap/extension-hard-break\";\nimport { History } from \"@tiptap/extension-history\";\nimport { Link } from \"@tiptap/extension-link\";\nimport { Text } from \"@tiptap/extension-text\";\nimport * as Y from \"yjs\";\nimport { createCopyToClipboardExtension } from \"../api/exporters/copyExtension\";\nimport { createPasteFromClipboardExtension } from \"../api/parsers/pasteExtension\";\nimport { BackgroundColorExtension } from \"../extensions/BackgroundColor/BackgroundColorExtension\";\nimport { Placeholder } from \"../extensions/Placeholder/PlaceholderExtension\";\nimport { TextAlignmentExtension } from \"../extensions/TextAlignment/TextAlignmentExtension\";\nimport { TextColorExtension } from \"../extensions/TextColor/TextColorExtension\";\nimport { TrailingNode } from \"../extensions/TrailingNode/TrailingNodeExtension\";\nimport UniqueID from \"../extensions/UniqueID/UniqueID\";\nimport { BlockContainer, BlockGroup, Doc } from \"../pm-nodes\";\nimport {\n  BlockNoteDOMAttributes,\n  BlockSchema,\n  BlockSpecs,\n  InlineContentSchema,\n  InlineContentSpecs,\n  StyleSchema,\n  StyleSpecs,\n} from \"../schema\";\n\n/**\n * Get all the Tiptap extensions BlockNote is configured with by default\n */\nexport const getBlockNoteExtensions = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(opts: {\n  editor: BlockNoteEditor<BSchema, I, S>;\n  placeholders?: Record<string | \"default\", string>;\n  domAttributes: Partial<BlockNoteDOMAttributes>;\n  blockSchema: BSchema;\n  blockSpecs: BlockSpecs;\n  inlineContentSpecs: InlineContentSpecs;\n  styleSpecs: StyleSpecs;\n  collaboration?: {\n    fragment: Y.XmlFragment;\n    user: {\n      name: string;\n      color: string;\n    };\n    provider: any;\n    renderCursor?: (user: any) => HTMLElement;\n  };\n}) => {\n  const ret: Extensions = [\n    extensions.ClipboardTextSerializer,\n    extensions.Commands,\n    extensions.Editable,\n    extensions.FocusEvents,\n    extensions.Tabindex,\n\n    // DevTools,\n    Gapcursor,\n\n    // DropCursor,\n    Placeholder.configure({\n      // TODO: This shorthand is kind of ugly\n      ...(opts.placeholders !== undefined\n        ? { placeholders: opts.placeholders }\n        : {}),\n    }),\n    UniqueID.configure({\n      types: [\"blockContainer\"],\n    }),\n    HardBreak,\n    // Comments,\n\n    // basics:\n    Text,\n\n    // marks:\n    Link,\n    ...Object.values(opts.styleSpecs).map((styleSpec) => {\n      return styleSpec.implementation.mark;\n    }),\n\n    TextColorExtension,\n\n    BackgroundColorExtension,\n    TextAlignmentExtension,\n\n    // nodes\n    Doc,\n    BlockContainer.configure({\n      editor: opts.editor as any,\n      domAttributes: opts.domAttributes,\n    }),\n    BlockGroup.configure({\n      domAttributes: opts.domAttributes,\n    }),\n    ...Object.values(opts.inlineContentSpecs)\n      .filter((a) => a.config !== \"link\" && a.config !== \"text\")\n      .map((inlineContentSpec) => {\n        return inlineContentSpec.implementation!.node.configure({\n          editor: opts.editor as any,\n        });\n      }),\n\n    ...Object.values(opts.blockSpecs).flatMap((blockSpec) => {\n      return [\n        // dependent nodes (e.g.: tablecell / row)\n        ...(blockSpec.implementation.requiredExtensions || []).map((ext) =>\n          ext.configure({\n            editor: opts.editor,\n            domAttributes: opts.domAttributes,\n          })\n        ),\n        // the actual node itself\n        blockSpec.implementation.node.configure({\n          editor: opts.editor,\n          domAttributes: opts.domAttributes,\n        }),\n      ];\n    }),\n    createCopyToClipboardExtension(opts.editor),\n    createPasteFromClipboardExtension(opts.editor),\n\n    Dropcursor.configure({ width: 5, color: \"#ddeeff\" }),\n    // This needs to be at the bottom of this list, because Key events (such as enter, when selecting a /command),\n    // should be handled before Enter handlers in other components like splitListItem\n    TrailingNode,\n  ];\n\n  if (opts.collaboration) {\n    ret.push(\n      Collaboration.configure({\n        fragment: opts.collaboration.fragment,\n      })\n    );\n    if (opts.collaboration.provider?.awareness) {\n      const defaultRender = (user: { color: string; name: string }) => {\n        const cursor = document.createElement(\"span\");\n\n        cursor.classList.add(\"collaboration-cursor__caret\");\n        cursor.setAttribute(\"style\", `border-color: ${user.color}`);\n\n        const label = document.createElement(\"span\");\n\n        label.classList.add(\"collaboration-cursor__label\");\n        label.setAttribute(\"style\", `background-color: ${user.color}`);\n        label.insertBefore(document.createTextNode(user.name), null);\n\n        const nonbreakingSpace1 = document.createTextNode(\"\\u2060\");\n        const nonbreakingSpace2 = document.createTextNode(\"\\u2060\");\n        cursor.insertBefore(nonbreakingSpace1, null);\n        cursor.insertBefore(label, null);\n        cursor.insertBefore(nonbreakingSpace2, null);\n        return cursor;\n      };\n      ret.push(\n        CollaborationCursor.configure({\n          user: opts.collaboration.user,\n          render: opts.collaboration.renderCursor || defaultRender,\n          provider: opts.collaboration.provider,\n        })\n      );\n    }\n  } else {\n    // disable history extension when collaboration is enabled as Yjs takes care of undo / redo\n    ret.push(History);\n  }\n\n  return ret;\n};\n","import { Fragment, Slice } from \"@tiptap/pm/model\";\nimport { EditorView } from \"@tiptap/pm/view\";\n\n// helper function to remove a child from a fragment\nfunction removeChild(node: Fragment, n: number) {\n  const children: any[] = [];\n  node.forEach((child, _, i) => {\n    if (i !== n) {\n      children.push(child);\n    }\n  });\n  return Fragment.from(children);\n}\n\n/**\n * fix for https://github.com/ProseMirror/prosemirror/issues/1430#issuecomment-1822570821\n *\n * Without this fix, pasting two paragraphs would cause the second one to be indented in the other\n * this fix wraps every element in the slice in it's own blockContainer, to prevent Prosemirror from nesting the\n * elements on paste.\n *\n * The exception is when we encounter blockGroups with listitems, because those actually should be nested\n */\nexport function transformPasted(slice: Slice, view: EditorView) {\n  let f = Fragment.from(slice.content);\n  for (let i = 0; i < f.childCount; i++) {\n    if (f.child(i).type.spec.group === \"blockContent\") {\n      const content = [f.child(i)];\n\n      // when there is a blockGroup with lists, it should be nested in the new blockcontainer\n      // (if we remove this if-block, the nesting bug will be fixed, but lists won't be nested correctly)\n      if (\n        i + 1 < f.childCount &&\n        f.child(i + 1).type.spec.group === \"blockGroup\"\n      ) {\n        const nestedChild = f\n          .child(i + 1)\n          .child(0)\n          .child(0);\n\n        if (\n          nestedChild.type.name === \"bulletListItem\" ||\n          nestedChild.type.name === \"numberedListItem\"\n        ) {\n          content.push(f.child(i + 1));\n          f = removeChild(f, i + 1);\n        }\n      }\n      const container = view.state.schema.nodes.blockContainer.create(\n        undefined,\n        content\n      );\n      f = f.replaceChild(i, container);\n    }\n  }\n\n  return new Slice(f, slice.openStart, slice.openEnd);\n}\n","import {\n  defaultBlockSpecs,\n  defaultInlineContentSpecs,\n  defaultStyleSpecs,\n} from \"../blocks/defaultBlocks\";\nimport {\n  BlockSchema,\n  BlockSchemaFromSpecs,\n  BlockSpecs,\n  InlineContentSchema,\n  InlineContentSchemaFromSpecs,\n  InlineContentSpecs,\n  StyleSchema,\n  StyleSchemaFromSpecs,\n  StyleSpecs,\n  getBlockSchemaFromSpecs,\n  getInlineContentSchemaFromSpecs,\n  getStyleSchemaFromSpecs,\n} from \"../schema\";\nimport type {\n  BlockNoDefaults,\n  PartialBlockNoDefaults,\n} from \"../schema/blocks/types\";\nimport type { BlockNoteEditor } from \"./BlockNoteEditor\";\n\nexport class BlockNoteSchema<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema\n> {\n  public readonly blockSpecs: BlockSpecs;\n  public readonly inlineContentSpecs: InlineContentSpecs;\n  public readonly styleSpecs: StyleSpecs;\n\n  public readonly blockSchema: BSchema;\n  public readonly inlineContentSchema: ISchema;\n  public readonly styleSchema: SSchema;\n\n  // Helper so that you can use typeof schema.BlockNoteEditor\n  public readonly BlockNoteEditor: BlockNoteEditor<BSchema, ISchema, SSchema> =\n    \"only for types\" as any;\n\n  public readonly Block: BlockNoDefaults<BSchema, ISchema, SSchema> =\n    \"only for types\" as any;\n\n  public readonly PartialBlock: PartialBlockNoDefaults<\n    BSchema,\n    ISchema,\n    SSchema\n  > = \"only for types\" as any;\n\n  public static create<\n    BSpecs extends BlockSpecs = typeof defaultBlockSpecs,\n    ISpecs extends InlineContentSpecs = typeof defaultInlineContentSpecs,\n    SSpecs extends StyleSpecs = typeof defaultStyleSpecs\n  >(options?: {\n    /**\n     * A list of custom block types that should be available in the editor.\n     */\n    blockSpecs?: BSpecs;\n    /**\n     * A list of custom InlineContent types that should be available in the editor.\n     */\n    inlineContentSpecs?: ISpecs;\n    /**\n     * A list of custom Styles that should be available in the editor.\n     */\n    styleSpecs?: SSpecs;\n  }) {\n    return new BlockNoteSchema<\n      BlockSchemaFromSpecs<BSpecs>,\n      InlineContentSchemaFromSpecs<ISpecs>,\n      StyleSchemaFromSpecs<SSpecs>\n    >(options);\n    // as BlockNoteSchema<\n    // BlockSchemaFromSpecs<BSpecs>,\n    // InlineContentSchemaFromSpecs<ISpecs>,\n    // StyleSchemaFromSpecs<SSpecs>\n    // >;\n  }\n\n  constructor(opts?: {\n    blockSpecs?: BlockSpecs;\n    inlineContentSpecs?: InlineContentSpecs;\n    styleSpecs?: StyleSpecs;\n  }) {\n    this.blockSpecs = opts?.blockSpecs || defaultBlockSpecs;\n    this.inlineContentSpecs =\n      opts?.inlineContentSpecs || defaultInlineContentSpecs;\n    this.styleSpecs = opts?.styleSpecs || defaultStyleSpecs;\n\n    this.blockSchema = getBlockSchemaFromSpecs(this.blockSpecs) as any;\n    this.inlineContentSchema = getInlineContentSchemaFromSpecs(\n      this.inlineContentSpecs\n    ) as any;\n    this.styleSchema = getStyleSchemaFromSpecs(this.styleSpecs) as any;\n  }\n}\n","import { EditorOptions, createDocument } from \"@tiptap/core\";\n// import \"./blocknote.css\";\nimport { Editor as TiptapEditor } from \"@tiptap/core\";\nimport { Node } from \"@tiptap/pm/model\";\nimport { EditorView } from \"@tiptap/pm/view\";\nimport { EditorState } from \"prosemirror-state\";\n\nimport { blockToNode } from \"../api/nodeConversions/nodeConversions\";\nimport { PartialBlock } from \"../blocks/defaultBlocks\";\nimport { StyleSchema } from \"../schema\";\n\nexport type BlockNoteTipTapEditorOptions = Partial<\n  Omit<EditorOptions, \"content\">\n> & {\n  content: PartialBlock<any, any, any>[];\n};\n\n/**\n * Custom Editor class that extends TiptapEditor and separates\n * the creation of the view from the constructor.\n */\n// @ts-ignore\nexport class BlockNoteTipTapEditor extends TiptapEditor {\n  private _state: EditorState;\n\n  constructor(options: BlockNoteTipTapEditorOptions, styleSchema: StyleSchema) {\n    // possible fix for next.js server side rendering\n    // const d = globalThis.document;\n    // const w = globalThis.window;\n    // if (!globalThis.document) {\n    //   globalThis.document = {\n    //     createElement: () => {},\n    //   };\n    // }\n    // if (!globalThis.window) {\n    //   globalThis.window = {\n    //     setTimeout: () => {},\n    //   };\n    // }\n    // options.injectCSS = false\n    super({ ...options, content: undefined });\n\n    // try {\n    //   globalThis.window = w;\n    //   } catch(e) {}\n    //   try {\n    //     globalThis.document = d;\n    //     } catch(e) {}\n\n    // This is a hack to make \"initial content detection\" by y-prosemirror (and also tiptap isEmpty)\n    // properly detect whether or not the document has changed.\n    // We change the doc.createAndFill function to make sure the initial block id is set, instead of null\n    const schema = this.schema;\n    let cache: any;\n    const oldCreateAndFill = schema.nodes.doc.createAndFill;\n    (schema.nodes.doc as any).createAndFill = (...args: any) => {\n      if (cache) {\n        return cache;\n      }\n      const ret = oldCreateAndFill.apply(schema.nodes.doc, args);\n\n      // create a copy that we can mutate (otherwise, assigning attrs is not safe and corrupts the pm state)\n      const jsonNode = JSON.parse(JSON.stringify(ret!.toJSON()));\n      jsonNode.content[0].content[0].attrs.id = \"initialBlockId\";\n\n      cache = Node.fromJSON(schema, jsonNode);\n      return cache;\n    };\n\n    let doc: Node;\n\n    try {\n      const pmNodes = options?.content.map((b) =>\n        blockToNode(b, this.schema, styleSchema).toJSON()\n      );\n      doc = createDocument(\n        {\n          type: \"doc\",\n          content: [\n            {\n              type: \"blockGroup\",\n              content: pmNodes,\n            },\n          ],\n        },\n        this.schema,\n        this.options.parseOptions\n      );\n    } catch (e) {\n      console.error(\n        \"Error creating document from blocks passed as `initialContent`. Caused by exception: \",\n        e\n      );\n      throw new Error(\n        \"Error creating document from blocks passed as `initialContent`:\\n\" +\n          +JSON.stringify(options.content)\n      );\n    }\n\n    // Create state immediately, so that it's available independently from the View,\n    // the way Prosemirror \"intends it to be\". This also makes sure that we can access\n    // the state before the view is created / mounted.\n    this._state = EditorState.create({\n      doc,\n      schema: this.schema,\n      // selection: selection || undefined,\n    });\n  }\n\n  get state() {\n    if (this.view) {\n      this._state = this.view.state;\n    }\n    return this._state;\n  }\n\n  createView() {\n    // no-op\n    // Disable default call to `createView` in the Editor constructor.\n    // We should call `createView` manually only when a DOM element is available\n  }\n\n  /**\n   * Replace the default `createView` method with a custom one - which we call on mount\n   */\n  private createViewAlternative() {\n    // Without queueMicrotask, custom IC / styles will give a React FlushSync error\n    queueMicrotask(() => {\n      this.view = new EditorView(this.options.element, {\n        ...this.options.editorProps,\n        // @ts-ignore\n        dispatchTransaction: this.dispatchTransaction.bind(this),\n        state: this.state,\n      });\n\n      // `editor.view` is not yet available at this time.\n      // Therefore we will add all plugins and node views directly afterwards.\n      const newState = this.state.reconfigure({\n        plugins: this.extensionManager.plugins,\n      });\n\n      this.view.updateState(newState);\n\n      this.createNodeViews();\n    });\n  }\n\n  /**\n   * Mounts / unmounts the editor to a dom element\n   *\n   * @param element DOM element to mount to, ur null / undefined to destroy\n   */\n  public mount = (element?: HTMLElement | null) => {\n    if (!element) {\n      this.destroy();\n    } else {\n      this.options.element = element;\n      // @ts-ignore\n      this.createViewAlternative();\n    }\n  };\n}\n","import { EditorOptions, Extension } from \"@tiptap/core\";\nimport { Node } from \"prosemirror-model\";\n// import \"./blocknote.css\";\nimport * as Y from \"yjs\";\nimport {\n  insertBlocks,\n  insertContentAt,\n  removeBlocks,\n  replaceBlocks,\n  updateBlock,\n} from \"../api/blockManipulation/blockManipulation\";\nimport { createExternalHTMLExporter } from \"../api/exporters/html/externalHTMLExporter\";\nimport { blocksToMarkdown } from \"../api/exporters/markdown/markdownExporter\";\nimport { getBlockInfoFromPos } from \"../api/getBlockInfoFromPos\";\nimport {\n  inlineContentToNodes,\n  nodeToBlock,\n} from \"../api/nodeConversions/nodeConversions\";\nimport { getNodeById } from \"../api/nodeUtil\";\nimport { HTMLToBlocks } from \"../api/parsers/html/parseHTML\";\nimport { markdownToBlocks } from \"../api/parsers/markdown/parseMarkdown\";\nimport {\n  Block,\n  DefaultBlockSchema,\n  DefaultInlineContentSchema,\n  DefaultStyleSchema,\n  PartialBlock,\n} from \"../blocks/defaultBlocks\";\nimport { FormattingToolbarProsemirrorPlugin } from \"../extensions/FormattingToolbar/FormattingToolbarPlugin\";\nimport { LinkToolbarProsemirrorPlugin } from \"../extensions/LinkToolbar/LinkToolbarPlugin\";\nimport { SideMenuProsemirrorPlugin } from \"../extensions/SideMenu/SideMenuPlugin\";\nimport { SuggestionMenuProseMirrorPlugin } from \"../extensions/SuggestionMenu/SuggestionPlugin\";\nimport { ImagePanelProsemirrorPlugin } from \"../extensions/ImagePanel/ImageToolbarPlugin\";\nimport { TableHandlesProsemirrorPlugin } from \"../extensions/TableHandles/TableHandlesPlugin\";\nimport { UniqueID } from \"../extensions/UniqueID/UniqueID\";\nimport {\n  BlockIdentifier,\n  BlockNoteDOMAttributes,\n  BlockSchema,\n  BlockSpecs,\n  InlineContentSchema,\n  InlineContentSpecs,\n  PartialInlineContent,\n  StyleSchema,\n  StyleSpecs,\n  Styles,\n} from \"../schema\";\nimport { mergeCSSClasses } from \"../util/browser\";\nimport { NoInfer, UnreachableCaseError } from \"../util/typescript\";\n\nimport { getBlockNoteExtensions } from \"./BlockNoteExtensions\";\nimport { TextCursorPosition } from \"./cursorPositionTypes\";\n\nimport { Selection } from \"./selectionTypes\";\nimport { transformPasted } from \"./transformPasted\";\n\nimport { checkDefaultBlockTypeInSchema } from \"../blocks/defaultBlockTypeGuards\";\nimport { BlockNoteSchema } from \"./BlockNoteSchema\";\nimport {\n  BlockNoteTipTapEditor,\n  BlockNoteTipTapEditorOptions,\n} from \"./BlockNoteTipTapEditor\";\n\n// CSS\nimport \"./Block.css\";\nimport \"./editor.css\";\n\nexport type BlockNoteEditorOptions<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema\n> = {\n  // TODO: Figure out if enableBlockNoteExtensions/disableHistoryExtension are needed and document them.\n  enableBlockNoteExtensions: boolean;\n\n  placeholders: Record<string | \"default\", string>;\n\n  /**\n   * An object containing attributes that should be added to HTML elements of the editor.\n   *\n   * @example { editor: { class: \"my-editor-class\" } }\n   */\n  domAttributes: Partial<BlockNoteDOMAttributes>;\n\n  /**\n   * The content that should be in the editor when it's created, represented as an array of partial block objects.\n   */\n  initialContent: PartialBlock<\n    NoInfer<BSchema>,\n    NoInfer<ISchema>,\n    NoInfer<SSchema>\n  >[];\n  /**\n   * Use default BlockNote font and reset the styles of <p> <li> <h1> elements etc., that are used in BlockNote.\n   *\n   * @default true\n   */\n  defaultStyles: boolean;\n\n  schema: BlockNoteSchema<BSchema, ISchema, SSchema>;\n\n  /**\n   * A custom function to handle file uploads.\n   * @param file The file that should be uploaded.\n   * @returns The URL of the uploaded file.\n   */\n  uploadFile: (file: File) => Promise<string>;\n\n  /**\n   * When enabled, allows for collaboration between multiple users.\n   */\n  collaboration: {\n    /**\n     * The Yjs XML fragment that's used for collaboration.\n     */\n    fragment: Y.XmlFragment;\n    /**\n     * The user info for the current user that's shown to other collaborators.\n     */\n    user: {\n      name: string;\n      color: string;\n    };\n    /**\n     * A Yjs provider (used for awareness / cursor information)\n     */\n    provider: any;\n    /**\n     * Optional function to customize how cursors of users are rendered\n     */\n    renderCursor?: (user: any) => HTMLElement;\n  };\n\n  // tiptap options, undocumented\n  _tiptapOptions: Partial<EditorOptions>;\n};\n\nconst blockNoteTipTapOptions = {\n  enableInputRules: true,\n  enablePasteRules: true,\n  enableCoreExtensions: false,\n};\n\nexport class BlockNoteEditor<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  ISchema extends InlineContentSchema = DefaultInlineContentSchema,\n  SSchema extends StyleSchema = DefaultStyleSchema\n> {\n  public readonly _tiptapEditor: BlockNoteTipTapEditor & {\n    contentComponent: any;\n  };\n  public blockCache = new WeakMap<Node, Block<any, any, any>>();\n  public readonly schema: BlockNoteSchema<BSchema, ISchema, SSchema>;\n\n  public readonly blockImplementations: BlockSpecs;\n  public readonly inlineContentImplementations: InlineContentSpecs;\n  public readonly styleImplementations: StyleSpecs;\n\n  public readonly formattingToolbar: FormattingToolbarProsemirrorPlugin;\n  public readonly linkToolbar: LinkToolbarProsemirrorPlugin<\n    BSchema,\n    ISchema,\n    SSchema\n  >;\n  public readonly sideMenu: SideMenuProsemirrorPlugin<\n    BSchema,\n    ISchema,\n    SSchema\n  >;\n  public readonly suggestionMenus: SuggestionMenuProseMirrorPlugin<\n    BSchema,\n    ISchema,\n    SSchema\n  >;\n  public readonly imagePanel?: ImagePanelProsemirrorPlugin<ISchema, SSchema>;\n  public readonly tableHandles?: TableHandlesProsemirrorPlugin<\n    ISchema,\n    SSchema\n  >;\n\n  public readonly uploadFile: ((file: File) => Promise<string>) | undefined;\n\n  public static create<\n    BSchema extends BlockSchema = DefaultBlockSchema,\n    ISchema extends InlineContentSchema = DefaultInlineContentSchema,\n    SSchema extends StyleSchema = DefaultStyleSchema\n  >(options: Partial<BlockNoteEditorOptions<BSchema, ISchema, SSchema>> = {}) {\n    return new BlockNoteEditor<BSchema, ISchema, SSchema>(options);\n  }\n\n  private constructor(\n    private readonly options: Partial<BlockNoteEditorOptions<any, any, any>>\n  ) {\n    const anyOpts = options as any;\n    if (anyOpts.onEditorContentChange) {\n      throw new Error(\n        \"onEditorContentChange initialization option is deprecated, use <BlockNoteView onChange={...} />, the useEditorChange(...) hook, or editor.onChange(...)\"\n      );\n    }\n\n    if (anyOpts.onTextCursorPositionChange) {\n      throw new Error(\n        \"onTextCursorPositionChange initialization option is deprecated, use <BlockNoteView onSelectionChange={...} />, the useEditorSelectionChange(...) hook, or editor.onSelectionChange(...)\"\n      );\n    }\n\n    if (anyOpts.onEditorReady) {\n      throw new Error(\n        \"onEditorReady is deprecated. Editor is immediately ready for use after creation.\"\n      );\n    }\n\n    if (anyOpts.editable) {\n      throw new Error(\n        \"editable initialization option is deprecated, use <BlockNoteView editable={true/false} />, or alternatively editor.isEditable = true/false\"\n      );\n    }\n\n    // apply defaults\n    const newOptions = {\n      defaultStyles: true,\n      schema: options.schema || BlockNoteSchema.create(),\n      ...options,\n    };\n\n    // @ts-ignore\n    this.schema = newOptions.schema;\n    this.blockImplementations = newOptions.schema.blockSpecs;\n    this.inlineContentImplementations = newOptions.schema.inlineContentSpecs;\n    this.styleImplementations = newOptions.schema.styleSpecs;\n\n    this.formattingToolbar = new FormattingToolbarProsemirrorPlugin(this);\n    this.linkToolbar = new LinkToolbarProsemirrorPlugin(this);\n    this.sideMenu = new SideMenuProsemirrorPlugin(this);\n    this.suggestionMenus = new SuggestionMenuProseMirrorPlugin(this);\n    if (checkDefaultBlockTypeInSchema(\"image\", this)) {\n      // Type guards only work on `const`s? Not working for `this`\n      this.imagePanel = new ImagePanelProsemirrorPlugin(this as any);\n    }\n    if (checkDefaultBlockTypeInSchema(\"table\", this)) {\n      this.tableHandles = new TableHandlesProsemirrorPlugin(this as any);\n    }\n\n    const extensions = getBlockNoteExtensions({\n      editor: this,\n      placeholders: newOptions.placeholders,\n      domAttributes: newOptions.domAttributes || {},\n      blockSchema: this.schema.blockSchema,\n      blockSpecs: this.schema.blockSpecs,\n      styleSpecs: this.schema.styleSpecs,\n      inlineContentSpecs: this.schema.inlineContentSpecs,\n      collaboration: newOptions.collaboration,\n    });\n\n    const blockNoteUIExtension = Extension.create({\n      name: \"BlockNoteUIExtension\",\n\n      addProseMirrorPlugins: () => {\n        return [\n          this.formattingToolbar.plugin,\n          this.linkToolbar.plugin,\n          this.sideMenu.plugin,\n          this.suggestionMenus.plugin,\n          ...(this.imagePanel ? [this.imagePanel.plugin] : []),\n          ...(this.tableHandles ? [this.tableHandles.plugin] : []),\n        ];\n      },\n    });\n    extensions.push(blockNoteUIExtension);\n\n    this.uploadFile = newOptions.uploadFile;\n\n    if (newOptions.collaboration && newOptions.initialContent) {\n      console.warn(\n        \"When using Collaboration, initialContent might cause conflicts, because changes should come from the collaboration provider\"\n      );\n    }\n\n    const initialContent =\n      newOptions.initialContent ||\n      (options.collaboration\n        ? [\n            {\n              type: \"paragraph\",\n              id: \"initialBlockId\",\n            },\n          ]\n        : [\n            {\n              type: \"paragraph\",\n              id: UniqueID.options.generateID(),\n            },\n          ]);\n\n    if (!Array.isArray(initialContent) || initialContent.length === 0) {\n      throw new Error(\n        \"initialContent must be a non-empty array of blocks, received: \" +\n          initialContent\n      );\n    }\n\n    const tiptapOptions: BlockNoteTipTapEditorOptions = {\n      ...blockNoteTipTapOptions,\n      ...newOptions._tiptapOptions,\n      content: initialContent,\n      extensions:\n        newOptions.enableBlockNoteExtensions === false\n          ? newOptions._tiptapOptions?.extensions || []\n          : [...(newOptions._tiptapOptions?.extensions || []), ...extensions],\n      editorProps: {\n        ...newOptions._tiptapOptions?.editorProps,\n        attributes: {\n          ...newOptions._tiptapOptions?.editorProps?.attributes,\n          ...newOptions.domAttributes?.editor,\n          class: mergeCSSClasses(\n            \"bn-editor\",\n            newOptions.defaultStyles ? \"bn-default-styles\" : \"\",\n            newOptions.domAttributes?.editor?.class || \"\"\n          ),\n        },\n        transformPasted,\n      },\n    };\n\n    this._tiptapEditor = new BlockNoteTipTapEditor(\n      tiptapOptions,\n      this.schema.styleSchema\n    ) as BlockNoteTipTapEditor & {\n      contentComponent: any;\n    };\n  }\n\n  /**\n   * Mount the editor to a parent DOM element. Call mount(undefined) to clean up\n   *\n   * @warning Not needed for React, use BlockNoteView to take care of this\n   */\n  public mount(parentElement?: HTMLElement | null) {\n    this._tiptapEditor.mount(parentElement);\n  }\n\n  public get prosemirrorView() {\n    return this._tiptapEditor.view;\n  }\n\n  public get domElement() {\n    return this._tiptapEditor.view.dom as HTMLDivElement;\n  }\n\n  public isFocused() {\n    return this._tiptapEditor.view.hasFocus();\n  }\n\n  public focus() {\n    this._tiptapEditor.view.focus();\n  }\n\n  /**\n   * @deprecated, use `editor.document` instead\n   */\n  public get topLevelBlocks(): Block<BSchema, ISchema, SSchema>[] {\n    return this.topLevelBlocks;\n  }\n\n  /**\n   * Gets a snapshot of all top-level (non-nested) blocks in the editor.\n   * @returns A snapshot of all top-level (non-nested) blocks in the editor.\n   */\n  public get document(): Block<BSchema, ISchema, SSchema>[] {\n    const blocks: Block<BSchema, ISchema, SSchema>[] = [];\n\n    this._tiptapEditor.state.doc.firstChild!.descendants((node) => {\n      blocks.push(\n        nodeToBlock(\n          node,\n          this.schema.blockSchema,\n          this.schema.inlineContentSchema,\n          this.schema.styleSchema,\n          this.blockCache\n        )\n      );\n\n      return false;\n    });\n\n    return blocks;\n  }\n\n  /**\n   * Gets a snapshot of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block that should be retrieved.\n   * @returns The block that matches the identifier, or `undefined` if no matching block was found.\n   */\n  public getBlock(\n    blockIdentifier: BlockIdentifier\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    const id =\n      typeof blockIdentifier === \"string\"\n        ? blockIdentifier\n        : blockIdentifier.id;\n    let newBlock: Block<BSchema, ISchema, SSchema> | undefined = undefined;\n\n    this._tiptapEditor.state.doc.firstChild!.descendants((node) => {\n      if (typeof newBlock !== \"undefined\") {\n        return false;\n      }\n\n      if (node.type.name !== \"blockContainer\" || node.attrs.id !== id) {\n        return true;\n      }\n\n      newBlock = nodeToBlock(\n        node,\n        this.schema.blockSchema,\n        this.schema.inlineContentSchema,\n        this.schema.styleSchema,\n        this.blockCache\n      );\n\n      return false;\n    });\n\n    return newBlock;\n  }\n\n  /**\n   * Traverses all blocks in the editor depth-first, and executes a callback for each.\n   * @param callback The callback to execute for each block. Returning `false` stops the traversal.\n   * @param reverse Whether the blocks should be traversed in reverse order.\n   */\n  public forEachBlock(\n    callback: (block: Block<BSchema, ISchema, SSchema>) => boolean,\n    reverse = false\n  ): void {\n    const blocks = this.document.slice();\n\n    if (reverse) {\n      blocks.reverse();\n    }\n\n    function traverseBlockArray(\n      blockArray: Block<BSchema, ISchema, SSchema>[]\n    ): boolean {\n      for (const block of blockArray) {\n        if (!callback(block)) {\n          return false;\n        }\n\n        const children = reverse\n          ? block.children.slice().reverse()\n          : block.children;\n\n        if (!traverseBlockArray(children)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    traverseBlockArray(blocks);\n  }\n\n  /**\n   * Executes a callback whenever the editor's contents change.\n   * @param callback The callback to execute.\n   */\n  public onEditorContentChange(callback: () => void) {\n    this._tiptapEditor.on(\"update\", callback);\n  }\n\n  /**\n   * Executes a callback whenever the editor's selection changes.\n   * @param callback The callback to execute.\n   */\n  public onEditorSelectionChange(callback: () => void) {\n    this._tiptapEditor.on(\"selectionUpdate\", callback);\n  }\n\n  /**\n   * Gets a snapshot of the current text cursor position.\n   * @returns A snapshot of the current text cursor position.\n   */\n  public getTextCursorPosition(): TextCursorPosition<\n    BSchema,\n    ISchema,\n    SSchema\n  > {\n    const { node, depth, startPos, endPos } = getBlockInfoFromPos(\n      this._tiptapEditor.state.doc,\n      this._tiptapEditor.state.selection.from\n    )!;\n\n    // Index of the current blockContainer node relative to its parent blockGroup.\n    const nodeIndex = this._tiptapEditor.state.doc\n      .resolve(endPos)\n      .index(depth - 1);\n    // Number of the parent blockGroup's child blockContainer nodes.\n    const numNodes = this._tiptapEditor.state.doc\n      .resolve(endPos + 1)\n      .node().childCount;\n\n    // Gets previous blockContainer node at the same nesting level, if the current node isn't the first child.\n    let prevNode: Node | undefined = undefined;\n    if (nodeIndex > 0) {\n      prevNode = this._tiptapEditor.state.doc.resolve(startPos - 2).node();\n    }\n\n    // Gets next blockContainer node at the same nesting level, if the current node isn't the last child.\n    let nextNode: Node | undefined = undefined;\n    if (nodeIndex < numNodes - 1) {\n      nextNode = this._tiptapEditor.state.doc.resolve(endPos + 2).node();\n    }\n\n    return {\n      block: nodeToBlock(\n        node,\n        this.schema.blockSchema,\n        this.schema.inlineContentSchema,\n        this.schema.styleSchema,\n        this.blockCache\n      ),\n      prevBlock:\n        prevNode === undefined\n          ? undefined\n          : nodeToBlock(\n              prevNode,\n              this.schema.blockSchema,\n              this.schema.inlineContentSchema,\n              this.schema.styleSchema,\n              this.blockCache\n            ),\n      nextBlock:\n        nextNode === undefined\n          ? undefined\n          : nodeToBlock(\n              nextNode,\n              this.schema.blockSchema,\n              this.schema.inlineContentSchema,\n              this.schema.styleSchema,\n              this.blockCache\n            ),\n    };\n  }\n\n  /**\n   * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could\n   * not be found.\n   * @param targetBlock The identifier of an existing block that the text cursor should be moved to.\n   * @param placement Whether the text cursor should be placed at the start or end of the block.\n   */\n  public setTextCursorPosition(\n    targetBlock: BlockIdentifier,\n    placement: \"start\" | \"end\" = \"start\"\n  ) {\n    const id = typeof targetBlock === \"string\" ? targetBlock : targetBlock.id;\n\n    const { posBeforeNode } = getNodeById(id, this._tiptapEditor.state.doc);\n    const { startPos, contentNode } = getBlockInfoFromPos(\n      this._tiptapEditor.state.doc,\n      posBeforeNode + 2\n    )!;\n\n    const contentType: \"none\" | \"inline\" | \"table\" =\n      this.schema.blockSchema[contentNode.type.name]!.content;\n\n    if (contentType === \"none\") {\n      this._tiptapEditor.commands.setNodeSelection(startPos);\n      return;\n    }\n\n    if (contentType === \"inline\") {\n      if (placement === \"start\") {\n        this._tiptapEditor.commands.setTextSelection(startPos + 1);\n      } else {\n        this._tiptapEditor.commands.setTextSelection(\n          startPos + contentNode.nodeSize - 1\n        );\n      }\n    } else if (contentType === \"table\") {\n      if (placement === \"start\") {\n        // Need to offset the position as we have to get through the `tableRow`\n        // and `tableCell` nodes to get to the `tableParagraph` node we want to\n        // set the selection in.\n        this._tiptapEditor.commands.setTextSelection(startPos + 4);\n      } else {\n        this._tiptapEditor.commands.setTextSelection(\n          startPos + contentNode.nodeSize - 4\n        );\n      }\n    } else {\n      throw new UnreachableCaseError(contentType);\n    }\n  }\n\n  /**\n   * Gets a snapshot of the current selection.\n   */\n  public getSelection(): Selection<BSchema, ISchema, SSchema> | undefined {\n    // Either the TipTap selection is empty, or it's a node selection. In either\n    // case, it only spans one block, so we return undefined.\n    if (\n      this._tiptapEditor.state.selection.from ===\n        this._tiptapEditor.state.selection.to ||\n      \"node\" in this._tiptapEditor.state.selection\n    ) {\n      return undefined;\n    }\n\n    const blocks: Block<BSchema, ISchema, SSchema>[] = [];\n\n    // TODO: This adds all child blocks to the same array. Needs to find min\n    //  depth and only add blocks at that depth.\n    this._tiptapEditor.state.doc.descendants((node, pos) => {\n      if (node.type.spec.group !== \"blockContent\") {\n        return true;\n      }\n\n      if (\n        pos + node.nodeSize < this._tiptapEditor.state.selection.from ||\n        pos > this._tiptapEditor.state.selection.to\n      ) {\n        return true;\n      }\n\n      blocks.push(\n        nodeToBlock(\n          this._tiptapEditor.state.doc.resolve(pos).node(),\n          this.schema.blockSchema,\n          this.schema.inlineContentSchema,\n          this.schema.styleSchema,\n          this.blockCache\n        )\n      );\n\n      return false;\n    });\n\n    return { blocks: blocks };\n  }\n\n  /**\n   * Checks if the editor is currently editable, or if it's locked.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  public get isEditable(): boolean {\n    return this._tiptapEditor.isEditable;\n  }\n\n  /**\n   * Makes the editor editable or locks it, depending on the argument passed.\n   * @param editable True to make the editor editable, or false to lock it.\n   */\n  public set isEditable(editable: boolean) {\n    if (this._tiptapEditor.options.editable !== editable) {\n      this._tiptapEditor.setEditable(editable);\n    }\n  }\n\n  /**\n   * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an\n   * error if the reference block could not be found.\n   * @param blocksToInsert An array of partial blocks that should be inserted.\n   * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.\n   * @param placement Whether the blocks should be inserted just before, just after, or nested inside the\n   * `referenceBlock`. Inserts the blocks at the start of the existing block's children if \"nested\" is used.\n   */\n  public insertBlocks(\n    blocksToInsert: PartialBlock<BSchema, ISchema, SSchema>[],\n    referenceBlock: BlockIdentifier,\n    placement: \"before\" | \"after\" | \"nested\" = \"before\"\n  ) {\n    return insertBlocks(blocksToInsert, referenceBlock, placement, this);\n  }\n\n  /**\n   * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be\n   * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could\n   * not be found.\n   * @param blockToUpdate The block that should be updated.\n   * @param update A partial block which defines how the existing block should be changed.\n   */\n  public updateBlock(\n    blockToUpdate: BlockIdentifier,\n    update: PartialBlock<BSchema, ISchema, SSchema>\n  ) {\n    return updateBlock(blockToUpdate, update, this);\n  }\n\n  /**\n   * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.\n   * @param blocksToRemove An array of identifiers for existing blocks that should be removed.\n   */\n  public removeBlocks(blocksToRemove: BlockIdentifier[]) {\n    return removeBlocks(blocksToRemove, this);\n  }\n\n  /**\n   * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or\n   * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in\n   * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.\n   * @param blocksToRemove An array of blocks that should be replaced.\n   * @param blocksToInsert An array of partial blocks to replace the old ones with.\n   */\n  public replaceBlocks(\n    blocksToRemove: BlockIdentifier[],\n    blocksToInsert: PartialBlock<BSchema, ISchema, SSchema>[]\n  ) {\n    return replaceBlocks(blocksToRemove, blocksToInsert, this);\n  }\n\n  /**\n   * Insert a piece of content at the current cursor position.\n   *\n   * @param content can be a string, or array of partial inline content elements\n   */\n  public insertInlineContent(content: PartialInlineContent<ISchema, SSchema>) {\n    const nodes = inlineContentToNodes(\n      content,\n      this._tiptapEditor.schema,\n      this.schema.styleSchema\n    );\n\n    insertContentAt(\n      {\n        from: this._tiptapEditor.state.selection.from,\n        to: this._tiptapEditor.state.selection.to,\n      },\n      nodes,\n      this\n    );\n  }\n\n  /**\n   * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.\n   */\n  public getActiveStyles() {\n    const styles: Styles<SSchema> = {};\n    const marks = this._tiptapEditor.state.selection.$to.marks();\n\n    for (const mark of marks) {\n      const config = this.schema.styleSchema[mark.type.name];\n      if (!config) {\n        console.warn(\"mark not found in styleschema\", mark.type.name);\n        continue;\n      }\n      if (config.propSchema === \"boolean\") {\n        (styles as any)[config.type] = true;\n      } else {\n        (styles as any)[config.type] = mark.attrs.stringValue;\n      }\n    }\n\n    return styles;\n  }\n\n  /**\n   * Adds styles to the currently selected content.\n   * @param styles The styles to add.\n   */\n  public addStyles(styles: Styles<SSchema>) {\n    this._tiptapEditor.view.focus();\n\n    for (const [style, value] of Object.entries(styles)) {\n      const config = this.schema.styleSchema[style];\n      if (!config) {\n        throw new Error(`style ${style} not found in styleSchema`);\n      }\n      if (config.propSchema === \"boolean\") {\n        this._tiptapEditor.commands.setMark(style);\n      } else if (config.propSchema === \"string\") {\n        this._tiptapEditor.commands.setMark(style, { stringValue: value });\n      } else {\n        throw new UnreachableCaseError(config.propSchema);\n      }\n    }\n  }\n\n  /**\n   * Removes styles from the currently selected content.\n   * @param styles The styles to remove.\n   */\n  public removeStyles(styles: Styles<SSchema>) {\n    this._tiptapEditor.view.focus();\n\n    for (const style of Object.keys(styles)) {\n      this._tiptapEditor.commands.unsetMark(style);\n    }\n  }\n\n  /**\n   * Toggles styles on the currently selected content.\n   * @param styles The styles to toggle.\n   */\n  public toggleStyles(styles: Styles<SSchema>) {\n    this._tiptapEditor.view.focus();\n\n    for (const [style, value] of Object.entries(styles)) {\n      const config = this.schema.styleSchema[style];\n      if (!config) {\n        throw new Error(`style ${style} not found in styleSchema`);\n      }\n      if (config.propSchema === \"boolean\") {\n        this._tiptapEditor.commands.toggleMark(style);\n      } else if (config.propSchema === \"string\") {\n        this._tiptapEditor.commands.toggleMark(style, { stringValue: value });\n      } else {\n        throw new UnreachableCaseError(config.propSchema);\n      }\n    }\n  }\n\n  /**\n   * Gets the currently selected text.\n   */\n  public getSelectedText() {\n    return this._tiptapEditor.state.doc.textBetween(\n      this._tiptapEditor.state.selection.from,\n      this._tiptapEditor.state.selection.to\n    );\n  }\n\n  /**\n   * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.\n   */\n  public getSelectedLinkUrl() {\n    return this._tiptapEditor.getAttributes(\"link\").href as string | undefined;\n  }\n\n  /**\n   * Creates a new link to replace the selected content.\n   * @param url The link URL.\n   * @param text The text to display the link with.\n   */\n  public createLink(url: string, text?: string) {\n    if (url === \"\") {\n      return;\n    }\n\n    const { from, to } = this._tiptapEditor.state.selection;\n\n    if (!text) {\n      text = this._tiptapEditor.state.doc.textBetween(from, to);\n    }\n\n    const mark = this._tiptapEditor.schema.mark(\"link\", { href: url });\n\n    this._tiptapEditor.view.dispatch(\n      this._tiptapEditor.view.state.tr\n        .insertText(text, from, to)\n        .addMark(from, from + text.length, mark)\n    );\n  }\n\n  /**\n   * Checks if the block containing the text cursor can be nested.\n   */\n  public canNestBlock() {\n    const { startPos, depth } = getBlockInfoFromPos(\n      this._tiptapEditor.state.doc,\n      this._tiptapEditor.state.selection.from\n    )!;\n\n    return this._tiptapEditor.state.doc.resolve(startPos).index(depth - 1) > 0;\n  }\n\n  /**\n   * Nests the block containing the text cursor into the block above it.\n   */\n  public nestBlock() {\n    this._tiptapEditor.commands.sinkListItem(\"blockContainer\");\n  }\n\n  /**\n   * Checks if the block containing the text cursor is nested.\n   */\n  public canUnnestBlock() {\n    const { depth } = getBlockInfoFromPos(\n      this._tiptapEditor.state.doc,\n      this._tiptapEditor.state.selection.from\n    )!;\n\n    return depth > 2;\n  }\n\n  /**\n   * Lifts the block containing the text cursor out of its parent.\n   */\n  public unnestBlock() {\n    this._tiptapEditor.commands.liftListItem(\"blockContainer\");\n  }\n\n  // TODO: Fix when implementing HTML/Markdown import & export\n  /**\n   * Serializes blocks into an HTML string. To better conform to HTML standards, children of blocks which aren't list\n   * items are un-nested in the output HTML.\n   * @param blocks An array of blocks that should be serialized into HTML.\n   * @returns The blocks, serialized as an HTML string.\n   */\n  public async blocksToHTMLLossy(\n    blocks: Block<BSchema, ISchema, SSchema>[] = this.document\n  ): Promise<string> {\n    const exporter = createExternalHTMLExporter(\n      this._tiptapEditor.schema,\n      this\n    );\n    return exporter.exportBlocks(blocks);\n  }\n\n  /**\n   * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and\n   * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote\n   * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.\n   * @param html The HTML string to parse blocks from.\n   * @returns The blocks parsed from the HTML string.\n   */\n  public async tryParseHTMLToBlocks(\n    html: string\n  ): Promise<Block<BSchema, ISchema, SSchema>[]> {\n    return HTMLToBlocks(\n      html,\n      this.schema.blockSchema,\n      this.schema.inlineContentSchema,\n      this.schema.styleSchema,\n      this._tiptapEditor.schema\n    );\n  }\n\n  /**\n   * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of\n   * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.\n   * @param blocks An array of blocks that should be serialized into Markdown.\n   * @returns The blocks, serialized as a Markdown string.\n   */\n  public async blocksToMarkdownLossy(\n    blocks: Block<BSchema, ISchema, SSchema>[] = this.document\n  ): Promise<string> {\n    return blocksToMarkdown(blocks, this._tiptapEditor.schema, this);\n  }\n\n  /**\n   * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on\n   * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it\n   * as text.\n   * @param markdown The Markdown string to parse blocks from.\n   * @returns The blocks parsed from the Markdown string.\n   */\n  public async tryParseMarkdownToBlocks(\n    markdown: string\n  ): Promise<Block<BSchema, ISchema, SSchema>[]> {\n    return markdownToBlocks(\n      markdown,\n      this.schema.blockSchema,\n      this.schema.inlineContentSchema,\n      this.schema.styleSchema,\n      this._tiptapEditor.schema\n    );\n  }\n\n  /**\n   * Updates the user info for the current user that's shown to other collaborators.\n   */\n  public updateCollaborationUserInfo(user: { name: string; color: string }) {\n    if (!this.options.collaboration) {\n      throw new Error(\n        \"Cannot update collaboration user info when collaboration is disabled.\"\n      );\n    }\n    this._tiptapEditor.commands.updateUser(user);\n  }\n\n  /**\n   * A callback function that runs whenever the editor's contents change.\n   *\n   * @param callback The callback to execute.\n   * @returns A function to remove the callback.\n   */\n  public onChange(\n    callback: (editor: BlockNoteEditor<BSchema, ISchema, SSchema>) => void\n  ) {\n    const cb = () => {\n      callback(this);\n    };\n\n    this._tiptapEditor.on(\"update\", cb);\n\n    return () => {\n      this._tiptapEditor.off(\"update\", cb);\n    };\n  }\n\n  /**\n   * A callback function that runs whenever the text cursor position or selection changes.\n   *\n   * @param callback The callback to execute.\n   * @returns A function to remove the callback.\n   */\n  public onSelectionChange(\n    callback: (editor: BlockNoteEditor<BSchema, ISchema, SSchema>) => void\n  ) {\n    const cb = () => {\n      callback(this);\n    };\n\n    this._tiptapEditor.on(\"selectionUpdate\", cb);\n\n    return () => {\n      this._tiptapEditor.off(\"selectionUpdate\", cb);\n    };\n  }\n}\n","import { Block, PartialBlock } from \"../../blocks/defaultBlocks\";\nimport { checkDefaultBlockTypeInSchema } from \"../../blocks/defaultBlockTypeGuards\";\nimport { BlockNoteEditor } from \"../../editor/BlockNoteEditor\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  isStyledTextInlineContent,\n  StyleSchema,\n} from \"../../schema\";\nimport { formatKeyboardShortcut } from \"../../util/browser\";\nimport { DefaultSuggestionItem } from \"./DefaultSuggestionItem\";\n\n// Sets the editor's text cursor position to the next content editable block,\n// so either a block with inline content or a table. The last block is always a\n// paragraph, so this function won't try to set the cursor position past the\n// last block.\nfunction setSelectionToNextContentEditableBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(editor: BlockNoteEditor<BSchema, I, S>) {\n  let block = editor.getTextCursorPosition().block;\n  let contentType = editor.schema.blockSchema[block.type].content;\n\n  while (contentType === \"none\") {\n    block = editor.getTextCursorPosition().nextBlock!;\n    contentType = editor.schema.blockSchema[block.type].content as\n      | \"inline\"\n      | \"table\"\n      | \"none\";\n    editor.setTextCursorPosition(block, \"end\");\n  }\n}\n\n// Checks if the current block is empty or only contains a slash, and if so,\n// updates the current block instead of inserting a new one below. If the new\n// block doesn't contain editable content, the cursor is moved to the next block\n// that does.\nexport function insertOrUpdateBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  block: PartialBlock<BSchema, I, S>\n): Block<BSchema, I, S> {\n  const currentBlock = editor.getTextCursorPosition().block;\n\n  if (currentBlock.content === undefined) {\n    throw new Error(\"Slash Menu open in a block that doesn't contain content.\");\n  }\n\n  if (\n    Array.isArray(currentBlock.content) &&\n    ((currentBlock.content.length === 1 &&\n      isStyledTextInlineContent(currentBlock.content[0]) &&\n      currentBlock.content[0].type === \"text\" &&\n      currentBlock.content[0].text === \"/\") ||\n      currentBlock.content.length === 0)\n  ) {\n    editor.updateBlock(currentBlock, block);\n  } else {\n    editor.insertBlocks([block], currentBlock, \"after\");\n    editor.setTextCursorPosition(\n      editor.getTextCursorPosition().nextBlock!,\n      \"end\"\n    );\n  }\n\n  const insertedBlock = editor.getTextCursorPosition().block;\n  setSelectionToNextContentEditableBlock(editor);\n\n  return insertedBlock;\n}\n\nexport function getDefaultSlashMenuItems<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(editor: BlockNoteEditor<BSchema, I, S>) {\n  const items: DefaultSuggestionItem[] = [];\n\n  if (checkDefaultBlockTypeInSchema(\"heading\", editor)) {\n    items.push(\n      {\n        title: \"Heading 1\",\n        onItemClick: () => {\n          insertOrUpdateBlock(editor, {\n            type: \"heading\",\n            props: { level: 1 },\n          });\n        },\n        subtext: \"Used for a top-level heading\",\n        badge: formatKeyboardShortcut(\"Mod-Alt-1\"),\n        aliases: [\"h\", \"heading1\", \"h1\"],\n        group: \"Headings\",\n      },\n      {\n        title: \"Heading 2\",\n        onItemClick: () => {\n          insertOrUpdateBlock(editor, {\n            type: \"heading\",\n            props: { level: 2 },\n          });\n        },\n        subtext: \"Used for key sections\",\n        badge: formatKeyboardShortcut(\"Mod-Alt-2\"),\n        aliases: [\"h2\", \"heading2\", \"subheading\"],\n        group: \"Headings\",\n      },\n      {\n        title: \"Heading 3\",\n        onItemClick: () => {\n          insertOrUpdateBlock(editor, {\n            type: \"heading\",\n            props: { level: 3 },\n          });\n        },\n        subtext: \"Used for subsections and group headings\",\n        badge: formatKeyboardShortcut(\"Mod-Alt-3\"),\n        aliases: [\"h3\", \"heading3\", \"subheading\"],\n        group: \"Headings\",\n      }\n    );\n  }\n\n  if (checkDefaultBlockTypeInSchema(\"numberedListItem\", editor)) {\n    items.push({\n      title: \"Numbered List\",\n      onItemClick: () => {\n        insertOrUpdateBlock(editor, {\n          type: \"numberedListItem\",\n        });\n      },\n      subtext: \"Used to display a numbered list\",\n      badge: formatKeyboardShortcut(\"Mod-Shift-7\"),\n      aliases: [\"ol\", \"li\", \"list\", \"numberedlist\", \"numbered list\"],\n      group: \"Basic blocks\",\n    });\n  }\n\n  if (checkDefaultBlockTypeInSchema(\"bulletListItem\", editor)) {\n    items.push({\n      title: \"Bullet List\",\n      onItemClick: () => {\n        insertOrUpdateBlock(editor, {\n          type: \"bulletListItem\",\n        });\n      },\n      subtext: \"Used to display an unordered list\",\n      badge: formatKeyboardShortcut(\"Mod-Shift-8\"),\n      aliases: [\"ul\", \"li\", \"list\", \"bulletlist\", \"bullet list\"],\n      group: \"Basic blocks\",\n    });\n  }\n\n  if (checkDefaultBlockTypeInSchema(\"paragraph\", editor)) {\n    items.push({\n      title: \"Paragraph\",\n      onItemClick: () => {\n        insertOrUpdateBlock(editor, {\n          type: \"paragraph\",\n        });\n      },\n      subtext: \"Used for the body of your document\",\n      badge: formatKeyboardShortcut(\"Mod-Alt-0\"),\n      aliases: [\"p\", \"paragraph\"],\n      group: \"Basic blocks\",\n    });\n  }\n\n  if (checkDefaultBlockTypeInSchema(\"table\", editor)) {\n    items.push({\n      title: \"Table\",\n      onItemClick: () => {\n        insertOrUpdateBlock(editor, {\n          type: \"table\",\n          content: {\n            type: \"tableContent\",\n            rows: [\n              {\n                cells: [\"\", \"\", \"\"],\n              },\n              {\n                cells: [\"\", \"\", \"\"],\n              },\n            ],\n          },\n        });\n      },\n      subtext: \"Used for for tables\",\n      aliases: [\"table\"],\n      group: \"Advanced\",\n      badge: undefined,\n    });\n  }\n\n  if (checkDefaultBlockTypeInSchema(\"image\", editor)) {\n    items.push({\n      title: \"Image\",\n      onItemClick: () => {\n        const insertedBlock = insertOrUpdateBlock(editor, {\n          type: \"image\",\n        });\n\n        // Immediately open the image toolbar\n        editor.prosemirrorView.dispatch(\n          editor._tiptapEditor.state.tr.setMeta(editor.imagePanel!.plugin, {\n            block: insertedBlock,\n          })\n        );\n      },\n      subtext: \"Insert an image\",\n      aliases: [\n        \"image\",\n        \"imageUpload\",\n        \"upload\",\n        \"img\",\n        \"picture\",\n        \"media\",\n        \"url\",\n        \"drive\",\n        \"dropbox\",\n      ],\n      group: \"Media\",\n    });\n  }\n\n  return items;\n}\n\nexport function filterSuggestionItems<\n  T extends { title: string; aliases?: readonly string[] }\n>(items: T[], query: string) {\n  return items.filter(\n    ({ title, aliases }) =>\n      title.toLowerCase().startsWith(query.toLowerCase()) ||\n      (aliases &&\n        aliases.filter((alias) =>\n          alias.toLowerCase().startsWith(query.toLowerCase())\n        ).length !== 0)\n  );\n}\n","import { Block, PartialBlock } from \"../../blocks/defaultBlocks\";\nimport UniqueID from \"../../extensions/UniqueID/UniqueID\";\nimport { BlockSchema, TableContent } from \"../../schema/blocks/types\";\nimport {\n  InlineContent,\n  InlineContentSchema,\n  PartialInlineContent,\n  StyledText,\n  isPartialLinkInlineContent,\n  isStyledTextInlineContent,\n} from \"../../schema/inlineContent/types\";\nimport { StyleSchema } from \"../../schema/styles/types\";\n\nfunction textShorthandToStyledText(\n  content: string | StyledText<any>[] = \"\"\n): StyledText<any>[] {\n  if (typeof content === \"string\") {\n    return [\n      {\n        type: \"text\",\n        text: content,\n        styles: {},\n      },\n    ];\n  }\n  return content;\n}\n\nfunction partialContentToInlineContent(\n  content: PartialInlineContent<any, any> | TableContent<any> | undefined\n): InlineContent<any, any>[] | TableContent<any> | undefined {\n  if (typeof content === \"string\") {\n    return textShorthandToStyledText(content);\n  }\n\n  if (Array.isArray(content)) {\n    return content.flatMap((partialContent) => {\n      if (typeof partialContent === \"string\") {\n        return textShorthandToStyledText(partialContent);\n      } else if (isPartialLinkInlineContent(partialContent)) {\n        return {\n          ...partialContent,\n          content: textShorthandToStyledText(partialContent.content),\n        };\n      } else if (isStyledTextInlineContent(partialContent)) {\n        return partialContent;\n      } else {\n        // custom inline content\n\n        return {\n          props: {},\n          ...partialContent,\n          content: partialContentToInlineContent(partialContent.content),\n        } as any;\n      }\n    });\n  }\n\n  return content;\n}\n\nexport function partialBlocksToBlocksForTesting<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  schema: BSchema,\n  partialBlocks: Array<PartialBlock<BSchema, I, S>>\n): Array<Block<BSchema, I, S>> {\n  return partialBlocks.map((partialBlock) =>\n    partialBlockToBlockForTesting(schema, partialBlock)\n  );\n}\n\nexport function partialBlockToBlockForTesting<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema\n>(\n  schema: BSchema,\n  partialBlock: PartialBlock<BSchema, I, S>\n): Block<BSchema, I, S> {\n  const withDefaults: Block<BSchema, I, S> = {\n    id: \"\",\n    type: partialBlock.type!,\n    props: {} as any,\n    content:\n      schema[partialBlock.type!].content === \"inline\" ? [] : (undefined as any),\n    children: [] as any,\n    ...partialBlock,\n  };\n\n  Object.entries(schema[partialBlock.type!].propSchema).forEach(\n    ([propKey, propValue]) => {\n      if (withDefaults.props[propKey] === undefined) {\n        (withDefaults.props as any)[propKey] = propValue.default;\n      }\n    }\n  );\n\n  return {\n    ...withDefaults,\n    content: partialContentToInlineContent(withDefaults.content),\n    children: withDefaults.children.map((c) => {\n      return partialBlockToBlockForTesting(schema, c);\n    }),\n  } as any;\n}\n\nexport function addIdsToBlock(block: PartialBlock<any, any, any>) {\n  if (!block.id) {\n    block.id = UniqueID.options.generateID();\n  }\n  if (block.children) {\n    addIdsToBlocks(block.children);\n  }\n}\n\nexport function addIdsToBlocks(blocks: PartialBlock<any, any, any>[]) {\n  for (const block of blocks) {\n    addIdsToBlock(block);\n  }\n}\n"],"names":["removeDuplicates","array","by","seen","item","key","findDuplicates","items","filtered","el","index","UniqueID","Extension","testOptions","v4","element","attributes","dragSourceElement","transformPasted","Plugin","PluginKey","transactions","oldState","newState","docChanges","transaction","filterTransactions","tr","_a","_b","types","attributeName","generateID","transform","combineTransactionSteps","mapping","getChangedRanges","newRange","newNodes","findChildrenInRange","node","newIds","id","duplicatedNewIds","pos","initialDoc","jsonNode","deleted","view","handleDragstart","event","slice","removeId","fragment","list","nodeWithoutId","Fragment","Slice","getBlockInfo","blockContainer","contentNode","contentType","numChildBlocks","getBlockInfoFromPos","doc","outerBlockGroupEndPos","$pos","maxDepth","depth","startPos","endPos","isLinkInlineContent","content","isPartialLinkInlineContent","isStyledTextInlineContent","UnreachableCaseError","val","styledTextToNodes","styledText","schema","styleSchema","marks","style","value","config","text","linkToNodes","link","linkMark","styledTextArrayToNodes","nodes","inlineContentToNodes","blockContent","blockOrInlineContentToContentNode","tableContentToNodes","tableContent","rowNodes","row","columnNodes","cell","pNode","textNodes","cellNode","rowNode","block","type","blockToNode","children","child","groupNode","contentNodeToTableContent","inlineContentSchema","ret","contentNodeToInlineContent","currentContent","nodeToCustomInlineContent","styles","mark","props","icConfig","attr","propSchema","nodeToBlock","blockSchema","blockCache","cachedBlock","blockInfo","blockSpec","blockConfig","i","options","serializeNodeInner","serializer","editor","toExternalHTML","dom","contentDOM","DOMSerializer","blockContentNode","blockGroupNode","impl","serializeProseMirrorFragment","internalHTML","parent","simplifyBlocks","listItemBlockTypes","simplifyBlocksHelper","tree","blockGroup","numChildElements","activeList","isListItemBlock","listItemBlockType","numElementsRemoved","fromDom","listItemElement","numElementsAdded","createExternalHTMLExporter","unified","rehypeParse","rehypeStringify","blocks","createInternalHTMLSerializer","uploadToTmpFilesDotOrg_DEV_ONLY","file","body","isAppleOS","formatKeyboardShortcut","shortcut","mergeCSSClasses","classes","c","isSafari","createDefaultBlockDOMOutputSpec","blockName","htmlTag","blockContentHTMLAttributes","inlineContentHTMLAttributes","attribute","inlineContent","defaultBlockToHTML","toDOM","renderSpec","defaultProps","inheritedProps","camelToDataKebab","str","propsToAttributes","tiptapAttributes","name","_spec","spec","asNumber","getBlockFromPos","getPos","tipTapEditor","blockIdentifier","wrapInBlockStructure","blockType","blockProps","domAttributes","prop","createStronglyTypedTiptapNode","Node","createInternalBlockSpec","implementation","createBlockSpecFromStronglyTypedTiptapNode","requiredExtensions","getBlockSchemaFromSpecs","specs","getParseRules","customParseFunction","rules","createBlockSpec","blockImplementation","div","blockContentDOMAttributes","output","addInlineContentAttributes","inlineContentType","inlineContentProps","addInlineContentKeyboardShortcuts","resolvedPos","createInternalInlineContentSpec","createInlineContentSpecFromTipTapNode","getInlineContentSchemaFromSpecs","getInlineContentParseRules","htmlElement","createInlineContentSpec","inlineContentConfig","inlineContentImplementation","stylePropsToAttributes","addStyleAttributes","styleType","styleValue","createInternalStyleSpec","createStyleSpecFromTipTapMark","getStyleSchemaFromSpecs","getStyleParseRules","createStyleSpec","styleConfig","styleImplementation","Mark","renderResult","BackgroundColorMark","HTMLAttributes","BackgroundColor","TextColorMark","TextColor","getCurrentBlockContentType","headingPropSchema","HeadingBlockContent","parsed","level","InputRule","state","chain","range","Heading","imagePropSchema","textAlignmentToAlignItems","textAlignment","minWidth","renderImage","wrapper","addImageButton","addImageButtonIcon","addImageButtonText","imageAndCaptionWrapper","imageWrapper","image","leftResizeHandle","rightResizeHandle","caption","handleEditorUpdate","selection","selectedBlock","resizeParams","windowMouseMoveHandler","newWidth","windowMouseUpHandler","addImageButtonMouseDownHandler","addImageButtonClickHandler","imageMouseEnterHandler","imageMouseLeaveHandler","leftResizeHandleMouseDownHandler","rightResizeHandleMouseDownHandler","Image","figure","img","figcaption","handleEnter","selectionEmpty","commands","bulletListItemPropSchema","BulletListItemBlockContent","BulletListItem","PLUGIN_KEY","NumberedListIndexingPlugin","_transactions","_oldState","modified","newIndex","isFirstBlockInDoc","prevBlockInfo","prevBlockContentNode","prevBlockIndex","numberedListItemPropSchema","NumberedListItemBlockContent","NumberedListItem","paragraphPropSchema","ParagraphBlockContent","Paragraph","TableExtension","columnResizing","tableEditing","selectionIsEmpty","selectionIsAtStartOfNode","selectionIsInTableParagraphNode","extension","context","callOrReturn","getExtensionField","tablePropSchema","TableBlockContent","TableParagraph","mergeAttributes","Table","TableHeader","TableCell","TableRow","defaultBlockSpecs","defaultBlockSchema","defaultStyleSpecs","Bold","Italic","Underline","Strike","Code","defaultStyleSchema","defaultInlineContentSpecs","defaultInlineContentSchema","checkDefaultBlockTypeInSchema","checkBlockIsDefaultType","checkBlockTypeHasDefaultProp","checkBlockHasDefaultProp","getNodeById","targetNode","posBeforeNode","insertBlocks","blocksToInsert","referenceBlock","placement","ttEditor","nodesToInsert","insertedBlocks","updateBlock","blockToUpdate","update","blockContainerNode","removeBlocksWithCallback","blocksToRemove","callback","idsOfBlocksToRemove","removedBlocks","removedSize","oldDocSize","newDocSize","notFoundIds","removeBlocks","replaceBlocks","idOfFirstBlock","insertContentAt","position","from","to","isOnlyTextContent","isOnlyBlockContent","selectionToInsertionEnd","removeUnderlines","removeUnderlinesHelper","cleanHTMLToMarkdown","cleanHTMLString","rehypeRemark","remarkGfm","remarkStringify","blocksToMarkdown","externalHTML","getChildIndex","isWhitespaceNode","liftNestedListsToParent","parentListItem","siblingsAfter","sibling","siblingContainer","createGroups","listItem","_detachedDoc","detachedDoc","nestedListsToBlockNoteStructure","elementOrHTML","HTMLToBlocks","html","icSchema","pmSchema","htmlNode","parentNode","DOMParser","code","properties","result","markdownToBlocks","markdown","htmlString","remarkParse","remarkRehype","defaultHandlers","EventEmitter","__publicField","fn","args","callbacks","FormattingToolbarView","pmView","emitUpdate","editorWrapper","composing","isSame","ranges","shouldShow","isNodeSelection","posToDOMRect","formattingToolbarPluginKey","FormattingToolbarProsemirrorPlugin","editorView","LinkToolbarView","hoveredLinkElement","posInHoveredLinkMark","resolvedPosInHoveredLinkMark","marksAtPos","getMarkRange","url","prevLinkMark","linkToolbarPluginKey","LinkToolbarProsemirrorPlugin","findBlock","findParentNode","SuggestionMenuView","decorationNode","suggestionMenuPluginKey","menuName","prevState","prev","next","started","stopped","SuggestionMenuProseMirrorPlugin","triggerCharacter","triggerCharacters","suggestionPluginTransactionMeta","_from","_to","suggestionPluginState","blockNode","DecorationSet","Decoration","createSuggestionMenu","MultipleNodeSelection","Selection","$anchor","$head","_pos","fromResult","toResult","dragImageElement","getDraggableBlockFromCoords","coords","blockPositionFromCoords","docView","desc","blockPositionsFromSelection","beforeFirstBlockPos","afterLastBlockPos","selectionStartInBlockContent","selectionEndInBlockContent","minDepth","startFirstBlockPos","endLastBlockPos","setDragImage","parentClone","getElementIndex","parentElement","targetElement","firstSelectedBlockIndex","lastSelectedBlockIndex","unsetDragImage","inheritedClasses","className","dragStart","e","editorBoundingBox","draggedBlockInSelection","multipleBlocksSelected","NodeSelection","selectedSlice","plainText","SideMenuView","evt","_event","editorOuterBoundingBox","cursorWithinEditor","_c","_d","_e","blockContentBoundingBox","newBlockInsertionPos","newBlockContentPos","sideMenuPluginKey","SideMenuProsemirrorPlugin","ImagePanelView","pluginKey","blockElement","pluginState","imagePanelPluginKey","ImagePanelProsemirrorPlugin","_editor","setHiddenDragImage","unsetHiddenDragImage","domCellAround","target","hideElementsWithClassNames","classNames","elementsToHide","TableHandlesView","colIndex","rowIndex","cellRect","tableRect","blockEl","boundedMouseCoords","tableCellElements","tableCellElement","emitStateUpdate","oldIndex","dispatchDecorationsTransaction","mousePos","tableHandlesPluginKey","rows","rowToMove","cellsToMove","tableElement","cellElement","TableHandlesProsemirrorPlugin","decorations","tableResolvedPos","tableNode","rowResolvedPos","cellResolvedPos","decorationPos","widget","selectedFragmentToHTML","selectedFragment","createCopyToClipboardExtension","acceptedMIMETypes","createPasteFromClipboardExtension","_view","format","mimeType","data","BackgroundColorExtension","Placeholder","placeholders","styleEl","styleSheet","getBaseSelector","additionalSelectors","getSelector","mustBeFocused","mustBeFocusedSelector","blockTypeSelector","placeholder","before","dec","TextAlignmentExtension","TextColorExtension","TrailingNode","plugin","_","__","shouldInsertNodeAtEnd","endPosition","_state","lastNode","lastContentNode","NonEditableBlockPlugin","nodeAttributes","PreviousBlockTypePlugin","timeout","_editorView","_prevState","currentTransactionOriginalOldBlockAttrs","oldNodes","findChildren","oldNodesById","oldNode","oldContentNode","newContentNode","newAttrs","oldAttrs","prevAttrs","decorationAttrs","nodeAttr","decoration","BlockAttributes","BlockContainer","attrs","HTMLAttr","blockOuter","blockHTMLAttributes","dispatch","newBlock","posInBlock","childNodes","oldType","newType","oldContentType","newContentType","TextSelection","posBetweenBlocks","nextNodeIsBlock","prevNodeIsBlock","nextBlockInfo","childBlocksStart","childBlocksEnd","childBlocksRange","prevBlockEndPos","keepType","originalBlockContent","newBlockContent","selectionAtBlockStart","isParagraph","blockAtDocStart","blockAtDocEnd","selectionAtBlockEnd","hasChildBlocks","oldDepth","newPos","newDepth","blockEmpty","blockIndented","BlockGroup","blockGroupHTMLAttributes","Doc","getBlockNoteExtensions","opts","extensions","Gapcursor","HardBreak","Text","Link","styleSpec","a","inlineContentSpec","ext","Dropcursor","Collaboration","defaultRender","user","cursor","label","nonbreakingSpace1","nonbreakingSpace2","CollaborationCursor","History","removeChild","n","f","nestedChild","container","BlockNoteSchema","BlockNoteTipTapEditor","TiptapEditor","cache","oldCreateAndFill","pmNodes","b","createDocument","EditorState","EditorView","blockNoteTipTapOptions","BlockNoteEditor","anyOpts","newOptions","blockNoteUIExtension","initialContent","tiptapOptions","_f","_h","_g","reverse","traverseBlockArray","blockArray","nodeIndex","numNodes","prevNode","nextNode","targetBlock","editable","cb","setSelectionToNextContentEditableBlock","insertOrUpdateBlock","currentBlock","insertedBlock","getDefaultSlashMenuItems","filterSuggestionItems","query","title","aliases","alias","textShorthandToStyledText","partialContentToInlineContent","partialContent","partialBlocksToBlocksForTesting","partialBlocks","partialBlock","partialBlockToBlockForTesting","withDefaults","propKey","propValue","addIdsToBlock","addIdsToBlocks"],"mappings":"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"}