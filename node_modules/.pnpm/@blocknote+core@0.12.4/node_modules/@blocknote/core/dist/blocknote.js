var me = Object.defineProperty;
var fe = (n, t, e) => t in n ? me(n, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[t] = e;
var d = (n, t, e) => (fe(n, typeof t != "symbol" ? t + "" : t, e), e);
import { Slice as U, Fragment as T, DOMSerializer as bt, DOMParser as ge, Node as be } from "prosemirror-model";
import zt from "rehype-parse";
import Vt from "rehype-stringify";
import { unified as kt } from "unified";
import { Extension as M, combineTransactionSteps as ke, getChangedRanges as ye, findChildrenInRange as we, Node as W, Mark as yt, InputRule as wt, callOrReturn as ve, getExtensionField as Ee, mergeAttributes as Se, selectionToInsertionEnd as Ce, isNodeSelection as xe, posToDOMRect as ft, getMarkRange as Mt, findParentNode as Te, findChildren as Bt, extensions as X, Editor as Me, createDocument as Be } from "@tiptap/core";
import { Plugin as v, PluginKey as x, Selection as ut, NodeSelection as it, TextSelection as ot, EditorState as Le } from "prosemirror-state";
import { v4 as Ie } from "uuid";
import { fromDom as Lt } from "hast-util-from-dom";
import Ne from "@tiptap/extension-bold";
import Ae from "@tiptap/extension-code";
import Pe from "@tiptap/extension-italic";
import He from "@tiptap/extension-strike";
import De from "@tiptap/extension-underline";
import { TableCell as Oe } from "@tiptap/extension-table-cell";
import { TableHeader as _e } from "@tiptap/extension-table-header";
import { TableRow as Ue } from "@tiptap/extension-table-row";
import { columnResizing as Re, tableEditing as ze } from "prosemirror-tables";
import Ve from "rehype-remark";
import Ft from "remark-gfm";
import Fe from "remark-stringify";
import $e from "remark-parse";
import Ge, { defaultHandlers as je } from "remark-rehype";
import { DecorationSet as G, Decoration as j, EditorView as We } from "prosemirror-view";
import qe from "@tiptap/extension-collaboration";
import Ke from "@tiptap/extension-collaboration-cursor";
import { Dropcursor as Je } from "@tiptap/extension-dropcursor";
import { Gapcursor as Xe } from "@tiptap/extension-gapcursor";
import { HardBreak as Ye } from "@tiptap/extension-hard-break";
import { History as Qe } from "@tiptap/extension-history";
import { Link as Ze } from "@tiptap/extension-link";
import { Text as tn } from "@tiptap/extension-text";
function en(n, t = JSON.stringify) {
  const e = {};
  return n.filter((o) => {
    const r = t(o);
    return Object.prototype.hasOwnProperty.call(e, r) ? !1 : e[r] = !0;
  });
}
function nn(n) {
  const t = n.filter(
    (o, r) => n.indexOf(o) !== r
  );
  return en(t);
}
const Z = M.create({
  name: "uniqueID",
  // we’ll set a very high priority to make sure this runs first
  // and is compatible with `appendTransaction` hooks of other extensions
  priority: 1e4,
  addOptions() {
    return {
      attributeName: "id",
      types: [],
      generateID: () => {
        if (typeof window < "u" && window.__TEST_OPTIONS) {
          const n = window.__TEST_OPTIONS;
          return n.mockID === void 0 ? n.mockID = 0 : n.mockID++, n.mockID.toString();
        }
        return Ie();
      },
      filterTransaction: null
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          [this.options.attributeName]: {
            default: null,
            parseHTML: (n) => n.getAttribute(`data-${this.options.attributeName}`),
            renderHTML: (n) => ({
              [`data-${this.options.attributeName}`]: n[this.options.attributeName]
            })
          }
        }
      }
    ];
  },
  // check initial content for missing ids
  // onCreate() {
  //   // Don’t do this when the collaboration extension is active
  //   // because this may update the content, so Y.js tries to merge these changes.
  //   // This leads to empty block nodes.
  //   // See: https://github.com/ueberdosis/tiptap/issues/2400
  //   if (
  //     this.editor.extensionManager.extensions.find(
  //       (extension) => extension.name === "collaboration"
  //     )
  //   ) {
  //     return;
  //   }
  //   const { view, state } = this.editor;
  //   const { tr, doc } = state;
  //   const { types, attributeName, generateID } = this.options;
  //   const nodesWithoutId = findChildren(doc, (node) => {
  //     return (
  //       types.includes(node.type.name) && node.attrs[attributeName] === null
  //     );
  //   });
  //   nodesWithoutId.forEach(({ node, pos }) => {
  //     tr.setNodeMarkup(pos, undefined, {
  //       ...node.attrs,
  //       [attributeName]: generateID(),
  //     });
  //   });
  //   tr.setMeta("addToHistory", false);
  //   view.dispatch(tr);
  // },
  addProseMirrorPlugins() {
    let n = null, t = !1;
    return [
      new v({
        key: new x("uniqueID"),
        appendTransaction: (e, o, r) => {
          const i = e.some((f) => f.docChanged) && !o.doc.eq(r.doc), s = this.options.filterTransaction && e.some((f) => {
            let k, S;
            return !(!((S = (k = this.options).filterTransaction) === null || S === void 0) && S.call(k, f));
          });
          if (!i || s)
            return;
          const { tr: a } = r, { types: l, attributeName: c, generateID: u } = this.options, p = ke(
            o.doc,
            e
          ), { mapping: m } = p;
          if (ye(p).forEach(({ newRange: f }) => {
            const k = we(
              r.doc,
              f,
              (E) => l.includes(E.type.name)
            ), S = k.map(({ node: E }) => E.attrs[c]).filter((E) => E !== null), B = nn(S);
            k.forEach(({ node: E, pos: O }) => {
              let V;
              const J = (V = a.doc.nodeAt(O)) === null || V === void 0 ? void 0 : V.attrs[c];
              if (J === null) {
                const ct = o.doc.type.createAndFill().content;
                if (o.doc.content.findDiffStart(ct) === null) {
                  const nt = JSON.parse(
                    JSON.stringify(r.doc.toJSON())
                  );
                  if (nt.content[0].content[0].attrs.id = "initialBlockId", JSON.stringify(nt.content) === JSON.stringify(ct.toJSON())) {
                    a.setNodeMarkup(O, void 0, {
                      ...E.attrs,
                      [c]: "initialBlockId"
                    });
                    return;
                  }
                }
                a.setNodeMarkup(O, void 0, {
                  ...E.attrs,
                  [c]: u()
                });
                return;
              }
              const { deleted: g } = m.invert().mapResult(O);
              g && B.includes(J) && a.setNodeMarkup(O, void 0, {
                ...E.attrs,
                [c]: u()
              });
            });
          }), !!a.steps.length)
            return a;
        },
        // we register a global drag handler to track the current drag source element
        view(e) {
          const o = (r) => {
            let i;
            n = !((i = e.dom.parentElement) === null || i === void 0) && i.contains(r.target) ? e.dom.parentElement : null;
          };
          return window.addEventListener("dragstart", o), {
            destroy() {
              window.removeEventListener("dragstart", o);
            }
          };
        },
        props: {
          // `handleDOMEvents` is called before `transformPasted`
          // so we can do some checks before
          handleDOMEvents: {
            // only create new ids for dropped content while holding `alt`
            // or content is dragged from another editor
            drop: (e, o) => {
              let r;
              return (n !== e.dom.parentElement || ((r = o.dataTransfer) === null || r === void 0 ? void 0 : r.effectAllowed) === "copy") && (n = null, t = !0), !1;
            },
            // always create new ids on pasted content
            paste: () => (t = !0, !1)
          },
          // we’ll remove ids for every pasted node
          // so we can create a new one within `appendTransaction`
          transformPasted: (e) => {
            if (!t)
              return e;
            const { types: o, attributeName: r } = this.options, i = (s) => {
              const a = [];
              return s.forEach((l) => {
                if (l.isText) {
                  a.push(l);
                  return;
                }
                if (!o.includes(l.type.name)) {
                  a.push(l.copy(i(l.content)));
                  return;
                }
                const c = l.type.create(
                  {
                    ...l.attrs,
                    [r]: null
                  },
                  i(l.content),
                  l.marks
                );
                a.push(c);
              }), T.from(a);
            };
            return t = !1, new U(
              i(e.content),
              e.openStart,
              e.openEnd
            );
          }
        }
      })
    ];
  }
});
function $t(n) {
  const t = n.attrs.id, e = n.firstChild, o = e.type, r = n.childCount === 2 ? n.lastChild.childCount : 0;
  return {
    id: t,
    node: n,
    contentNode: e,
    contentType: o,
    numChildBlocks: r
  };
}
function b(n, t) {
  const o = n.nodeSize - 2;
  if (t <= 1)
    for (t = 1 + 1; n.resolve(t).parent.type.name !== "blockContainer" && t < o; )
      t++;
  else if (t >= o)
    for (t = o - 1; n.resolve(t).parent.type.name !== "blockContainer" && t > 1; )
      t--;
  n.resolve(t).parent.type.name === "blockGroup" && t++;
  const r = n.resolve(t), i = r.depth;
  let s = r.node(i), a = i;
  for (; ; ) {
    if (a < 0)
      throw new Error(
        "Could not find blockContainer node. This can only happen if the underlying BlockNote schema has been edited."
      );
    if (s.type.name === "blockContainer")
      break;
    a -= 1, s = r.node(a);
  }
  const { id: l, contentNode: c, contentType: u, numChildBlocks: p } = $t(s), m = r.start(a), h = r.end(a);
  return {
    id: l,
    node: s,
    contentNode: c,
    contentType: u,
    numChildBlocks: p,
    startPos: m,
    endPos: h,
    depth: a
  };
}
function It(n) {
  return n.type === "link";
}
function Gt(n) {
  return typeof n != "string" && n.type === "link";
}
function Q(n) {
  return typeof n != "string" && n.type === "text";
}
class A extends Error {
  constructor(t) {
    super(`Unreachable case: ${t}`);
  }
}
function Nt(n, t, e) {
  const o = [];
  for (const [r, i] of Object.entries(n.styles)) {
    const s = e[r];
    if (!s)
      throw new Error(`style ${r} not found in styleSchema`);
    if (s.propSchema === "boolean")
      o.push(t.mark(r));
    else if (s.propSchema === "string")
      o.push(t.mark(r, { stringValue: i }));
    else
      throw new A(s.propSchema);
  }
  return n.text.split(/(\n)/g).filter((r) => r.length > 0).map((r) => r === `
` ? t.nodes.hardBreak.create() : t.text(r, o));
}
function on(n, t, e) {
  const o = t.marks.link.create({
    href: n.href
  });
  return gt(n.content, t, e).map(
    (r) => {
      if (r.type.name === "text")
        return r.mark([...r.marks, o]);
      if (r.type.name === "hardBreak")
        return r;
      throw new Error("unexpected node type");
    }
  );
}
function gt(n, t, e) {
  const o = [];
  if (typeof n == "string")
    return o.push(
      ...Nt(
        { type: "text", text: n, styles: {} },
        t,
        e
      )
    ), o;
  for (const r of n)
    o.push(...Nt(r, t, e));
  return o;
}
function at(n, t, e) {
  const o = [];
  for (const r of n)
    typeof r == "string" ? o.push(...gt(r, t, e)) : Gt(r) ? o.push(...on(r, t, e)) : Q(r) ? o.push(...gt([r], t, e)) : o.push(
      Wt(r, t, e)
    );
  return o;
}
function jt(n, t, e) {
  const o = [];
  for (const r of n.rows) {
    const i = [];
    for (const a of r.cells) {
      let l;
      if (!a)
        l = t.nodes.tableParagraph.create({});
      else if (typeof a == "string")
        l = t.nodes.tableParagraph.create({}, t.text(a));
      else {
        const u = at(a, t, e);
        l = t.nodes.tableParagraph.create({}, u);
      }
      const c = t.nodes.tableCell.create({}, l);
      i.push(c);
    }
    const s = t.nodes.tableRow.create({}, i);
    o.push(s);
  }
  return o;
}
function Wt(n, t, e) {
  let o, r = n.type;
  if (r === void 0 && (r = "paragraph"), !t.nodes[r])
    throw new Error(`node type ${r} not found in schema`);
  if (!n.content)
    o = t.nodes[r].create(n.props);
  else if (typeof n.content == "string")
    o = t.nodes[r].create(
      n.props,
      t.text(n.content)
    );
  else if (Array.isArray(n.content)) {
    const i = at(n.content, t, e);
    o = t.nodes[r].create(n.props, i);
  } else if (n.content.type === "tableContent") {
    const i = jt(n.content, t, e);
    o = t.nodes[r].create(n.props, i);
  } else
    throw new A(n.content.type);
  return o;
}
function D(n, t, e) {
  let o = n.id;
  o === void 0 && (o = Z.options.generateID());
  const r = Wt(
    n,
    t,
    e
  ), i = [];
  if (n.children)
    for (const a of n.children)
      i.push(D(a, t, e));
  const s = t.nodes.blockGroup.create({}, i);
  return t.nodes.blockContainer.create(
    {
      id: o,
      ...n.props
    },
    i.length > 0 ? [r, s] : r
  );
}
function rn(n, t, e) {
  const o = {
    type: "tableContent",
    rows: []
  };
  return n.content.forEach((r) => {
    const i = {
      cells: []
    };
    r.content.forEach((s) => {
      i.cells.push(
        vt(
          s.firstChild,
          t,
          e
        )
      );
    }), o.rows.push(i);
  }), o;
}
function vt(n, t, e) {
  const o = [];
  let r;
  return n.content.forEach((i) => {
    if (i.type.name === "hardBreak") {
      if (r)
        if (Q(r))
          r.text += `
`;
        else if (It(r))
          r.content[r.content.length - 1].text += `
`;
        else
          throw new Error("unexpected");
      else
        r = {
          type: "text",
          text: `
`,
          styles: {}
        };
      return;
    }
    if (i.type.name !== "link" && i.type.name !== "text" && t[i.type.name]) {
      r && (o.push(r), r = void 0), o.push(
        qt(i, t, e)
      );
      return;
    }
    const s = {};
    let a;
    for (const l of i.marks)
      if (l.type.name === "link")
        a = l;
      else {
        const c = e[l.type.name];
        if (!c)
          throw new Error(`style ${l.type.name} not found in styleSchema`);
        if (c.propSchema === "boolean")
          s[c.type] = !0;
        else if (c.propSchema === "string")
          s[c.type] = l.attrs.stringValue;
        else
          throw new A(c.propSchema);
      }
    r ? Q(r) ? a ? (o.push(r), r = {
      type: "link",
      href: a.attrs.href,
      content: [
        {
          type: "text",
          text: i.textContent,
          styles: s
        }
      ]
    }) : JSON.stringify(r.styles) === JSON.stringify(s) ? r.text += i.textContent : (o.push(r), r = {
      type: "text",
      text: i.textContent,
      styles: s
    }) : It(r) && (a ? r.href === a.attrs.href ? JSON.stringify(
      r.content[r.content.length - 1].styles
    ) === JSON.stringify(s) ? r.content[r.content.length - 1].text += i.textContent : r.content.push({
      type: "text",
      text: i.textContent,
      styles: s
    }) : (o.push(r), r = {
      type: "link",
      href: a.attrs.href,
      content: [
        {
          type: "text",
          text: i.textContent,
          styles: s
        }
      ]
    }) : (o.push(r), r = {
      type: "text",
      text: i.textContent,
      styles: s
    })) : a ? r = {
      type: "link",
      href: a.attrs.href,
      content: [
        {
          type: "text",
          text: i.textContent,
          styles: s
        }
      ]
    } : r = {
      type: "text",
      text: i.textContent,
      styles: s
    };
  }), r && o.push(r), o;
}
function qt(n, t, e) {
  if (n.type.name === "text" || n.type.name === "link")
    throw new Error("unexpected");
  const o = {}, r = t[n.type.name];
  for (const [a, l] of Object.entries(n.attrs)) {
    if (!r)
      throw Error("ic node is of an unrecognized type: " + n.type.name);
    const c = r.propSchema;
    a in c && (o[a] = l);
  }
  let i;
  return r.content === "styled" ? i = vt(
    n,
    t,
    e
  ) : i = void 0, {
    type: n.type.name,
    props: o,
    content: i
  };
}
function y(n, t, e, o, r) {
  if (n.type.name !== "blockContainer")
    throw Error(
      "Node must be of type blockContainer, but is of type" + n.type.name + "."
    );
  const i = r == null ? void 0 : r.get(n);
  if (i)
    return i;
  const s = $t(n);
  let a = s.id;
  a === null && (a = Z.options.generateID());
  const l = {};
  for (const [h, f] of Object.entries({
    ...n.attrs,
    ...s.contentNode.attrs
  })) {
    const k = t[s.contentType.name];
    if (!k)
      throw Error(
        "Block is of an unrecognized type: " + s.contentType.name
      );
    const S = k.propSchema;
    h in S && (l[h] = f);
  }
  const c = t[s.contentType.name], u = [];
  for (let h = 0; h < s.numChildBlocks; h++)
    u.push(
      y(
        n.lastChild.child(h),
        t,
        e,
        o,
        r
      )
    );
  let p;
  if (c.content === "inline")
    p = vt(
      s.contentNode,
      e,
      o
    );
  else if (c.content === "table")
    p = rn(
      s.contentNode,
      e,
      o
    );
  else if (c.content === "none")
    p = void 0;
  else
    throw new A(c.content);
  const m = {
    id: a,
    type: c.type,
    props: l,
    content: p,
    children: u
  };
  return r == null || r.set(n, m), m;
}
function sn(n) {
  return n.document || window.document;
}
const Kt = (n, t, e, o, r) => {
  if (!e.nodes[n.type.name])
    throw new Error("Serializer is missing a node type: " + n.type.name);
  const { dom: i, contentDOM: s } = bt.renderSpec(
    sn(t),
    e.nodes[n.type.name](n)
  );
  if (s) {
    if (n.isLeaf)
      throw new RangeError("Content hole not allowed in a leaf node spec");
    if (n.type.name === "blockContainer") {
      const a = n.childCount > 0 && n.firstChild.type.spec.group === "blockContent" ? n.firstChild : void 0, l = n.childCount > 0 && n.lastChild.type.spec.group === "blockGroup" ? n.lastChild : void 0;
      if (a !== void 0) {
        const c = o.blockImplementations[a.type.name].implementation, p = (r ? c.toExternalHTML : c.toInternalHTML)(
          y(
            n,
            o.schema.blockSchema,
            o.schema.inlineContentSchema,
            o.schema.styleSchema,
            o.blockCache
          ),
          o
        );
        if (p.contentDOM !== void 0) {
          if (n.isLeaf)
            throw new RangeError(
              "Content hole not allowed in a leaf node spec"
            );
          p.contentDOM.appendChild(
            e.serializeFragment(a.content, t)
          );
        }
        s.appendChild(p.dom);
      }
      l !== void 0 && e.serializeFragment(
        T.from(l),
        t,
        s
      );
    } else
      e.serializeFragment(n.content, t, s);
  }
  return i;
}, Jt = (n, t) => {
  const e = t.serializeFragment(n), o = document.createElement("div");
  return o.appendChild(e), o.innerHTML;
};
function an(n) {
  const t = /* @__PURE__ */ new Set([
    ...n.orderedListItemBlockTypes,
    ...n.unorderedListItemBlockTypes
  ]), e = (o) => {
    var s;
    if (o.children.length === 1 && ((s = o.children[0].properties) == null ? void 0 : s.dataNodeType) === "blockGroup") {
      const a = o.children[0];
      o.children.pop(), o.children.push(...a.children);
    }
    let r = o.children.length, i;
    for (let a = 0; a < r; a++) {
      const c = o.children[a].children[0], u = c.children[0], p = c.children.length === 2 ? c.children[1] : null, m = t.has(
        u.properties.dataContentType
      ), h = m ? n.orderedListItemBlockTypes.has(
        u.properties.dataContentType
      ) ? "ol" : "ul" : null;
      if (p !== null && e(p), i && i.tagName !== h) {
        o.children.splice(
          a - i.children.length,
          i.children.length,
          i
        );
        const f = i.children.length - 1;
        a -= f, r -= f, i = void 0;
      }
      if (m) {
        i || (i = Lt(
          document.createElement(h)
        ));
        const f = Lt(
          document.createElement("li")
        );
        f.children.push(u.children[0]), p !== null && f.children.push(...p.children), i.children.push(f);
      } else if (p !== null) {
        o.children.splice(a + 1, 0, ...p.children), o.children[a] = u.children[0];
        const f = p.children.length;
        a += f, r += f;
      } else
        o.children[a] = u.children[0];
    }
    i && o.children.splice(
      r - i.children.length,
      i.children.length,
      i
    );
  };
  return e;
}
const lt = (n, t) => {
  const e = bt.fromSchema(n);
  return e.serializeNodeInner = (o, r) => Kt(o, r, e, t, !0), e.exportProseMirrorFragment = (o) => kt().use(zt, { fragment: !0 }).use(an, {
    orderedListItemBlockTypes: /* @__PURE__ */ new Set(["numberedListItem"]),
    unorderedListItemBlockTypes: /* @__PURE__ */ new Set(["bulletListItem"])
  }).use(Vt).processSync(Jt(o, e)).value, e.exportBlocks = (o) => {
    const r = o.map(
      (s) => D(s, n, t.schema.styleSchema)
    ), i = n.nodes.blockGroup.create(null, r);
    return e.exportProseMirrorFragment(T.from(i));
  }, e;
}, Xt = (n, t) => {
  const e = bt.fromSchema(n);
  return e.serializeNodeInner = (o, r) => Kt(o, r, e, t, !1), e.serializeProseMirrorFragment = (o) => Jt(o, e), e.serializeBlocks = (o) => {
    const r = o.map(
      (s) => D(s, n, t.schema.styleSchema)
    ), i = n.nodes.blockGroup.create(null, r);
    return e.serializeProseMirrorFragment(T.from(i));
  }, e;
}, Hr = async (n) => {
  const t = new FormData();
  return t.append("file", n), (await (await fetch("https://tmpfiles.org/api/v1/upload", {
    method: "POST",
    body: t
  })).json()).data.url.replace(
    "tmpfiles.org/",
    "tmpfiles.org/dl/"
  );
}, ln = () => typeof navigator < "u" && (/Mac/.test(navigator.platform) || /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent));
function F(n) {
  return ln() ? n.replace("Mod", "⌘") : n.replace("Mod", "Ctrl");
}
function z(...n) {
  return n.filter((t) => t).join(" ");
}
const Dr = () => /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
function tt(n, t, e, o) {
  const r = document.createElement("div");
  r.className = z(
    "bn-block-content",
    e.class
  ), r.setAttribute("data-content-type", n);
  for (const [s, a] of Object.entries(e))
    s !== "class" && r.setAttribute(s, a);
  const i = document.createElement(t);
  i.className = z(
    "bn-inline-content",
    o.class
  );
  for (const [s, a] of Object.entries(
    o
  ))
    s !== "class" && i.setAttribute(s, a);
  return r.appendChild(i), {
    dom: r,
    contentDOM: i
  };
}
const At = (n, t) => {
  const e = D(
    n,
    t._tiptapEditor.schema,
    t.schema.styleSchema
  ).firstChild, o = t._tiptapEditor.schema.nodes[e.type.name].spec.toDOM;
  if (o === void 0)
    throw new Error(
      "This block has no default HTML serialization as its corresponding TipTap node doesn't implement `renderHTML`."
    );
  const r = o(e);
  if (typeof r != "object" || !("dom" in r))
    throw new Error(
      "Cannot use this block's default HTML serialization as its corresponding TipTap node's `renderHTML` function does not return an object with the `dom` property."
    );
  return r;
}, w = {
  backgroundColor: {
    default: "default"
  },
  textColor: {
    default: "default"
  },
  textAlignment: {
    default: "left",
    values: ["left", "center", "right", "justify"]
  }
}, Yt = ["backgroundColor", "textColor"];
function st(n) {
  return "data-" + n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function Qt(n) {
  const t = {};
  return Object.entries(n).filter(([e, o]) => !Yt.includes(e)).forEach(([e, o]) => {
    t[e] = {
      default: o.default,
      keepOnSplit: !0,
      // Props are displayed in kebab-case as HTML attributes. If a prop's
      // value is the same as its default, we don't display an HTML
      // attribute for it.
      parseHTML: (r) => {
        const i = r.getAttribute(st(e));
        if (i === null)
          return null;
        if (typeof o.default == "boolean")
          return i === "true" ? !0 : i === "false" ? !1 : null;
        if (typeof o.default == "number") {
          const s = parseFloat(i);
          return !Number.isNaN(s) && Number.isFinite(s) ? s : null;
        }
        return i;
      },
      renderHTML: (r) => r[e] !== o.default ? {
        [st(e)]: r[e]
      } : {}
    };
  }), t;
}
function cn(n, t, e, o) {
  if (typeof n == "boolean")
    throw new Error(
      "Cannot find node position as getPos is a boolean, not a function."
    );
  const r = n(), s = e.state.doc.resolve(r).node().attrs.id, a = t.getBlock(s);
  if (a.type !== o)
    throw new Error("Block type does not match");
  return a;
}
function pt(n, t, e, o, r) {
  const i = document.createElement("div");
  if (r !== void 0)
    for (const [s, a] of Object.entries(r))
      s !== "class" && i.setAttribute(s, a);
  i.className = z(
    "bn-block-content",
    (r == null ? void 0 : r.class) || ""
  ), i.setAttribute("data-content-type", t);
  for (const [s, a] of Object.entries(e))
    !Yt.includes(s) && a !== o[s].default && i.setAttribute(st(s), a);
  return i.appendChild(n.dom), n.contentDOM !== void 0 && (n.contentDOM.className = z(
    "bn-inline-content",
    n.contentDOM.className
  ), n.contentDOM.setAttribute("data-editable", "")), {
    ...n,
    dom: i
  };
}
function q(n) {
  return W.create(n);
}
function Zt(n, t) {
  return {
    config: n,
    implementation: t
  };
}
function et(n, t, e) {
  return Zt(
    {
      type: n.name,
      content: n.config.content === "inline*" ? "inline" : n.config.content === "tableRow+" ? "table" : "none",
      propSchema: t
    },
    {
      node: n,
      requiredExtensions: e,
      toInternalHTML: At,
      toExternalHTML: At
      // parse: () => undefined, // parse rules are in node already
    }
  );
}
function te(n) {
  return Object.fromEntries(
    Object.entries(n).map(([t, e]) => [t, e.config])
  );
}
function dn(n, t) {
  const e = [
    {
      tag: "[data-content-type=" + n.type + "]",
      contentElement: "[data-editable]"
    }
  ];
  return t && e.push({
    tag: "*",
    getAttrs(o) {
      if (typeof o == "string")
        return !1;
      const r = t == null ? void 0 : t(o);
      return r === void 0 ? !1 : r;
    }
  }), e;
}
function un(n, t) {
  const e = q({
    name: n.type,
    content: n.content === "inline" ? "inline*" : "",
    group: "blockContent",
    selectable: !0,
    addAttributes() {
      return Qt(n.propSchema);
    },
    parseHTML() {
      return dn(n, t.parse);
    },
    renderHTML() {
      const o = document.createElement("div");
      return o.setAttribute("data-tmp-placeholder", "true"), {
        dom: o
      };
    },
    addNodeView() {
      return ({ getPos: o }) => {
        var l;
        const r = this.options.editor, i = cn(
          o,
          r,
          this.editor,
          n.type
        ), s = ((l = this.options.domAttributes) == null ? void 0 : l.blockContent) || {}, a = t.render(i, r);
        return pt(
          a,
          i.type,
          i.props,
          n.propSchema,
          s
        );
      };
    }
  });
  if (e.name !== n.type)
    throw new Error(
      "Node name does not match block type. This is a bug in BlockNote."
    );
  return Zt(n, {
    node: e,
    toInternalHTML: (o, r) => {
      var a;
      const i = ((a = e.options.domAttributes) == null ? void 0 : a.blockContent) || {}, s = t.render(o, r);
      return pt(
        s,
        o.type,
        o.props,
        n.propSchema,
        i
      );
    },
    toExternalHTML: (o, r) => {
      var a, l;
      const i = ((a = e.options.domAttributes) == null ? void 0 : a.blockContent) || {};
      let s = (l = t.toExternalHTML) == null ? void 0 : l.call(
        t,
        o,
        r
      );
      return s === void 0 && (s = t.render(o, r)), pt(
        s,
        o.type,
        o.props,
        n.propSchema,
        i
      );
    }
  });
}
function pn(n, t, e, o) {
  return n.dom.setAttribute("data-inline-content-type", t), Object.entries(e).filter(([r, i]) => i !== o[r].default).map(([r, i]) => [st(r), i]).forEach(([r, i]) => n.dom.setAttribute(r, i)), n.contentDOM !== void 0 && n.contentDOM.setAttribute("data-editable", ""), n;
}
function hn(n) {
  return {
    Backspace: ({ editor: t }) => {
      const e = t.state.selection.$from;
      return t.state.selection.empty && e.node().type.name === n.type && e.parentOffset === 0;
    }
  };
}
function mn(n, t) {
  return {
    config: n,
    implementation: t
  };
}
function fn(n, t) {
  return mn(
    {
      type: n.name,
      propSchema: t,
      content: n.config.content === "inline*" ? "styled" : "none"
    },
    {
      node: n
    }
  );
}
function ee(n) {
  return Object.fromEntries(
    Object.entries(n).map(([t, e]) => [t, e.config])
  );
}
function gn(n) {
  return [
    {
      tag: `[data-inline-content-type="${n.type}"]`,
      contentElement: (t) => {
        const e = t;
        return e.matches("[data-editable]") ? e : e.querySelector("[data-editable]") || e;
      }
    }
  ];
}
function Or(n, t) {
  const e = W.create({
    name: n.type,
    inline: !0,
    group: "inline",
    selectable: n.content === "styled",
    atom: n.content === "none",
    content: n.content === "styled" ? "inline*" : "",
    addAttributes() {
      return Qt(n.propSchema);
    },
    addKeyboardShortcuts() {
      return hn(n);
    },
    parseHTML() {
      return gn(n);
    },
    renderHTML({ node: o }) {
      const r = this.options.editor, i = t.render(
        qt(
          o,
          r.schema.inlineContentSchema,
          r.schema.styleSchema
        )
        // TODO: fix cast
      );
      return pn(
        i,
        n.type,
        o.attrs,
        n.propSchema
      );
    }
  });
  return fn(
    e,
    n.propSchema
  );
}
function bn(n) {
  return n === "boolean" ? {} : {
    stringValue: {
      default: void 0,
      keepOnSplit: !0,
      parseHTML: (t) => t.getAttribute("data-value"),
      renderHTML: (t) => t.stringValue !== void 0 ? {
        "data-value": t.stringValue
      } : {}
    }
  };
}
function kn(n, t, e, o) {
  return n.dom.setAttribute("data-style-type", t), o === "string" && n.dom.setAttribute("data-value", e), n.contentDOM !== void 0 && n.contentDOM.setAttribute("data-editable", ""), n;
}
function ne(n, t) {
  return {
    config: n,
    implementation: t
  };
}
function _(n, t) {
  return ne(
    {
      type: n.name,
      propSchema: t
    },
    {
      mark: n
    }
  );
}
function oe(n) {
  return Object.fromEntries(
    Object.entries(n).map(([t, e]) => [t, e.config])
  );
}
function yn(n) {
  return [
    {
      tag: `[data-style-type="${n.type}"]`,
      contentElement: (t) => {
        const e = t;
        return e.matches("[data-editable]") ? e : e.querySelector("[data-editable]") || e;
      }
    }
  ];
}
function _r(n, t) {
  const e = yt.create({
    name: n.type,
    addAttributes() {
      return bn(n.propSchema);
    },
    parseHTML() {
      return yn(n);
    },
    renderHTML({ mark: o }) {
      let r;
      if (n.propSchema === "boolean")
        r = t.render();
      else if (n.propSchema === "string")
        r = t.render(o.attrs.stringValue);
      else
        throw new A(n.propSchema);
      return kn(
        r,
        n.type,
        o.attrs.stringValue,
        n.propSchema
      );
    }
  });
  return ne(n, {
    mark: e
  });
}
const wn = yt.create({
  name: "backgroundColor",
  addAttributes() {
    return {
      stringValue: {
        default: void 0,
        parseHTML: (n) => n.getAttribute("data-background-color"),
        renderHTML: (n) => ({
          "data-background-color": n.stringValue
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (n) => typeof n == "string" ? !1 : n.hasAttribute("data-background-color") ? {
          stringValue: n.getAttribute("data-background-color")
        } : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["span", n, 0];
  }
}), vn = _(
  wn,
  "string"
), En = yt.create({
  name: "textColor",
  addAttributes() {
    return {
      stringValue: {
        default: void 0,
        parseHTML: (n) => n.getAttribute("data-text-color"),
        renderHTML: (n) => ({
          "data-text-color": n.stringValue
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (n) => typeof n == "string" ? !1 : n.hasAttribute("data-text-color") ? { stringValue: n.getAttribute("data-text-color") } : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["span", n, 0];
  }
}), Sn = _(En, "string"), N = (n) => {
  const { contentType: t } = b(
    n.state.doc,
    n.state.selection.from
  );
  return t.spec.content;
}, Cn = {
  ...w,
  level: { default: 1, values: [1, 2, 3] }
}, xn = q({
  name: "heading",
  content: "inline*",
  group: "blockContent",
  addAttributes() {
    return {
      level: {
        default: 1,
        // instead of "level" attributes, use "data-level"
        parseHTML: (n) => {
          const t = n.getAttribute("data-level"), e = parseInt(t);
          if (isFinite(e))
            return e;
        },
        renderHTML: (n) => ({
          "data-level": n.level.toString()
        })
      }
    };
  },
  addInputRules() {
    return [
      ...[1, 2, 3].map((n) => new wt({
        find: new RegExp(`^(#{${n}})\\s$`),
        handler: ({ state: t, chain: e, range: o }) => {
          N(this.editor) === "inline*" && e().BNUpdateBlock(t.selection.from, {
            type: "heading",
            props: {
              level: n
            }
          }).deleteRange({ from: o.from, to: o.to });
        }
      }))
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-1": () => N(this.editor) !== "inline*" ? !0 : this.editor.commands.BNUpdateBlock(
        this.editor.state.selection.anchor,
        {
          type: "heading",
          props: {
            level: 1
          }
        }
      ),
      "Mod-Alt-2": () => N(this.editor) !== "inline*" ? !0 : this.editor.commands.BNUpdateBlock(
        this.editor.state.selection.anchor,
        {
          type: "heading",
          props: {
            level: 2
          }
        }
      ),
      "Mod-Alt-3": () => N(this.editor) !== "inline*" ? !0 : this.editor.commands.BNUpdateBlock(
        this.editor.state.selection.anchor,
        {
          type: "heading",
          props: {
            level: 3
          }
        }
      )
    };
  },
  parseHTML() {
    return [
      {
        tag: "div[data-content-type=" + this.name + "]",
        getAttrs: (n) => typeof n == "string" ? !1 : {
          level: n.getAttribute("data-level")
        }
      },
      {
        tag: "h1",
        attrs: { level: 1 },
        node: "heading"
      },
      {
        tag: "h2",
        attrs: { level: 2 },
        node: "heading"
      },
      {
        tag: "h3",
        attrs: { level: 3 },
        node: "heading"
      }
    ];
  },
  renderHTML({ node: n, HTMLAttributes: t }) {
    var e, o;
    return tt(
      this.name,
      `h${n.attrs.level}`,
      {
        ...((e = this.options.domAttributes) == null ? void 0 : e.blockContent) || {},
        ...t
      },
      ((o = this.options.domAttributes) == null ? void 0 : o.inlineContent) || {}
    );
  }
}), Tn = et(
  xn,
  Cn
), Mn = {
  textAlignment: w.textAlignment,
  backgroundColor: w.backgroundColor,
  // Image url.
  url: {
    default: ""
  },
  // Image caption.
  caption: {
    default: ""
  },
  // Image width in px.
  width: {
    default: 512
  }
}, Pt = (n) => {
  switch (n) {
    case "left":
      return "flex-start";
    case "center":
      return "center";
    case "right":
      return "flex-end";
    default:
      return "flex-start";
  }
}, Ht = 64, Bn = (n, t) => {
  const e = document.createElement("div");
  e.className = "bn-image-block-content-wrapper", e.style.alignItems = Pt(
    n.props.textAlignment
  );
  const o = document.createElement("div");
  o.className = "bn-add-image-button";
  const r = document.createElement("div");
  r.className = "bn-add-image-button-icon";
  const i = document.createElement("p");
  i.className = "bn-add-image-button-text", i.innerText = "Add Image";
  const s = document.createElement("div");
  s.className = "bn-image-and-caption-wrapper";
  const a = document.createElement("div");
  a.className = "bn-image-wrapper";
  const l = document.createElement("img");
  l.className = "bn-image", l.src = n.props.url, l.alt = "placeholder", l.contentEditable = "false", l.draggable = !1, l.style.width = `${Math.min(
    n.props.width,
    t.domElement.firstElementChild.clientWidth
  )}px`;
  const c = document.createElement("div");
  c.className = "bn-image-resize-handle", c.style.left = "4px";
  const u = document.createElement("div");
  u.className = "bn-image-resize-handle", u.style.right = "4px";
  const p = document.createElement("p");
  p.className = "bn-image-caption", p.innerText = n.props.caption, p.style.padding = n.props.caption ? "4px" : "";
  const m = () => {
    var dt;
    const g = ((dt = t.getSelection()) == null ? void 0 : dt.blocks) || [];
    [t.getTextCursorPosition().block, ...g].find(
      (nt) => nt.id === n.id
    ) !== void 0 ? (o.style.outline = "4px solid rgb(100, 160, 255)", s.style.outline = "4px solid rgb(100, 160, 255)") : (o.style.outline = "", s.style.outline = "");
  };
  t.onEditorContentChange(m), t.onEditorSelectionChange(m);
  let h;
  const f = (g) => {
    if (!h) {
      !t.isEditable && a.contains(c) && a.contains(u) && (a.removeChild(c), a.removeChild(u));
      return;
    }
    let L;
    Pt(n.props.textAlignment) === "center" ? h.handleUsed === "left" ? L = h.initialWidth + (h.initialClientX - g.clientX) * 2 : L = h.initialWidth + (g.clientX - h.initialClientX) * 2 : h.handleUsed === "left" ? L = h.initialWidth + h.initialClientX - g.clientX : L = h.initialWidth + g.clientX - h.initialClientX, L < Ht ? l.style.width = `${Ht}px` : L > t.domElement.firstElementChild.clientWidth ? l.style.width = `${t.domElement.firstElementChild.clientWidth}px` : l.style.width = `${L}px`;
  }, k = (g) => {
    (!g.target || !a.contains(g.target) || !t.isEditable) && a.contains(c) && a.contains(u) && (a.removeChild(c), a.removeChild(u)), h && (h = void 0, t.updateBlock(n, {
      type: "image",
      props: {
        // Removes "px" from the end of the width string and converts to float.
        width: parseFloat(l.style.width.slice(0, -2))
      }
    }));
  }, S = (g) => {
    g.preventDefault();
  }, B = () => {
    t._tiptapEditor.view.dispatch(
      t._tiptapEditor.state.tr.setMeta(t.imagePanel.plugin, {
        block: n
      })
    );
  }, E = () => {
    t.isEditable && (a.appendChild(c), a.appendChild(u));
  }, O = (g) => {
    g.relatedTarget === c || g.relatedTarget === u || h || t.isEditable && a.contains(c) && a.contains(u) && (a.removeChild(c), a.removeChild(u));
  }, V = (g) => {
    g.preventDefault(), a.appendChild(c), a.appendChild(u), h = {
      handleUsed: "left",
      initialWidth: n.props.width,
      initialClientX: g.clientX
    };
  }, J = (g) => {
    g.preventDefault(), a.appendChild(c), a.appendChild(u), h = {
      handleUsed: "right",
      initialWidth: n.props.width,
      initialClientX: g.clientX
    };
  };
  return o.appendChild(r), o.appendChild(i), s.appendChild(a), a.appendChild(l), s.appendChild(p), n.props.url === "" ? e.appendChild(o) : e.appendChild(s), window.addEventListener("mousemove", f), window.addEventListener("mouseup", k), o.addEventListener("mousedown", S), o.addEventListener("click", B), l.addEventListener("mouseenter", E), l.addEventListener("mouseleave", O), c.addEventListener(
    "mousedown",
    V
  ), u.addEventListener(
    "mousedown",
    J
  ), {
    dom: e,
    destroy: () => {
      window.removeEventListener("mousemove", f), window.removeEventListener("mouseup", k), o.removeEventListener(
        "mousedown",
        S
      ), o.removeEventListener("click", B), c.removeEventListener(
        "mousedown",
        V
      ), u.removeEventListener(
        "mousedown",
        J
      );
    }
  };
}, Ln = un(
  {
    type: "image",
    propSchema: Mn,
    content: "none"
  },
  {
    render: Bn,
    toExternalHTML: (n) => {
      if (n.props.url === "") {
        const o = document.createElement("p");
        return o.innerHTML = "Add Image", {
          dom: o
        };
      }
      const t = document.createElement("figure"), e = document.createElement("img");
      if (e.src = n.props.url, t.appendChild(e), n.props.caption !== "") {
        const o = document.createElement("figcaption");
        o.innerHTML = n.props.caption, t.appendChild(o);
      }
      return {
        dom: t
      };
    },
    parse: (n) => {
      if (n.tagName === "FIGURE") {
        const t = n.querySelector("img"), e = n.querySelector("figcaption");
        return {
          url: (t == null ? void 0 : t.getAttribute("src")) || "",
          caption: (e == null ? void 0 : e.textContent) || (t == null ? void 0 : t.getAttribute("alt")) || void 0
        };
      } else if (n.tagName === "IMG")
        return {
          url: n.getAttribute("src") || "",
          caption: n.getAttribute("alt") || void 0
        };
    }
  }
), Et = (n) => {
  const { node: t, contentType: e } = b(
    n.state.doc,
    n.state.selection.from
  ), o = n.state.selection.anchor === n.state.selection.head;
  return !(e.name === "bulletListItem" || e.name === "numberedListItem") || !o ? !1 : n.commands.first(({ state: r, chain: i, commands: s }) => [
    () => (
      // Changes list item block to a text block if the content is empty.
      s.command(() => t.textContent.length === 0 ? s.BNUpdateBlock(r.selection.from, {
        type: "paragraph",
        props: {}
      }) : !1)
    ),
    () => (
      // Splits the current block, moving content inside that's after the cursor to a new block of the same type
      // below.
      s.command(() => t.textContent.length > 0 ? (i().deleteSelection().BNSplitBlock(r.selection.from, !0).run(), !0) : !1)
    )
  ]);
}, In = {
  ...w
}, Nn = q({
  name: "bulletListItem",
  content: "inline*",
  group: "blockContent",
  addInputRules() {
    return [
      // Creates an unordered list when starting with "-", "+", or "*".
      new wt({
        find: new RegExp("^[-+*]\\s$"),
        handler: ({ state: n, chain: t, range: e }) => {
          N(this.editor) === "inline*" && t().BNUpdateBlock(n.selection.from, {
            type: "bulletListItem",
            props: {}
          }).deleteRange({ from: e.from, to: e.to });
        }
      })
    ];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => Et(this.editor),
      "Mod-Shift-8": () => N(this.editor) !== "inline*" ? !0 : this.editor.commands.BNUpdateBlock(
        this.editor.state.selection.anchor,
        {
          type: "bulletListItem",
          props: {}
        }
      )
    };
  },
  parseHTML() {
    return [
      // Case for regular HTML list structure.
      {
        tag: "div[data-content-type=" + this.name + "]"
        // TODO: remove if we can't come up with test case that needs this
      },
      {
        tag: "li",
        getAttrs: (n) => {
          if (typeof n == "string")
            return !1;
          const t = n.parentElement;
          return t === null ? !1 : t.tagName === "UL" || t.tagName === "DIV" && t.parentElement.tagName === "UL" ? {} : !1;
        },
        node: "bulletListItem"
      },
      // Case for BlockNote list structure.
      {
        tag: "p",
        getAttrs: (n) => {
          if (typeof n == "string")
            return !1;
          const t = n.parentElement;
          return t === null ? !1 : t.getAttribute("data-content-type") === "bulletListItem" ? {} : !1;
        },
        priority: 300,
        node: "bulletListItem"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    var t, e;
    return tt(
      this.name,
      // We use a <p> tag, because for <li> tags we'd need a <ul> element to put
      // them in to be semantically correct, which we can't have due to the
      // schema.
      "p",
      {
        ...((t = this.options.domAttributes) == null ? void 0 : t.blockContent) || {},
        ...n
      },
      ((e = this.options.domAttributes) == null ? void 0 : e.inlineContent) || {}
    );
  }
}), An = et(
  Nn,
  In
), Pn = new x("numbered-list-indexing"), Hn = () => new v({
  key: Pn,
  appendTransaction: (n, t, e) => {
    const o = e.tr;
    o.setMeta("numberedListIndexing", !0);
    let r = !1;
    return e.doc.descendants((i, s) => {
      if (i.type.name === "blockContainer" && i.firstChild.type.name === "numberedListItem") {
        let a = "1";
        const l = s === 1, c = b(o.doc, s + 1);
        if (c === void 0)
          return;
        if (!l) {
          const m = b(o.doc, s - 2);
          if (m === void 0)
            return;
          if (!(c.depth !== m.depth)) {
            const f = m.contentNode;
            if (m.contentType.name === "numberedListItem") {
              const B = f.attrs.index;
              a = (parseInt(B) + 1).toString();
            }
          }
        }
        c.contentNode.attrs.index !== a && (r = !0, o.setNodeMarkup(s + 1, void 0, {
          index: a
        }));
      }
    }), r ? o : null;
  }
}), Dn = {
  ...w
}, On = q({
  name: "numberedListItem",
  content: "inline*",
  group: "blockContent",
  addAttributes() {
    return {
      index: {
        default: null,
        parseHTML: (n) => n.getAttribute("data-index"),
        renderHTML: (n) => ({
          "data-index": n.index
        })
      }
    };
  },
  addInputRules() {
    return [
      // Creates an ordered list when starting with "1.".
      new wt({
        find: new RegExp("^1\\.\\s$"),
        handler: ({ state: n, chain: t, range: e }) => {
          N(this.editor) === "inline*" && t().BNUpdateBlock(n.selection.from, {
            type: "numberedListItem",
            props: {}
          }).deleteRange({ from: e.from, to: e.to });
        }
      })
    ];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => Et(this.editor),
      "Mod-Shift-7": () => N(this.editor) !== "inline*" ? !0 : this.editor.commands.BNUpdateBlock(
        this.editor.state.selection.anchor,
        {
          type: "numberedListItem",
          props: {}
        }
      )
    };
  },
  addProseMirrorPlugins() {
    return [Hn()];
  },
  parseHTML() {
    return [
      {
        tag: "div[data-content-type=" + this.name + "]"
        // TODO: remove if we can't come up with test case that needs this
      },
      // Case for regular HTML list structure.
      // (e.g.: when pasting from other apps)
      {
        tag: "li",
        getAttrs: (n) => {
          if (typeof n == "string")
            return !1;
          const t = n.parentElement;
          return t === null ? !1 : t.tagName === "OL" || t.tagName === "DIV" && t.parentElement.tagName === "OL" ? {} : !1;
        },
        node: "numberedListItem"
      },
      // Case for BlockNote list structure.
      // (e.g.: when pasting from blocknote)
      {
        tag: "p",
        getAttrs: (n) => {
          if (typeof n == "string")
            return !1;
          const t = n.parentElement;
          return t === null ? !1 : t.getAttribute("data-content-type") === "numberedListItem" ? {} : !1;
        },
        priority: 300,
        node: "numberedListItem"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    var t, e;
    return tt(
      this.name,
      // We use a <p> tag, because for <li> tags we'd need an <ol> element to
      // put them in to be semantically correct, which we can't have due to the
      // schema.
      "p",
      {
        ...((t = this.options.domAttributes) == null ? void 0 : t.blockContent) || {},
        ...n
      },
      ((e = this.options.domAttributes) == null ? void 0 : e.inlineContent) || {}
    );
  }
}), _n = et(
  On,
  Dn
), Un = {
  ...w
}, Rn = q({
  name: "paragraph",
  content: "inline*",
  group: "blockContent",
  addKeyboardShortcuts() {
    return {
      Enter: () => Et(this.editor),
      "Mod-Alt-0": () => N(this.editor) !== "inline*" ? !0 : this.editor.commands.BNUpdateBlock(
        this.editor.state.selection.anchor,
        {
          type: "paragraph",
          props: {}
        }
      )
    };
  },
  parseHTML() {
    return [
      { tag: "div[data-content-type=" + this.name + "]" },
      {
        tag: "p",
        priority: 200,
        node: "paragraph"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    var t, e;
    return tt(
      this.name,
      "p",
      {
        ...((t = this.options.domAttributes) == null ? void 0 : t.blockContent) || {},
        ...n
      },
      ((e = this.options.domAttributes) == null ? void 0 : e.inlineContent) || {}
    );
  }
}), zn = et(
  Rn,
  Un
), Vn = M.create({
  name: "BlockNoteTableExtension",
  addProseMirrorPlugins: () => [
    Re({
      cellMinWidth: 100
    }),
    ze()
  ],
  addKeyboardShortcuts() {
    return {
      // Makes enter create a new line within the cell.
      Enter: () => this.editor.state.selection.empty && this.editor.state.selection.$head.parent.type.name === "tableParagraph" ? (this.editor.commands.setHardBreak(), !0) : !1,
      // Ensures that backspace won't delete the table if the text cursor is at
      // the start of a cell and the selection is empty.
      Backspace: () => {
        const n = this.editor.state.selection, t = n.empty, e = n.$head.parentOffset === 0, o = n.$head.node().type.name === "tableParagraph";
        return t && e && o;
      }
    };
  },
  extendNodeSchema(n) {
    const t = {
      name: n.name,
      options: n.options,
      storage: n.storage
    };
    return {
      tableRole: ve(
        Ee(n, "tableRole", t)
      )
    };
  }
}), Fn = {
  ...w
}, $n = q({
  name: "table",
  content: "tableRow+",
  group: "blockContent",
  tableRole: "table",
  isolating: !0,
  parseHTML() {
    return [{ tag: "table" }];
  },
  renderHTML({ HTMLAttributes: n }) {
    var t, e;
    return tt(
      this.name,
      "table",
      {
        ...((t = this.options.domAttributes) == null ? void 0 : t.blockContent) || {},
        ...n
      },
      ((e = this.options.domAttributes) == null ? void 0 : e.inlineContent) || {}
    );
  }
}), Gn = W.create({
  name: "tableParagraph",
  group: "tableContent",
  content: "inline*",
  parseHTML() {
    return [{ tag: "p" }];
  },
  renderHTML({ HTMLAttributes: n }) {
    return [
      "p",
      Se(this.options.HTMLAttributes, n),
      0
    ];
  }
}), jn = et(
  $n,
  Fn,
  [
    Vn,
    Gn,
    _e.extend({
      content: "tableContent"
    }),
    Oe.extend({
      content: "tableContent"
    }),
    Ue
  ]
), re = {
  paragraph: zn,
  heading: Tn,
  bulletListItem: An,
  numberedListItem: _n,
  image: Ln,
  table: jn
}, Wn = te(re), ie = {
  bold: _(Ne, "boolean"),
  italic: _(Pe, "boolean"),
  underline: _(De, "boolean"),
  strike: _(He, "boolean"),
  code: _(Ae, "boolean"),
  textColor: Sn,
  backgroundColor: vn
}, Ur = oe(ie), se = {
  text: { config: "text", implementation: {} },
  link: { config: "link", implementation: {} }
}, Rr = ee(
  se
);
function I(n, t) {
  return n in t.schema.blockSchema && t.schema.blockSchema[n] === Wn[n];
}
function zr(n, t, e) {
  return t.type === n && t.type in e.schema.blockSchema && I(t.type, e);
}
function qn(n, t, e) {
  return t in e.schema.blockSchema && n in e.schema.blockSchema[t].propSchema && e.schema.blockSchema[t].propSchema[n] === w[n];
}
function Vr(n, t, e) {
  return qn(n, t.type, e);
}
function St(n, t) {
  let e, o;
  if (t.firstChild.descendants((r, i) => e ? !1 : r.type.name !== "blockContainer" || r.attrs.id !== n ? !0 : (e = r, o = i + 1, !1)), e === void 0 || o === void 0)
    throw Error("Could not find block in the editor with matching ID.");
  return {
    node: e,
    posBeforeNode: o
  };
}
function Kn(n, t, e = "before", o) {
  const r = o._tiptapEditor, i = typeof t == "string" ? t : t.id, s = [];
  for (const u of n)
    s.push(
      D(u, r.schema, o.schema.styleSchema)
    );
  const { node: a, posBeforeNode: l } = St(i, r.state.doc);
  if (e === "before" && r.view.dispatch(
    r.state.tr.insert(l, s)
  ), e === "after" && r.view.dispatch(
    r.state.tr.insert(l + a.nodeSize, s)
  ), e === "nested" && a.childCount < 2) {
    const u = r.state.schema.nodes.blockGroup.create(
      {},
      s
    );
    r.view.dispatch(
      r.state.tr.insert(
        l + a.firstChild.nodeSize + 1,
        u
      )
    );
  }
  const c = [];
  for (const u of s)
    c.push(
      y(
        u,
        o.schema.blockSchema,
        o.schema.inlineContentSchema,
        o.schema.styleSchema,
        o.blockCache
      )
    );
  return c;
}
function Jn(n, t, e) {
  const o = e._tiptapEditor, r = typeof n == "string" ? n : n.id, { posBeforeNode: i } = St(r, o.state.doc);
  o.commands.BNUpdateBlock(i + 1, t);
  const s = o.state.doc.resolve(i + 1).node();
  return y(
    s,
    e.schema.blockSchema,
    e.schema.inlineContentSchema,
    e.schema.styleSchema,
    e.blockCache
  );
}
function ae(n, t, e) {
  const o = t._tiptapEditor, r = o.state.tr, i = new Set(
    n.map(
      (l) => typeof l == "string" ? l : l.id
    )
  ), s = [];
  let a = 0;
  if (o.state.doc.descendants((l, c) => {
    if (i.size === 0)
      return !1;
    if (l.type.name !== "blockContainer" || !i.has(l.attrs.id))
      return !0;
    s.push(
      y(
        l,
        t.schema.blockSchema,
        t.schema.inlineContentSchema,
        t.schema.styleSchema,
        t.blockCache
      )
    ), i.delete(l.attrs.id), a = (e == null ? void 0 : e(l, c, r, a)) || a;
    const u = r.doc.nodeSize;
    r.delete(c - a - 1, c - a + l.nodeSize + 1);
    const p = r.doc.nodeSize;
    return a += u - p, !1;
  }), i.size > 0) {
    const l = [...i].join(`
`);
    throw Error(
      "Blocks with the following IDs could not be found in the editor: " + l
    );
  }
  return o.view.dispatch(r), s;
}
function Xn(n, t) {
  return ae(n, t);
}
function Yn(n, t, e) {
  const o = e._tiptapEditor, r = [];
  for (const l of t)
    r.push(
      D(l, o.schema, e.schema.styleSchema)
    );
  const i = typeof n[0] == "string" ? n[0] : n[0].id, s = ae(
    n,
    e,
    (l, c, u, p) => {
      if (l.attrs.id === i) {
        const m = u.doc.nodeSize;
        u.insert(c, r);
        const h = u.doc.nodeSize;
        return p + m - h;
      }
      return p;
    }
  ), a = [];
  for (const l of r)
    a.push(
      y(
        l,
        e.schema.blockSchema,
        e.schema.inlineContentSchema,
        e.schema.styleSchema,
        e.blockCache
      )
    );
  return { insertedBlocks: a, removedBlocks: s };
}
function Qn(n, t, e, o = { updateSelection: !0 }) {
  const r = e._tiptapEditor, i = r.state.tr;
  let { from: s, to: a } = typeof n == "number" ? { from: n, to: n } : { from: n.from, to: n.to }, l = !0, c = !0, u = "";
  if (t.forEach((p) => {
    p.check(), l && p.isText && p.marks.length === 0 ? u += p.text : l = !1, c = c ? p.isBlock : !1;
  }), s === a && c) {
    const { parent: p } = i.doc.resolve(s);
    p.isTextblock && !p.type.spec.code && !p.childCount && (s -= 1, a += 1);
  }
  return l ? i.insertText(u, s, a) : i.replaceWith(s, a, t), o.updateSelection && Ce(i, i.steps.length - 1, -1), r.view.dispatch(i), !0;
}
function Zn() {
  const n = (t) => {
    let e = t.children.length;
    for (let o = 0; o < e; o++) {
      const r = t.children[o];
      if (r.type === "element" && (n(r), r.tagName === "u"))
        if (r.children.length > 0) {
          t.children.splice(o, 1, ...r.children);
          const i = r.children.length - 1;
          e += i, o += i;
        } else
          t.children.splice(o, 1), e--, o--;
    }
  };
  return n;
}
function Ct(n) {
  return kt().use(zt, { fragment: !0 }).use(Zn).use(Ve).use(Ft).use(Fe).processSync(n).value;
}
function to(n, t, e) {
  const r = lt(t, e).exportBlocks(n);
  return Ct(r);
}
function eo(n) {
  return Array.prototype.indexOf.call(n.parentElement.childNodes, n);
}
function no(n) {
  return n.nodeType === 3 && !/\S/.test(n.nodeValue || "");
}
function oo(n) {
  n.querySelectorAll("li > ul, li > ol").forEach((t) => {
    const e = eo(t), o = t.parentElement, r = Array.from(o.childNodes).slice(
      e + 1
    );
    t.remove(), r.forEach((i) => {
      i.remove();
    }), o.insertAdjacentElement("afterend", t), r.reverse().forEach((i) => {
      if (no(i))
        return;
      const s = document.createElement("li");
      s.append(i), t.insertAdjacentElement("afterend", s);
    }), o.childNodes.length === 0 && o.remove();
  });
}
function ro(n) {
  n.querySelectorAll("li + ul, li + ol").forEach((t) => {
    var i, s;
    const e = t.previousElementSibling, o = document.createElement("div");
    e.insertAdjacentElement("afterend", o), o.append(e);
    const r = document.createElement("div");
    for (r.setAttribute("data-node-type", "blockGroup"), o.append(r); ((i = o.nextElementSibling) == null ? void 0 : i.nodeName) === "UL" || ((s = o.nextElementSibling) == null ? void 0 : s.nodeName) === "OL"; )
      r.append(o.nextElementSibling);
  });
}
let Dt = null;
function io() {
  return Dt || (Dt = document.implementation.createHTMLDocument("title"));
}
function le(n) {
  if (typeof n == "string") {
    const t = io().createElement("div");
    t.innerHTML = n, n = t;
  }
  return oo(n), ro(n), n;
}
async function ce(n, t, e, o, r) {
  const i = le(n), a = ge.fromSchema(r).parse(i, {
    topNode: r.nodes.blockGroup.create()
  }), l = [];
  for (let c = 0; c < a.childCount; c++)
    l.push(
      y(a.child(c), t, e, o)
    );
  return l;
}
function so(n, t) {
  const e = t.value ? t.value + `
` : "", o = {};
  t.lang && (o["data-language"] = t.lang);
  let r = {
    type: "element",
    tagName: "code",
    properties: o,
    children: [{ type: "text", value: e }]
  };
  return t.meta && (r.data = { meta: t.meta }), n.patch(t, r), r = n.applyData(t, r), r = {
    type: "element",
    tagName: "pre",
    properties: {},
    children: [r]
  }, n.patch(t, r), r;
}
function ao(n, t, e, o, r) {
  const i = kt().use($e).use(Ft).use(Ge, {
    handlers: {
      ...je,
      code: so
    }
  }).use(Vt).processSync(n);
  return ce(
    i.value,
    t,
    e,
    o,
    r
  );
}
class K {
  constructor() {
    // eslint-disable-next-line @typescript-eslint/ban-types
    d(this, "callbacks", {});
  }
  on(t, e) {
    return this.callbacks[t] || (this.callbacks[t] = []), this.callbacks[t].push(e), () => this.off(t, e);
  }
  emit(t, ...e) {
    const o = this.callbacks[t];
    o && o.forEach((r) => r.apply(this, e));
  }
  off(t, e) {
    const o = this.callbacks[t];
    o && (e ? this.callbacks[t] = o.filter((r) => r !== e) : delete this.callbacks[t]);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
class lo {
  constructor(t, e, o) {
    d(this, "state");
    d(this, "emitUpdate");
    d(this, "preventHide", !1);
    d(this, "preventShow", !1);
    d(this, "prevWasEditable", null);
    d(this, "shouldShow", ({ state: t }) => !t.selection.empty);
    d(this, "viewMousedownHandler", () => {
      this.preventShow = !0;
    });
    d(this, "viewMouseupHandler", () => {
      this.preventShow = !1, setTimeout(() => this.update(this.pmView));
    });
    // For dragging the whole editor.
    d(this, "dragHandler", () => {
      var t;
      (t = this.state) != null && t.show && (this.state.show = !1, this.emitUpdate());
    });
    d(this, "focusHandler", () => {
      setTimeout(() => this.update(this.pmView));
    });
    d(this, "blurHandler", (t) => {
      var o;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      const e = this.pmView.dom.parentElement;
      // An element is clicked.
      t && t.relatedTarget && // Element is inside the editor.
      (e === t.relatedTarget || e.contains(t.relatedTarget)) || (o = this.state) != null && o.show && (this.state.show = !1, this.emitUpdate());
    });
    d(this, "scrollHandler", () => {
      var t;
      (t = this.state) != null && t.show && (this.state.referencePos = this.getSelectionBoundingBox(), this.emitUpdate());
    });
    this.editor = t, this.pmView = e, this.emitUpdate = () => {
      if (!this.state)
        throw new Error(
          "Attempting to update uninitialized formatting toolbar"
        );
      o(this.state);
    }, e.dom.addEventListener("mousedown", this.viewMousedownHandler), e.dom.addEventListener("mouseup", this.viewMouseupHandler), e.dom.addEventListener("dragstart", this.dragHandler), e.dom.addEventListener("dragover", this.dragHandler), e.dom.addEventListener("focus", this.focusHandler), e.dom.addEventListener("blur", this.blurHandler), document.addEventListener("scroll", this.scrollHandler);
  }
  update(t, e) {
    var m, h;
    const { state: o, composing: r } = t, { doc: i, selection: s } = o, a = e && e.doc.eq(i) && e.selection.eq(s);
    if ((this.prevWasEditable === null || this.prevWasEditable === this.editor.isEditable) && (r || a))
      return;
    this.prevWasEditable = this.editor.isEditable;
    const { ranges: l } = s, c = Math.min(...l.map((f) => f.$from.pos)), u = Math.max(...l.map((f) => f.$to.pos)), p = (m = this.shouldShow) == null ? void 0 : m.call(this, {
      view: t,
      state: o,
      from: c,
      to: u
    });
    if (this.editor.isEditable && !this.preventShow && (p || this.preventHide)) {
      this.state = {
        show: !0,
        referencePos: this.getSelectionBoundingBox()
      }, this.emitUpdate();
      return;
    }
    if ((h = this.state) != null && h.show && !this.preventHide && (!p || this.preventShow || !this.editor.isEditable)) {
      this.state.show = !1, this.emitUpdate();
      return;
    }
  }
  destroy() {
    this.pmView.dom.removeEventListener("mousedown", this.viewMousedownHandler), this.pmView.dom.removeEventListener("mouseup", this.viewMouseupHandler), this.pmView.dom.removeEventListener("dragstart", this.dragHandler), this.pmView.dom.removeEventListener("dragover", this.dragHandler), this.pmView.dom.removeEventListener("focus", this.focusHandler), this.pmView.dom.removeEventListener("blur", this.blurHandler), document.removeEventListener("scroll", this.scrollHandler);
  }
  getSelectionBoundingBox() {
    const { state: t } = this.pmView, { selection: e } = t, { ranges: o } = e, r = Math.min(...o.map((s) => s.$from.pos)), i = Math.max(...o.map((s) => s.$to.pos));
    if (xe(e)) {
      const s = this.pmView.nodeDOM(r);
      if (s)
        return s.getBoundingClientRect();
    }
    return ft(this.pmView, r, i);
  }
}
const co = new x(
  "FormattingToolbarPlugin"
);
class uo extends K {
  constructor(e) {
    super();
    d(this, "view");
    d(this, "plugin");
    this.plugin = new v({
      key: co,
      view: (o) => (this.view = new lo(e, o, (r) => {
        this.emit("update", r);
      }), this.view)
    });
  }
  onUpdate(e) {
    return this.on("update", e);
  }
}
class po {
  constructor(t, e, o) {
    d(this, "state");
    d(this, "emitUpdate");
    d(this, "menuUpdateTimer");
    d(this, "startMenuUpdateTimer");
    d(this, "stopMenuUpdateTimer");
    d(this, "mouseHoveredLinkMark");
    d(this, "mouseHoveredLinkMarkRange");
    d(this, "keyboardHoveredLinkMark");
    d(this, "keyboardHoveredLinkMarkRange");
    d(this, "linkMark");
    d(this, "linkMarkRange");
    d(this, "mouseOverHandler", (t) => {
      if (this.mouseHoveredLinkMark = void 0, this.mouseHoveredLinkMarkRange = void 0, this.stopMenuUpdateTimer(), t.target instanceof HTMLAnchorElement && t.target.nodeName === "A") {
        const e = t.target, o = this.pmView.posAtDOM(e, 0) + 1, r = this.pmView.state.doc.resolve(o), i = r.marks();
        for (const s of i)
          if (s.type.name === this.pmView.state.schema.mark("link").type.name) {
            this.mouseHoveredLinkMark = s, this.mouseHoveredLinkMarkRange = Mt(r, s.type, s.attrs) || void 0;
            break;
          }
      }
      return this.startMenuUpdateTimer(), !1;
    });
    d(this, "clickHandler", (t) => {
      var o;
      const e = this.pmView.dom.parentElement;
      // Toolbar is open.
      this.linkMark && // An element is clicked.
      t && t.target && // The clicked element is not the editor.
      !(e === t.target || e.contains(t.target)) && (o = this.state) != null && o.show && (this.state.show = !1, this.emitUpdate());
    });
    d(this, "scrollHandler", () => {
      var t;
      this.linkMark !== void 0 && (t = this.state) != null && t.show && (this.state.referencePos = ft(
        this.pmView,
        this.linkMarkRange.from,
        this.linkMarkRange.to
      ), this.emitUpdate());
    });
    this.editor = t, this.pmView = e, this.emitUpdate = () => {
      if (!this.state)
        throw new Error("Attempting to update uninitialized link toolbar");
      o(this.state);
    }, this.startMenuUpdateTimer = () => {
      this.menuUpdateTimer = setTimeout(() => {
        this.update();
      }, 250);
    }, this.stopMenuUpdateTimer = () => (this.menuUpdateTimer && (clearTimeout(this.menuUpdateTimer), this.menuUpdateTimer = void 0), !1), this.pmView.dom.addEventListener("mouseover", this.mouseOverHandler), document.addEventListener("click", this.clickHandler, !0), document.addEventListener("scroll", this.scrollHandler);
  }
  editLink(t, e) {
    var r;
    const o = this.pmView.state.tr.insertText(
      e,
      this.linkMarkRange.from,
      this.linkMarkRange.to
    );
    o.addMark(
      this.linkMarkRange.from,
      this.linkMarkRange.from + e.length,
      this.pmView.state.schema.mark("link", { href: t })
    ), this.pmView.dispatch(o), this.pmView.focus(), (r = this.state) != null && r.show && (this.state.show = !1, this.emitUpdate());
  }
  deleteLink() {
    var t;
    this.pmView.dispatch(
      this.pmView.state.tr.removeMark(
        this.linkMarkRange.from,
        this.linkMarkRange.to,
        this.linkMark.type
      ).setMeta("preventAutolink", !0)
    ), this.pmView.focus(), (t = this.state) != null && t.show && (this.state.show = !1, this.emitUpdate());
  }
  update() {
    var e;
    if (!this.pmView.hasFocus())
      return;
    const t = this.linkMark;
    if (this.linkMark = void 0, this.linkMarkRange = void 0, this.keyboardHoveredLinkMark = void 0, this.keyboardHoveredLinkMarkRange = void 0, this.pmView.state.selection.empty) {
      const o = this.pmView.state.selection.$from.marks();
      for (const r of o)
        if (r.type.name === this.pmView.state.schema.mark("link").type.name) {
          this.keyboardHoveredLinkMark = r, this.keyboardHoveredLinkMarkRange = Mt(
            this.pmView.state.selection.$from,
            r.type,
            r.attrs
          ) || void 0;
          break;
        }
    }
    if (this.mouseHoveredLinkMark && (this.linkMark = this.mouseHoveredLinkMark, this.linkMarkRange = this.mouseHoveredLinkMarkRange), this.keyboardHoveredLinkMark && (this.linkMark = this.keyboardHoveredLinkMark, this.linkMarkRange = this.keyboardHoveredLinkMarkRange), this.linkMark && this.editor.isEditable) {
      this.state = {
        show: !0,
        referencePos: ft(
          this.pmView,
          this.linkMarkRange.from,
          this.linkMarkRange.to
        ),
        url: this.linkMark.attrs.href,
        text: this.pmView.state.doc.textBetween(
          this.linkMarkRange.from,
          this.linkMarkRange.to
        )
      }, this.emitUpdate();
      return;
    }
    if ((e = this.state) != null && e.show && t && (!this.linkMark || !this.editor.isEditable)) {
      this.state.show = !1, this.emitUpdate();
      return;
    }
  }
  destroy() {
    this.pmView.dom.removeEventListener("mouseover", this.mouseOverHandler), document.removeEventListener("scroll", this.scrollHandler), document.removeEventListener("click", this.clickHandler, !0);
  }
}
const ho = new x("LinkToolbarPlugin");
class mo extends K {
  constructor(e) {
    super();
    d(this, "view");
    d(this, "plugin");
    /**
     * Edit the currently hovered link.
     */
    d(this, "editLink", (e, o) => {
      this.view.editLink(e, o);
    });
    /**
     * Delete the currently hovered link.
     */
    d(this, "deleteLink", () => {
      this.view.deleteLink();
    });
    /**
     * When hovering on/off links using the mouse cursor, the link toolbar will
     * open & close with a delay.
     *
     * This function starts the delay timer, and should be used for when the mouse
     * cursor enters the link toolbar.
     */
    d(this, "startHideTimer", () => {
      this.view.startMenuUpdateTimer();
    });
    /**
     * When hovering on/off links using the mouse cursor, the link toolbar will
     * open & close with a delay.
     *
     * This function stops the delay timer, and should be used for when the mouse
     * cursor exits the link toolbar.
     */
    d(this, "stopHideTimer", () => {
      this.view.stopMenuUpdateTimer();
    });
    this.plugin = new v({
      key: ho,
      view: (o) => (this.view = new po(e, o, (r) => {
        this.emit("update", r);
      }), this.view)
    });
  }
  onUpdate(e) {
    return this.on("update", e);
  }
}
const fo = Te((n) => n.type.name === "blockContainer");
class go {
  constructor(t, e) {
    d(this, "state");
    d(this, "emitUpdate");
    d(this, "pluginState");
    d(this, "handleScroll", () => {
      var t;
      if ((t = this.state) != null && t.show) {
        const e = document.querySelector(
          `[data-decoration-id="${this.pluginState.decorationId}"]`
        );
        this.state.referencePos = e.getBoundingClientRect(), this.emitUpdate(this.pluginState.triggerCharacter);
      }
    });
    d(this, "closeMenu", () => {
      this.editor._tiptapEditor.view.dispatch(
        this.editor._tiptapEditor.view.state.tr.setMeta(
          R,
          null
        )
      );
    });
    d(this, "clearQuery", () => {
      this.pluginState !== void 0 && this.editor._tiptapEditor.chain().focus().deleteRange({
        from: this.pluginState.queryStartPos - (this.pluginState.fromUserInput ? this.pluginState.triggerCharacter.length : 0),
        to: this.editor._tiptapEditor.state.selection.from
      }).run();
    });
    this.editor = t, this.pluginState = void 0, this.emitUpdate = (o) => {
      if (!this.state)
        throw new Error("Attempting to update uninitialized suggestions menu");
      e(o, this.state);
    }, document.addEventListener("scroll", this.handleScroll);
  }
  update(t, e) {
    const o = R.getState(e), r = R.getState(
      t.state
    ), i = o === void 0 && r !== void 0, s = o !== void 0 && r === void 0;
    if (!i && !(o !== void 0 && r !== void 0) && !s)
      return;
    if (this.pluginState = s ? o : r, s || !this.editor.isEditable) {
      this.state.show = !1, this.emitUpdate(this.pluginState.triggerCharacter);
      return;
    }
    const l = document.querySelector(
      `[data-decoration-id="${this.pluginState.decorationId}"]`
    );
    this.editor.isEditable && (this.state = {
      show: !0,
      referencePos: l.getBoundingClientRect(),
      query: this.pluginState.query
    }, this.emitUpdate(this.pluginState.triggerCharacter));
  }
  destroy() {
    document.removeEventListener("scroll", this.handleScroll);
  }
}
const R = new x("SuggestionMenuPlugin");
class bo extends K {
  constructor(e) {
    super();
    d(this, "view");
    d(this, "plugin");
    d(this, "triggerCharacters", []);
    d(this, "addTriggerCharacter", (e) => {
      this.triggerCharacters.push(e);
    });
    // TODO: Should this be called automatically when listeners are removed?
    d(this, "removeTriggerCharacter", (e) => {
      this.triggerCharacters = this.triggerCharacters.filter(
        (o) => o !== e
      );
    });
    d(this, "closeMenu", () => this.view.closeMenu());
    d(this, "clearQuery", () => this.view.clearQuery());
    const o = this.triggerCharacters;
    this.plugin = new v({
      key: R,
      view: () => (this.view = new go(
        e,
        (r, i) => {
          this.emit(`update ${r}`, i);
        }
      ), this.view),
      state: {
        // Initialize the plugin's internal state.
        init() {
        },
        // Apply changes to the plugin state from an editor transaction.
        apply(r, i, s, a) {
          if (r.getMeta("orderedListIndexing") !== void 0)
            return i;
          const l = r.getMeta(R);
          if (typeof l == "object" && l !== null && i === void 0)
            return {
              triggerCharacter: l.triggerCharacter,
              fromUserInput: l.fromUserInput !== !1,
              queryStartPos: a.selection.from,
              query: "",
              decorationId: `id_${Math.floor(Math.random() * 4294967295)}`
            };
          if (i === void 0)
            return i;
          if (
            // Highlighting text should hide the menu.
            a.selection.from !== a.selection.to || // Transactions with plugin metadata should hide the menu.
            l === null || // Certain mouse events should hide the menu.
            // TODO: Change to global mousedown listener.
            r.getMeta("focus") || r.getMeta("blur") || r.getMeta("pointer") || // Moving the caret before the character which triggered the menu should hide it.
            i.triggerCharacter !== void 0 && a.selection.from < i.queryStartPos
          )
            return;
          const c = { ...i };
          return c.query = a.doc.textBetween(
            i.queryStartPos,
            a.selection.from
          ), c;
        }
      },
      props: {
        handleTextInput(r, i, s, a) {
          const l = this.getState(r.state);
          return o.includes(a) && l === void 0 ? (r.dispatch(
            r.state.tr.insertText(a).scrollIntoView().setMeta(R, {
              triggerCharacter: a
            })
          ), !0) : !1;
        },
        // Setup decorator on the currently active suggestion.
        decorations(r) {
          const i = this.getState(r);
          if (i === void 0)
            return null;
          if (!i.fromUserInput) {
            const s = fo(r.selection);
            if (s)
              return G.create(r.doc, [
                j.node(
                  s.pos,
                  s.pos + s.node.nodeSize,
                  {
                    nodeName: "span",
                    class: "bn-suggestion-decorator",
                    "data-decoration-id": i.decorationId
                  }
                )
              ]);
          }
          return G.create(r.doc, [
            j.inline(
              i.queryStartPos - i.triggerCharacter.length,
              i.queryStartPos,
              {
                nodeName: "span",
                class: "bn-suggestion-decorator",
                "data-decoration-id": i.decorationId
              }
            )
          ]);
        }
      }
    });
  }
  onUpdate(e, o) {
    return this.triggerCharacters.includes(e) || this.addTriggerCharacter(e), this.on(`update ${e}`, o);
  }
}
function Fr(n, t) {
  n.suggestionMenus.addTriggerCharacter(t);
}
class $ extends ut {
  constructor(e, o) {
    super(e, o);
    d(this, "nodes");
    const r = e.node();
    this.nodes = [], e.doc.nodesBetween(e.pos, o.pos, (i, s, a) => {
      if (a !== null && a.eq(r))
        return this.nodes.push(i), !1;
    });
  }
  static create(e, o, r = o) {
    return new $(e.resolve(o), e.resolve(r));
  }
  content() {
    return new U(T.from(this.nodes), 0, 0);
  }
  eq(e) {
    if (!(e instanceof $) || this.nodes.length !== e.nodes.length || this.from !== e.from || this.to !== e.to)
      return !1;
    for (let o = 0; o < this.nodes.length; o++)
      if (!this.nodes[o].eq(e.nodes[o]))
        return !1;
    return !0;
  }
  map(e, o) {
    const r = o.mapResult(this.from), i = o.mapResult(this.to);
    return i.deleted ? ut.near(e.resolve(r.pos)) : r.deleted ? ut.near(e.resolve(i.pos)) : new $(
      e.resolve(r.pos),
      e.resolve(i.pos)
    );
  }
  toJSON() {
    return { type: "node", anchor: this.anchor, head: this.head };
  }
}
let H;
function xt(n, t) {
  var r;
  if (!t.dom.isConnected)
    return;
  const e = t.posAtCoords(n);
  if (!e)
    return;
  let o = t.domAtPos(e.pos).node;
  if (o !== t.dom) {
    for (; o && o.parentNode && o.parentNode !== t.dom && !((r = o.hasAttribute) != null && r.call(o, "data-id")); )
      o = o.parentNode;
    if (o)
      return { node: o, id: o.getAttribute("data-id") };
  }
}
function ko(n, t) {
  const e = xt(n, t);
  if (e && e.node.nodeType === 1) {
    const o = t.docView, r = o.nearestDesc(e.node, !0);
    return !r || r === o ? null : r.posBefore;
  }
  return null;
}
function yo(n, t) {
  let e, o;
  const r = t.resolve(n.from).node().type.spec.group === "blockContent", i = t.resolve(n.to).node().type.spec.group === "blockContent", s = Math.min(n.$anchor.depth, n.$head.depth);
  if (r && i) {
    const a = n.$from.start(s - 1), l = n.$to.end(s - 1);
    e = t.resolve(a - 1).pos, o = t.resolve(l + 1).pos;
  } else
    e = n.from, o = n.to;
  return { from: e, to: o };
}
function Ot(n, t, e = t) {
  t === e && (e += n.state.doc.resolve(t + 1).node().nodeSize);
  const o = n.domAtPos(t).node.cloneNode(!0), r = n.domAtPos(t).node, i = (u, p) => Array.prototype.indexOf.call(u.children, p), s = i(
    r,
    // Expects from position to be just before the first selected block.
    n.domAtPos(t + 1).node.parentElement
  ), a = i(
    r,
    // Expects to position to be just after the last selected block.
    n.domAtPos(e - 1).node.parentElement
  );
  for (let u = r.childElementCount - 1; u >= 0; u--)
    (u > a || u < s) && o.removeChild(o.children[u]);
  de(), H = o;
  const c = n.dom.className.split(" ").filter(
    (u) => u !== "ProseMirror" && u !== "bn-root" && u !== "bn-editor"
  ).join(" ");
  H.className = H.className + " bn-drag-preview " + c, document.body.appendChild(H);
}
function de() {
  H !== void 0 && (document.body.removeChild(H), H = void 0);
}
function wo(n, t) {
  if (!n.dataTransfer)
    return;
  const e = t.prosemirrorView, o = e.dom.getBoundingClientRect(), r = {
    left: o.left + o.width / 2,
    // take middle of editor
    top: n.clientY
  }, i = ko(r, e);
  if (i != null) {
    const s = e.state.selection, a = e.state.doc, { from: l, to: c } = yo(s, a), u = l <= i && i < c, p = s.$anchor.node() !== s.$head.node() || s instanceof $;
    u && p ? (e.dispatch(
      e.state.tr.setSelection($.create(a, l, c))
    ), Ot(e, l, c)) : (e.dispatch(
      e.state.tr.setSelection(it.create(e.state.doc, i))
    ), Ot(e, i));
    const m = e.state.selection.content(), h = t._tiptapEditor.schema, k = Xt(h, t).serializeProseMirrorFragment(
      m.content
    ), B = lt(h, t).exportProseMirrorFragment(
      m.content
    ), E = Ct(B);
    n.dataTransfer.clearData(), n.dataTransfer.setData("blocknote/html", k), n.dataTransfer.setData("text/html", B), n.dataTransfer.setData("text/plain", E), n.dataTransfer.effectAllowed = "move", n.dataTransfer.setDragImage(H, 0, 0), e.dragging = { slice: m, move: !0 };
  }
}
class vo {
  constructor(t, e, o) {
    d(this, "state");
    d(this, "emitUpdate");
    // When true, the drag handle with be anchored at the same level as root elements
    // When false, the drag handle with be just to the left of the element
    // TODO: Is there any case where we want this to be false?
    d(this, "horizontalPosAnchoredAtRoot");
    d(this, "horizontalPosAnchor");
    d(this, "hoveredBlock");
    // Used to check if currently dragged content comes from this editor instance.
    d(this, "isDragging", !1);
    d(this, "menuFrozen", !1);
    /**
     * Sets isDragging when dragging text.
     */
    d(this, "onDragStart", () => {
      this.isDragging = !0;
    });
    /**
     * If the event is outside the editor contents,
     * we dispatch a fake event, so that we can still drop the content
     * when dragging / dropping to the side of the editor
     */
    d(this, "onDrop", (t) => {
      if (this.editor._tiptapEditor.commands.blur(), t.synthetic || !this.isDragging)
        return;
      const e = this.pmView.posAtCoords({
        left: t.clientX,
        top: t.clientY
      });
      if (this.isDragging = !1, !e || e.inside === -1) {
        const o = new Event("drop", t), r = this.pmView.dom.firstChild.getBoundingClientRect();
        o.clientX = r.left + r.width / 2, o.clientY = t.clientY, o.dataTransfer = t.dataTransfer, o.preventDefault = () => t.preventDefault(), o.synthetic = !0, this.pmView.dom.dispatchEvent(o);
      }
    });
    /**
     * If the event is outside the editor contents,
     * we dispatch a fake event, so that we can still drop the content
     * when dragging / dropping to the side of the editor
     */
    d(this, "onDragOver", (t) => {
      if (t.synthetic || !this.isDragging)
        return;
      const e = this.pmView.posAtCoords({
        left: t.clientX,
        top: t.clientY
      });
      if (!e || e.inside === -1) {
        const o = new Event("dragover", t), r = this.pmView.dom.firstChild.getBoundingClientRect();
        o.clientX = r.left + r.width / 2, o.clientY = t.clientY, o.dataTransfer = t.dataTransfer, o.preventDefault = () => t.preventDefault(), o.synthetic = !0, this.pmView.dom.dispatchEvent(o);
      }
    });
    d(this, "onKeyDown", (t) => {
      var e;
      (e = this.state) != null && e.show && (this.state.show = !1, this.emitUpdate(this.state)), this.menuFrozen = !1;
    });
    d(this, "onMouseDown", (t) => {
      this.state && !this.state.show && (this.state.show = !0, this.emitUpdate(this.state)), this.menuFrozen = !1;
    });
    d(this, "onMouseMove", (t) => {
      var c, u, p, m, h;
      if (this.menuFrozen)
        return;
      const e = this.pmView.dom.firstChild.getBoundingClientRect(), o = this.pmView.dom.getBoundingClientRect(), r = t.clientX >= o.left && t.clientX <= o.right && t.clientY >= o.top && t.clientY <= o.bottom, i = this.pmView.dom.parentElement;
      if (
        // Cursor is within the editor area
        r && // An element is hovered
        t && t.target && // Element is outside the editor
        !(i === t.target || i.contains(t.target))
      ) {
        (c = this.state) != null && c.show && (this.state.show = !1, this.emitUpdate(this.state));
        return;
      }
      this.horizontalPosAnchor = e.x;
      const s = {
        left: e.left + e.width / 2,
        // take middle of editor
        top: t.clientY
      }, a = xt(s, this.pmView);
      if (!a || !this.editor.isEditable) {
        (u = this.state) != null && u.show && (this.state.show = !1, this.emitUpdate(this.state));
        return;
      }
      if ((p = this.state) != null && p.show && ((m = this.hoveredBlock) != null && m.hasAttribute("data-id")) && ((h = this.hoveredBlock) == null ? void 0 : h.getAttribute("data-id")) === a.id)
        return;
      this.hoveredBlock = a.node;
      const l = a.node.firstChild;
      if (l && this.editor.isEditable) {
        const f = l.getBoundingClientRect();
        this.state = {
          show: !0,
          referencePos: new DOMRect(
            this.horizontalPosAnchoredAtRoot ? this.horizontalPosAnchor : f.x,
            f.y,
            f.width,
            f.height
          ),
          block: this.editor.getBlock(
            this.hoveredBlock.getAttribute("data-id")
          )
        }, this.emitUpdate(this.state);
      }
    });
    d(this, "onScroll", () => {
      var t;
      if ((t = this.state) != null && t.show) {
        const o = this.hoveredBlock.firstChild.getBoundingClientRect();
        this.state.referencePos = new DOMRect(
          this.horizontalPosAnchoredAtRoot ? this.horizontalPosAnchor : o.x,
          o.y,
          o.width,
          o.height
        ), this.emitUpdate(this.state);
      }
    });
    this.editor = t, this.pmView = e, this.emitUpdate = () => {
      if (!this.state)
        throw new Error("Attempting to update uninitialized side menu");
      o(this.state);
    }, this.horizontalPosAnchoredAtRoot = !0, this.horizontalPosAnchor = this.pmView.dom.firstChild.getBoundingClientRect().x, document.body.addEventListener("drop", this.onDrop, !0), document.body.addEventListener("dragover", this.onDragOver), this.pmView.dom.addEventListener("dragstart", this.onDragStart), document.body.addEventListener("mousemove", this.onMouseMove, !0), document.addEventListener("scroll", this.onScroll), document.body.addEventListener("mousedown", this.onMouseDown, !0), document.body.addEventListener("keydown", this.onKeyDown, !0);
  }
  destroy() {
    var t;
    (t = this.state) != null && t.show && (this.state.show = !1, this.emitUpdate(this.state)), document.body.removeEventListener("mousemove", this.onMouseMove, !0), document.body.removeEventListener("dragover", this.onDragOver), this.pmView.dom.removeEventListener("dragstart", this.onDragStart), document.body.removeEventListener("drop", this.onDrop, !0), document.removeEventListener("scroll", this.onScroll), document.body.removeEventListener("mousedown", this.onMouseDown, !0), document.body.removeEventListener("keydown", this.onKeyDown, !0);
  }
  addBlock() {
    var l;
    (l = this.state) != null && l.show && (this.state.show = !1, this.emitUpdate(this.state)), this.menuFrozen = !0;
    const e = this.hoveredBlock.firstChild.getBoundingClientRect(), o = this.pmView.posAtCoords({
      left: e.left + e.width / 2,
      top: e.top + e.height / 2
    });
    if (!o)
      return;
    const r = b(
      this.editor._tiptapEditor.state.doc,
      o.pos
    );
    if (r === void 0)
      return;
    const { contentNode: i, startPos: s, endPos: a } = r;
    if (i.type.spec.content !== "inline*" || i.textContent.length !== 0) {
      const c = a + 1, u = c + 2;
      this.editor._tiptapEditor.chain().BNCreateBlock(c).setTextSelection(u).run();
    } else
      this.editor._tiptapEditor.commands.setTextSelection(s + 1);
    this.pmView.focus(), this.pmView.dispatch(
      this.pmView.state.tr.scrollIntoView().setMeta(R, {
        triggerCharacter: "/",
        fromUserInput: !1
      })
    );
  }
}
const Eo = new x("SideMenuPlugin");
class So extends K {
  constructor(e) {
    super();
    d(this, "view");
    d(this, "plugin");
    /**
     * If the block is empty, opens the slash menu. If the block has content,
     * creates a new block below and opens the slash menu in it.
     */
    d(this, "addBlock", () => this.view.addBlock());
    /**
     * Handles drag & drop events for blocks.
     */
    d(this, "blockDragStart", (e) => {
      this.view.isDragging = !0, wo(e, this.editor);
    });
    /**
     * Handles drag & drop events for blocks.
     */
    d(this, "blockDragEnd", () => de());
    /**
     * Freezes the side menu. When frozen, the side menu will stay
     * attached to the same block regardless of which block is hovered by the
     * mouse cursor.
     */
    d(this, "freezeMenu", () => this.view.menuFrozen = !0);
    /**
     * Unfreezes the side menu. When frozen, the side menu will stay
     * attached to the same block regardless of which block is hovered by the
     * mouse cursor.
     */
    d(this, "unfreezeMenu", () => this.view.menuFrozen = !1);
    this.editor = e, this.plugin = new v({
      key: Eo,
      view: (o) => (this.view = new vo(e, o, (r) => {
        this.emit("update", r);
      }), this.view)
    });
  }
  onUpdate(e) {
    return this.on("update", e);
  }
}
class Co {
  constructor(t, e, o) {
    d(this, "state");
    d(this, "emitUpdate");
    d(this, "prevWasEditable", null);
    d(this, "mouseDownHandler", () => {
      var t;
      (t = this.state) != null && t.show && (this.state.show = !1, this.emitUpdate());
    });
    // For dragging the whole editor.
    d(this, "dragstartHandler", () => {
      var t;
      (t = this.state) != null && t.show && (this.state.show = !1, this.emitUpdate());
    });
    d(this, "blurHandler", (t) => {
      var o;
      const e = this.pmView.dom.parentElement;
      // An element is clicked.
      t && t.relatedTarget && // Element is inside the editor.
      (e === t.relatedTarget || e.contains(t.relatedTarget)) || (o = this.state) != null && o.show && (this.state.show = !1, this.emitUpdate());
    });
    d(this, "scrollHandler", () => {
      var t;
      if ((t = this.state) != null && t.show) {
        const e = document.querySelector(
          `[data-node-type="blockContainer"][data-id="${this.state.block.id}"]`
        );
        this.state.referencePos = e.getBoundingClientRect(), this.emitUpdate();
      }
    });
    this.pluginKey = t, this.pmView = e, this.emitUpdate = () => {
      if (!this.state)
        throw new Error("Attempting to update uninitialized image panel");
      o(this.state);
    }, e.dom.addEventListener("mousedown", this.mouseDownHandler), e.dom.addEventListener("dragstart", this.dragstartHandler), e.dom.addEventListener("blur", this.blurHandler), document.addEventListener("scroll", this.scrollHandler);
  }
  update(t, e) {
    var r, i;
    const o = this.pluginKey.getState(t.state);
    if (!((r = this.state) != null && r.show) && o.block) {
      const s = document.querySelector(
        `[data-node-type="blockContainer"][data-id="${o.block.id}"]`
      );
      this.state = {
        show: !0,
        referencePos: s.getBoundingClientRect(),
        block: o.block
      }, this.emitUpdate();
      return;
    }
    (!t.state.selection.eq(e.selection) || !t.state.doc.eq(e.doc)) && (i = this.state) != null && i.show && (this.state.show = !1, this.emitUpdate());
  }
  destroy() {
    this.pmView.dom.removeEventListener("mousedown", this.mouseDownHandler), this.pmView.dom.removeEventListener("dragstart", this.dragstartHandler), this.pmView.dom.removeEventListener("blur", this.blurHandler), document.removeEventListener("scroll", this.scrollHandler);
  }
}
const ht = new x("ImagePanelPlugin");
class xo extends K {
  constructor(e) {
    super();
    d(this, "view");
    d(this, "plugin");
    this.plugin = new v({
      key: ht,
      view: (o) => (this.view = new Co(
        // editor,
        ht,
        o,
        (r) => {
          this.emit("update", r);
        }
      ), this.view),
      state: {
        init: () => ({
          block: void 0
        }),
        apply: (o) => {
          var i;
          return {
            block: (i = o.getMeta(ht)) == null ? void 0 : i.block
          };
        }
      }
    });
  }
  onUpdate(e) {
    return this.on("update", e);
  }
}
let C;
function _t() {
  C || (C = document.createElement("div"), C.innerHTML = "_", C.style.opacity = "0", C.style.height = "1px", C.style.width = "1px", document.body.appendChild(C));
}
function To() {
  C && (document.body.removeChild(C), C = void 0);
}
function rt(n) {
  return Array.prototype.indexOf.call(n.parentElement.childNodes, n);
}
function Mo(n) {
  for (; n && n.nodeName !== "TD" && n.nodeName !== "TH"; )
    n = n.classList && n.classList.contains("ProseMirror") ? null : n.parentNode;
  return n;
}
function Bo(n) {
  n.forEach((t) => {
    const e = document.getElementsByClassName(t);
    for (let o = 0; o < e.length; o++)
      e[o].style.visibility = "hidden";
  });
}
class Lo {
  constructor(t, e, o) {
    d(this, "state");
    d(this, "emitUpdate");
    d(this, "tableId");
    d(this, "tablePos");
    d(this, "menuFrozen", !1);
    d(this, "prevWasEditable", null);
    d(this, "mouseMoveHandler", (t) => {
      var c;
      if (this.menuFrozen)
        return;
      const e = Mo(t.target);
      if (!e || !this.editor.isEditable) {
        (c = this.state) != null && c.show && (this.state.show = !1, this.emitUpdate());
        return;
      }
      const o = rt(e), r = rt(e.parentElement), i = e.getBoundingClientRect(), s = e.parentElement.parentElement.getBoundingClientRect(), a = xt(i, this.pmView);
      if (!a)
        throw new Error(
          "Found table cell element, but could not find surrounding blockContent element."
        );
      if (this.tableId = a.id, this.state !== void 0 && this.state.show && this.tableId === a.id && this.state.rowIndex === r && this.state.colIndex === o)
        return;
      let l;
      return this.editor._tiptapEditor.state.doc.descendants((u, p) => typeof l < "u" ? !1 : u.type.name !== "blockContainer" || u.attrs.id !== a.id ? !0 : (l = y(
        u,
        this.editor.schema.blockSchema,
        this.editor.schema.inlineContentSchema,
        this.editor.schema.styleSchema,
        this.editor.blockCache
      ), this.tablePos = p + 1, !1)), this.state = {
        show: !0,
        referencePosCell: i,
        referencePosTable: s,
        block: l,
        colIndex: o,
        rowIndex: r,
        draggingState: void 0
      }, this.emitUpdate(), !1;
    });
    d(this, "dragOverHandler", (t) => {
      var m;
      if (((m = this.state) == null ? void 0 : m.draggingState) === void 0)
        return;
      t.preventDefault(), t.dataTransfer.dropEffect = "move", Bo([
        "column-resize-handle",
        "prosemirror-dropcursor-block",
        "prosemirror-dropcursor-inline"
      ]);
      const e = {
        left: Math.min(
          Math.max(t.clientX, this.state.referencePosTable.left + 1),
          this.state.referencePosTable.right - 1
        ),
        top: Math.min(
          Math.max(t.clientY, this.state.referencePosTable.top + 1),
          this.state.referencePosTable.bottom - 1
        )
      }, o = document.elementsFromPoint(e.left, e.top).filter(
        (h) => h.tagName === "TD" || h.tagName === "TH"
      );
      if (o.length === 0)
        throw new Error(
          "Could not find table cell element that the mouse cursor is hovering over."
        );
      const r = o[0];
      let i = !1;
      const s = rt(r.parentElement), a = rt(r), l = this.state.draggingState.draggedCellOrientation === "row" ? this.state.rowIndex : this.state.colIndex, u = (this.state.draggingState.draggedCellOrientation === "row" ? s : a) !== l;
      (this.state.rowIndex !== s || this.state.colIndex !== a) && (this.state.rowIndex = s, this.state.colIndex = a, this.state.referencePosCell = r.getBoundingClientRect(), i = !0);
      const p = this.state.draggingState.draggedCellOrientation === "row" ? e.top : e.left;
      this.state.draggingState.mousePos !== p && (this.state.draggingState.mousePos = p, i = !0), i && this.emitUpdate(), u && this.pmView.dispatch(
        this.pmView.state.tr.setMeta(Y, !0)
      );
    });
    d(this, "dropHandler", (t) => {
      if (this.state === void 0 || this.state.draggingState === void 0)
        return;
      t.preventDefault();
      const e = this.state.block.content.rows;
      if (this.state.draggingState.draggedCellOrientation === "row") {
        const o = e[this.state.draggingState.originalIndex];
        e.splice(this.state.draggingState.originalIndex, 1), e.splice(this.state.rowIndex, 0, o);
      } else {
        const o = e.map(
          (r) => r.cells[this.state.draggingState.originalIndex]
        );
        e.forEach((r, i) => {
          r.cells.splice(this.state.draggingState.originalIndex, 1), r.cells.splice(this.state.colIndex, 0, o[i]);
        });
      }
      this.editor.updateBlock(this.state.block, {
        type: "table",
        content: {
          type: "tableContent",
          rows: e
        }
      });
    });
    d(this, "scrollHandler", () => {
      var t;
      if ((t = this.state) != null && t.show) {
        const e = document.querySelector(
          `[data-node-type="blockContainer"][data-id="${this.tableId}"] table`
        ), o = e.querySelector(
          `tr:nth-child(${this.state.rowIndex + 1}) > td:nth-child(${this.state.colIndex + 1})`
        );
        this.state.referencePosTable = e.getBoundingClientRect(), this.state.referencePosCell = o.getBoundingClientRect(), this.emitUpdate();
      }
    });
    this.editor = t, this.pmView = e, this.emitUpdate = () => {
      if (!this.state)
        throw new Error("Attempting to update uninitialized image toolbar");
      o(this.state);
    }, e.dom.addEventListener("mousemove", this.mouseMoveHandler), document.addEventListener("dragover", this.dragOverHandler), document.addEventListener("drop", this.dropHandler), document.addEventListener("scroll", this.scrollHandler);
  }
  destroy() {
    this.pmView.dom.removeEventListener("mousedown", this.mouseMoveHandler), document.removeEventListener("dragover", this.dragOverHandler), document.removeEventListener("drop", this.dropHandler), document.removeEventListener("scroll", this.scrollHandler);
  }
}
const Y = new x("TableHandlesPlugin");
class Io extends K {
  constructor(e) {
    super();
    d(this, "view");
    d(this, "plugin");
    /**
     * Callback that should be set on the `dragStart` event for whichever element
     * is used as the column drag handle.
     */
    d(this, "colDragStart", (e) => {
      if (this.view.state === void 0)
        throw new Error(
          "Attempted to drag table column, but no table block was hovered prior."
        );
      this.view.state.draggingState = {
        draggedCellOrientation: "col",
        originalIndex: this.view.state.colIndex,
        mousePos: e.clientX
      }, this.view.emitUpdate(), this.editor._tiptapEditor.view.dispatch(
        this.editor._tiptapEditor.state.tr.setMeta(Y, {
          draggedCellOrientation: this.view.state.draggingState.draggedCellOrientation,
          originalIndex: this.view.state.colIndex,
          newIndex: this.view.state.colIndex,
          tablePos: this.view.tablePos
        })
      ), _t(), e.dataTransfer.setDragImage(C, 0, 0), e.dataTransfer.effectAllowed = "move";
    });
    /**
     * Callback that should be set on the `dragStart` event for whichever element
     * is used as the row drag handle.
     */
    d(this, "rowDragStart", (e) => {
      if (this.view.state === void 0)
        throw new Error(
          "Attempted to drag table row, but no table block was hovered prior."
        );
      this.view.state.draggingState = {
        draggedCellOrientation: "row",
        originalIndex: this.view.state.rowIndex,
        mousePos: e.clientY
      }, this.view.emitUpdate(), this.editor._tiptapEditor.view.dispatch(
        this.editor._tiptapEditor.state.tr.setMeta(Y, {
          draggedCellOrientation: this.view.state.draggingState.draggedCellOrientation,
          originalIndex: this.view.state.rowIndex,
          newIndex: this.view.state.rowIndex,
          tablePos: this.view.tablePos
        })
      ), _t(), e.dataTransfer.setDragImage(C, 0, 0), e.dataTransfer.effectAllowed = "copyMove";
    });
    /**
     * Callback that should be set on the `dragEnd` event for both the element
     * used as the row drag handle, and the one used as the column drag handle.
     */
    d(this, "dragEnd", () => {
      if (this.view.state === void 0)
        throw new Error(
          "Attempted to drag table row, but no table block was hovered prior."
        );
      this.view.state.draggingState = void 0, this.view.emitUpdate(), this.editor._tiptapEditor.view.dispatch(
        this.editor._tiptapEditor.state.tr.setMeta(Y, null)
      ), To();
    });
    /**
     * Freezes the drag handles. When frozen, they will stay attached to the same
     * cell regardless of which cell is hovered by the mouse cursor.
     */
    d(this, "freezeHandles", () => {
      this.view.menuFrozen = !0;
    });
    /**
     * Unfreezes the drag handles. When frozen, they will stay attached to the
     * same cell regardless of which cell is hovered by the mouse cursor.
     */
    d(this, "unfreezeHandles", () => {
      this.view.menuFrozen = !1;
    });
    this.editor = e, this.plugin = new v({
      key: Y,
      view: (o) => (this.view = new Lo(e, o, (r) => {
        this.emit("update", r);
      }), this.view),
      // We use decorations to render the drop cursor when dragging a table row
      // or column. The decorations are updated in the `dragOverHandler` method.
      props: {
        decorations: (o) => {
          if (this.view === void 0 || this.view.state === void 0 || this.view.state.draggingState === void 0 || this.view.tablePos === void 0)
            return;
          const r = this.view.state.draggingState.draggedCellOrientation === "row" ? this.view.state.rowIndex : this.view.state.colIndex, i = [];
          if (r === this.view.state.draggingState.originalIndex)
            return G.create(o.doc, i);
          const s = o.doc.resolve(this.view.tablePos + 1), a = s.node();
          if (this.view.state.draggingState.draggedCellOrientation === "row") {
            const l = o.doc.resolve(
              s.posAtIndex(r) + 1
            ), c = l.node();
            for (let u = 0; u < c.childCount; u++) {
              const p = o.doc.resolve(
                l.posAtIndex(u) + 1
              ), m = p.node(), h = p.pos + (r > this.view.state.draggingState.originalIndex ? m.nodeSize - 2 : 0);
              i.push(
                // The widget is a small bar which spans the width of the cell.
                j.widget(h, () => {
                  const f = document.createElement("div");
                  return f.className = "bn-table-drop-cursor", f.style.left = "0", f.style.right = "0", r > this.view.state.draggingState.originalIndex ? f.style.bottom = "-2px" : f.style.top = "-3px", f.style.height = "4px", f;
                })
              );
            }
          } else
            for (let l = 0; l < a.childCount; l++) {
              const c = o.doc.resolve(
                s.posAtIndex(l) + 1
              ), u = o.doc.resolve(
                c.posAtIndex(r) + 1
              ), p = u.node(), m = u.pos + (r > this.view.state.draggingState.originalIndex ? p.nodeSize - 2 : 0);
              i.push(
                // The widget is a small bar which spans the height of the cell.
                j.widget(m, () => {
                  const h = document.createElement("div");
                  return h.className = "bn-table-drop-cursor", h.style.top = "0", h.style.bottom = "0", r > this.view.state.draggingState.originalIndex ? h.style.right = "-2px" : h.style.left = "-3px", h.style.width = "4px", h;
                })
              );
            }
          return G.create(o.doc, i);
        }
      }
    });
  }
  onUpdate(e) {
    return this.on("update", e);
  }
}
function Ut(n, t) {
  const e = n.state.selection.content().content, r = Xt(
    n.state.schema,
    t
  ).serializeProseMirrorFragment(e), s = lt(
    n.state.schema,
    t
  ).exportProseMirrorFragment(e), a = Ct(s);
  return { internalHTML: r, externalHTML: s, plainText: a };
}
const No = (n) => M.create({
  name: "copyToClipboard",
  addProseMirrorPlugins() {
    return [
      new v({
        props: {
          handleDOMEvents: {
            copy(t, e) {
              e.preventDefault(), e.clipboardData.clearData(), "node" in t.state.selection && t.state.selection.node.type.spec.group === "blockContent" && t.dispatch(
                t.state.tr.setSelection(
                  new it(
                    t.state.doc.resolve(t.state.selection.from - 1)
                  )
                )
              );
              const { internalHTML: o, externalHTML: r, plainText: i } = Ut(t, n);
              return e.clipboardData.setData("blocknote/html", o), e.clipboardData.setData("text/html", r), e.clipboardData.setData("text/plain", i), !0;
            },
            // This is for the use-case in which only a block without content
            // is selected, e.g. an image block, and dragged (not using the
            // drag handle).
            dragstart(t, e) {
              if (!("node" in t.state.selection) || t.state.selection.node.type.spec.group !== "blockContent")
                return;
              t.dispatch(
                t.state.tr.setSelection(
                  new it(
                    t.state.doc.resolve(t.state.selection.from - 1)
                  )
                )
              ), e.preventDefault(), e.dataTransfer.clearData();
              const { internalHTML: o, externalHTML: r, plainText: i } = Ut(t, n);
              return e.dataTransfer.setData("blocknote/html", o), e.dataTransfer.setData("text/html", r), e.dataTransfer.setData("text/plain", i), !0;
            }
          }
        }
      })
    ];
  }
}), Ao = [
  "blocknote/html",
  "text/html",
  "text/plain"
], Po = (n) => M.create({
  name: "pasteFromClipboard",
  addProseMirrorPlugins() {
    return [
      new v({
        props: {
          handleDOMEvents: {
            paste(t, e) {
              e.preventDefault();
              let o = null;
              for (const r of Ao)
                if (e.clipboardData.types.includes(r)) {
                  o = r;
                  break;
                }
              if (o !== null) {
                let r = e.clipboardData.getData(o);
                o === "text/html" && (r = le(
                  r.trim()
                ).innerHTML), n._tiptapEditor.view.pasteHTML(r);
              }
              return !0;
            }
          }
        }
      })
    ];
  }
}), Ho = M.create({
  name: "blockBackgroundColor",
  addGlobalAttributes() {
    return [
      {
        types: ["blockContainer"],
        attributes: {
          backgroundColor: {
            default: w.backgroundColor.default,
            parseHTML: (n) => n.hasAttribute("data-background-color") ? n.getAttribute("data-background-color") : w.backgroundColor.default,
            renderHTML: (n) => n.backgroundColor !== w.backgroundColor.default && {
              "data-background-color": n.backgroundColor
            }
          }
        }
      }
    ];
  }
}), Do = new x("blocknote-placeholder"), Oo = M.create({
  name: "placeholder",
  addOptions() {
    return {
      placeholders: {
        default: "Enter text or type '/' for commands",
        heading: "Heading",
        bulletListItem: "List",
        numberedListItem: "List"
      }
    };
  },
  addProseMirrorPlugins() {
    const n = this.options.placeholders;
    return [
      new v({
        key: Do,
        view: () => {
          const t = document.createElement("style");
          document.head.appendChild(t);
          const e = t.sheet, o = (i = "") => `.bn-block-content${i} .bn-inline-content:has(> .ProseMirror-trailingBreak):before`, r = (i, s = !0) => {
            const a = s ? "[data-is-empty-and-focused]" : "";
            if (i === "default")
              return o(a);
            const l = `[data-content-type="${i}"]`;
            return o(a + l);
          };
          for (const [i, s] of Object.entries(n)) {
            const a = i === "default";
            e.insertRule(
              `${r(
                i,
                a
              )}{ content: ${JSON.stringify(s)}; }`
            ), a || e.insertRule(
              `${r(i, !0)}{ content: ${JSON.stringify(
                s
              )}; }`
            );
          }
          return {
            destroy: () => {
              document.head.removeChild(t);
            }
          };
        },
        props: {
          // TODO: maybe also add placeholder for empty document ("e.g.: start writing..")
          decorations: (t) => {
            const { doc: e, selection: o } = t;
            if (!this.editor.isEditable || !o.empty)
              return;
            const i = o.$anchor, s = i.parent;
            if (s.content.size > 0)
              return null;
            const a = i.before(), l = j.node(a, a + s.nodeSize, {
              "data-is-empty-and-focused": "true"
            });
            return G.create(e, [l]);
          }
        }
      })
    ];
  }
}), _o = M.create({
  name: "textAlignment",
  addGlobalAttributes() {
    return [
      {
        // Attribute is applied to block content instead of container so that child blocks don't inherit the text
        // alignment styling.
        types: ["paragraph", "heading", "bulletListItem", "numberedListItem"],
        attributes: {
          textAlignment: {
            default: "left",
            parseHTML: (n) => n.getAttribute("data-text-alignment"),
            renderHTML: (n) => n.textAlignment !== "left" && {
              "data-text-alignment": n.textAlignment
            }
          }
        }
      }
    ];
  }
}), Uo = M.create({
  name: "blockTextColor",
  addGlobalAttributes() {
    return [
      {
        types: ["blockContainer"],
        attributes: {
          textColor: {
            default: w.textColor.default,
            parseHTML: (n) => n.hasAttribute("data-text-color") ? n.getAttribute("data-text-color") : w.textColor.default,
            renderHTML: (n) => n.textColor !== w.textColor.default && {
              "data-text-color": n.textColor
            }
          }
        }
      }
    ];
  }
}), Ro = M.create({
  name: "trailingNode",
  addProseMirrorPlugins() {
    const n = new x(this.name);
    return [
      new v({
        key: n,
        appendTransaction: (t, e, o) => {
          const { doc: r, tr: i, schema: s } = o, a = n.getState(o), l = r.content.size - 2, c = s.nodes.blockContainer, u = s.nodes.paragraph;
          if (a)
            return i.insert(
              l,
              c.create(void 0, u.create())
            );
        },
        state: {
          init: (t, e) => {
          },
          apply: (t, e) => {
            if (!t.docChanged)
              return e;
            let o = t.doc.lastChild;
            if (!o || o.type.name !== "blockGroup")
              throw new Error("Expected blockGroup");
            if (o = o.lastChild, !o || o.type.name !== "blockContainer")
              throw new Error("Expected blockContainer");
            const r = o.firstChild;
            if (!r)
              throw new Error("Expected blockContent");
            return o.nodeSize > 4 || r.type.spec.content !== "inline*";
          }
        }
      })
    ];
  }
}), zo = new x("non-editable-block"), Vo = () => new v({
  key: zo,
  props: {
    handleKeyDown: (n, t) => {
      "node" in n.state.selection && t.key.length === 1 && !t.ctrlKey && !t.altKey && !t.metaKey && !t.shiftKey && t.preventDefault();
    }
  }
}), Rt = new x("previous-blocks"), Fo = {
  // Numbered List Items
  index: "index",
  // Headings
  level: "level",
  // All Blocks
  type: "type",
  depth: "depth",
  "depth-change": "depth-change"
}, $o = () => {
  let n;
  return new v({
    key: Rt,
    view(t) {
      return {
        update: async (e, o) => {
          var r;
          ((r = this.key) == null ? void 0 : r.getState(e.state).updatedBlocks.size) > 0 && (n = setTimeout(() => {
            e.dispatch(
              e.state.tr.setMeta(Rt, { clearUpdate: !0 })
            );
          }, 0));
        },
        destroy: () => {
          n && clearTimeout(n);
        }
      };
    },
    state: {
      init() {
        return {
          // Block attributes, by block ID, from just before the previous transaction.
          prevTransactionOldBlockAttrs: {},
          // Block attributes, by block ID, from just before the current transaction.
          currentTransactionOldBlockAttrs: {},
          // Set of IDs of blocks whose attributes changed from the current transaction.
          updatedBlocks: /* @__PURE__ */ new Set()
        };
      },
      apply(t, e, o, r) {
        if (e.currentTransactionOldBlockAttrs = {}, e.updatedBlocks.clear(), !t.docChanged || o.doc.eq(r.doc))
          return e;
        const i = {}, s = Bt(o.doc, (c) => c.attrs.id), a = new Map(
          s.map((c) => [c.node.attrs.id, c])
        ), l = Bt(r.doc, (c) => c.attrs.id);
        for (const c of l) {
          const u = a.get(c.node.attrs.id), p = u == null ? void 0 : u.node.firstChild, m = c.node.firstChild;
          if (u && p && m) {
            const h = {
              index: m.attrs.index,
              level: m.attrs.level,
              type: m.type.name,
              depth: r.doc.resolve(c.pos).depth
            };
            let f = {
              index: p.attrs.index,
              level: p.attrs.level,
              type: p.type.name,
              depth: o.doc.resolve(u.pos).depth
            };
            i[c.node.attrs.id] = f, t.getMeta("numberedListIndexing") && (c.node.attrs.id in e.prevTransactionOldBlockAttrs && (f = e.prevTransactionOldBlockAttrs[c.node.attrs.id]), h.type === "numberedListItem" && (f.index = h.index)), e.currentTransactionOldBlockAttrs[c.node.attrs.id] = f, JSON.stringify(f) !== JSON.stringify(h) && (f["depth-change"] = f.depth - h.depth, e.updatedBlocks.add(c.node.attrs.id));
          }
        }
        return e.prevTransactionOldBlockAttrs = i, e;
      }
    },
    props: {
      decorations(t) {
        const e = this.getState(t);
        if (e.updatedBlocks.size === 0)
          return;
        const o = [];
        return t.doc.descendants((r, i) => {
          if (!r.attrs.id || !e.updatedBlocks.has(r.attrs.id))
            return;
          const s = e.currentTransactionOldBlockAttrs[r.attrs.id], a = {};
          for (const [c, u] of Object.entries(s))
            a["data-prev-" + Fo[c]] = u || "none";
          const l = j.node(i, i + r.nodeSize, {
            ...a
          });
          o.push(l);
        }), G.create(t.doc, o);
      }
    }
  });
}, Go = {
  blockColor: "data-block-color",
  blockStyle: "data-block-style",
  id: "data-id",
  depth: "data-depth",
  depthChange: "data-depth-change"
}, jo = W.create({
  name: "blockContainer",
  group: "blockContainer",
  // A block always contains content, and optionally a blockGroup which contains nested blocks
  content: "blockContent blockGroup?",
  // Ensures content-specific keyboard handlers trigger first.
  priority: 50,
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "div",
        getAttrs: (n) => {
          if (typeof n == "string")
            return !1;
          const t = {};
          for (const [e, o] of Object.entries(Go))
            n.getAttribute(o) && (t[e] = n.getAttribute(o));
          return n.getAttribute("data-node-type") === "blockContainer" ? t : !1;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    var r;
    const t = document.createElement("div");
    t.className = "bn-block-outer", t.setAttribute("data-node-type", "blockOuter");
    for (const [i, s] of Object.entries(n))
      i !== "class" && t.setAttribute(i, s);
    const e = {
      ...((r = this.options.domAttributes) == null ? void 0 : r.block) || {},
      ...n
    }, o = document.createElement("div");
    o.className = z("bn-block", e.class), o.setAttribute("data-node-type", this.name);
    for (const [i, s] of Object.entries(e))
      i !== "class" && o.setAttribute(i, s);
    return t.appendChild(o), {
      dom: t,
      contentDOM: o
    };
  },
  addCommands() {
    return {
      // Creates a new text block at a given position.
      BNCreateBlock: (n) => ({ state: t, dispatch: e }) => {
        const o = t.schema.nodes.blockContainer.createAndFill();
        return e && t.tr.insert(n, o), !0;
      },
      // Deletes a block at a given position.
      BNDeleteBlock: (n) => ({ state: t, dispatch: e }) => {
        const o = b(t.doc, n);
        if (o === void 0)
          return !1;
        const { startPos: r, endPos: i } = o;
        return e && t.tr.deleteRange(r, i), !0;
      },
      // Updates a block at a given position.
      BNUpdateBlock: (n, t) => ({ state: e, dispatch: o }) => {
        const r = b(e.doc, n);
        if (r === void 0)
          return !1;
        const { startPos: i, endPos: s, node: a, contentNode: l } = r;
        if (o) {
          if (t.children !== void 0) {
            const m = [];
            for (const h of t.children)
              m.push(
                D(
                  h,
                  e.schema,
                  this.options.editor.schema.styleSchema
                )
              );
            a.childCount === 2 ? e.tr.replace(
              i + l.nodeSize + 1,
              s - 1,
              new U(T.from(m), 0, 0)
            ) : e.tr.insert(
              i + l.nodeSize,
              e.schema.nodes.blockGroup.create({}, m)
            );
          }
          const c = l.type.name, u = t.type || c;
          let p = "keep";
          if (t.content)
            if (typeof t.content == "string")
              p = [e.schema.text(t.content)];
            else if (Array.isArray(t.content))
              p = at(
                t.content,
                e.schema,
                this.options.editor.schema.styleSchema
              );
            else if (t.content.type === "tableContent")
              p = jt(
                t.content,
                e.schema,
                this.options.editor.schema.styleSchema
              );
            else
              throw new A(t.content.type);
          else {
            const m = e.schema.nodes[c].spec.content, h = e.schema.nodes[u].spec.content;
            m === "" || h !== m && (p = []);
          }
          p === "keep" ? e.tr.setNodeMarkup(
            i,
            t.type === void 0 ? void 0 : e.schema.nodes[t.type],
            {
              ...l.attrs,
              ...t.props
            }
          ) : e.tr.replaceWith(
            i,
            s,
            e.schema.nodes[u].create(
              {
                ...l.attrs,
                ...t.props
              },
              p
            )
          ).setSelection(
            e.schema.nodes[u].spec.content === "" ? new it(e.tr.doc.resolve(i)) : e.schema.nodes[u].spec.content === "inline*" ? new ot(e.tr.doc.resolve(i)) : (
              // Need to offset the position as we have to get through the
              // `tableRow` and `tableCell` nodes to get to the
              // `tableParagraph` node we want to set the selection in.
              new ot(e.tr.doc.resolve(i + 4))
            )
          ), e.tr.setNodeMarkup(i - 1, void 0, {
            ...a.attrs,
            ...t.props
          });
        }
        return !0;
      },
      // Appends the text contents of a block to the nearest previous block, given a position between them. Children of
      // the merged block are moved out of it first, rather than also being merged.
      //
      // In the example below, the position passed into the function is between Block1 and Block2.
      //
      // Block1
      //    Block2
      // Block3
      //    Block4
      //        Block5
      //
      // Becomes:
      //
      // Block1
      //    Block2Block3
      // Block4
      //     Block5
      BNMergeBlocks: (n) => ({ state: t, dispatch: e }) => {
        const o = t.doc.resolve(n + 1).node().type.name === "blockContainer", r = t.doc.resolve(n - 1).node().type.name === "blockContainer";
        if (!o || !r)
          return !1;
        const i = b(
          t.doc,
          n + 1
        ), { node: s, contentNode: a, startPos: l, endPos: c, depth: u } = i;
        if (s.childCount === 2) {
          const h = t.doc.resolve(
            l + a.nodeSize + 1
          ), f = t.doc.resolve(c - 1), k = h.blockRange(f);
          e && t.tr.lift(k, u - 1);
        }
        let p = n - 1, m = b(t.doc, p);
        for (; m.numChildBlocks > 0; )
          if (p--, m = b(t.doc, p), m === void 0)
            return !1;
        return e && (e(
          t.tr.deleteRange(l, l + a.nodeSize).replace(
            p - 1,
            l,
            new U(a.content, 0, 0)
          ).scrollIntoView()
        ), t.tr.setSelection(
          new ot(t.doc.resolve(p - 1))
        )), !0;
      },
      // Splits a block at a given position. Content after the position is moved to a new block below, at the same
      // nesting level.
      BNSplitBlock: (n, t) => ({ state: e, dispatch: o }) => {
        const r = b(e.doc, n);
        if (r === void 0)
          return !1;
        const { contentNode: i, contentType: s, startPos: a, endPos: l, depth: c } = r, u = e.doc.cut(a + 1, n), p = e.doc.cut(n, l - 1), m = e.schema.nodes.blockContainer.createAndFill(), h = l + 1, f = h + 2;
        return o && (e.tr.insert(h, m), e.tr.replace(
          f,
          f + 1,
          p.content.size > 0 ? new U(
            T.from(p),
            c + 2,
            c + 2
          ) : void 0
        ), t && e.tr.setBlockType(
          f,
          f,
          e.schema.node(s).type,
          i.attrs
        ), e.tr.setSelection(
          new ot(e.doc.resolve(f))
        ), e.tr.replace(
          a + 1,
          l - 1,
          u.content.size > 0 ? new U(
            T.from(u),
            c + 2,
            c + 2
          ) : void 0
        )), !0;
      }
    };
  },
  addProseMirrorPlugins() {
    return [$o(), Vo()];
  },
  addKeyboardShortcuts() {
    return {
      Backspace: () => this.editor.commands.first(({ commands: o }) => [
        // Deletes the selection if it's not empty.
        () => o.deleteSelection(),
        // Undoes an input rule if one was triggered in the last editor state change.
        () => o.undoInputRule(),
        // Reverts block content type to a paragraph if the selection is at the start of the block.
        () => o.command(({ state: r }) => {
          const { contentType: i, startPos: s } = b(
            r.doc,
            r.selection.from
          ), a = r.selection.from === s + 1, l = i.name === "paragraph";
          return a && !l ? o.BNUpdateBlock(r.selection.from, {
            type: "paragraph",
            props: {}
          }) : !1;
        }),
        // Removes a level of nesting if the block is indented if the selection is at the start of the block.
        () => o.command(({ state: r }) => {
          const { startPos: i } = b(
            r.doc,
            r.selection.from
          );
          return r.selection.from === i + 1 ? o.liftListItem("blockContainer") : !1;
        }),
        // Merges block with the previous one if it isn't indented, isn't the first block in the doc, and the selection
        // is at the start of the block.
        () => o.command(({ state: r }) => {
          const { depth: i, startPos: s } = b(
            r.doc,
            r.selection.from
          ), a = r.selection.from === s + 1, l = r.selection.empty, c = s === 2, u = s - 1;
          return !c && a && l && i === 2 ? o.BNMergeBlocks(u) : !1;
        })
      ]),
      Delete: () => this.editor.commands.first(({ commands: o }) => [
        // Deletes the selection if it's not empty.
        () => o.deleteSelection(),
        // Merges block with the next one (at the same nesting level or lower),
        // if one exists, the block has no children, and the selection is at the
        // end of the block.
        () => o.command(({ state: r }) => {
          const { node: i, depth: s, endPos: a } = b(
            r.doc,
            r.selection.from
          ), l = a === r.doc.nodeSize - 4, c = r.selection.from === a - 1, u = r.selection.empty, p = i.childCount === 2;
          if (!l && c && u && !p) {
            let m = s, h = a + 2, f = r.doc.resolve(h).depth;
            for (; f < m; )
              m = f, h += 2, f = r.doc.resolve(h).depth;
            return o.BNMergeBlocks(h - 1);
          }
          return !1;
        })
      ]),
      Enter: () => this.editor.commands.first(({ commands: o }) => [
        // Removes a level of nesting if the block is empty & indented, while the selection is also empty & at the start
        // of the block.
        () => o.command(({ state: r }) => {
          const { node: i, depth: s } = b(
            r.doc,
            r.selection.from
          ), a = r.selection.$anchor.parentOffset === 0, l = r.selection.anchor === r.selection.head, c = i.textContent.length === 0, u = s > 2;
          return a && l && c && u ? o.liftListItem("blockContainer") : !1;
        }),
        // Creates a new block and moves the selection to it if the current one is empty, while the selection is also
        // empty & at the start of the block.
        () => o.command(({ state: r, chain: i }) => {
          const { node: s, endPos: a } = b(
            r.doc,
            r.selection.from
          ), l = r.selection.$anchor.parentOffset === 0, c = r.selection.anchor === r.selection.head, u = s.textContent.length === 0;
          if (l && c && u) {
            const p = a + 1, m = p + 2;
            return i().BNCreateBlock(p).setTextSelection(m).run(), !0;
          }
          return !1;
        }),
        // Splits the current block, moving content inside that's after the cursor to a new text block below. Also
        // deletes the selection beforehand, if it's not empty.
        () => o.command(({ state: r, chain: i }) => {
          const { node: s } = b(
            r.doc,
            r.selection.from
          ), a = r.selection.$anchor.parentOffset === 0;
          return s.textContent.length === 0 ? !1 : (i().deleteSelection().BNSplitBlock(r.selection.from, a).run(), !0);
        })
      ]),
      // Always returning true for tab key presses ensures they're not captured by the browser. Otherwise, they blur the
      // editor since the browser will try to use tab for keyboard navigation.
      Tab: () => (this.editor.commands.sinkListItem("blockContainer"), !0),
      "Shift-Tab": () => (this.editor.commands.liftListItem("blockContainer"), !0)
    };
  }
}), Wo = W.create({
  name: "blockGroup",
  group: "blockGroup",
  content: "blockContainer+",
  parseHTML() {
    return [
      {
        tag: "div",
        getAttrs: (n) => typeof n == "string" ? !1 : n.getAttribute("data-node-type") === "blockGroup" ? null : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    var o;
    const t = {
      ...((o = this.options.domAttributes) == null ? void 0 : o.blockGroup) || {},
      ...n
    }, e = document.createElement("div");
    e.className = z(
      "bn-block-group",
      t.class
    ), e.setAttribute("data-node-type", "blockGroup");
    for (const [r, i] of Object.entries(t))
      r !== "class" && e.setAttribute(r, i);
    return {
      dom: e,
      contentDOM: e
    };
  }
}), qo = W.create({
  name: "doc",
  topNode: !0,
  content: "blockGroup"
}), Ko = (n) => {
  var e;
  const t = [
    X.ClipboardTextSerializer,
    X.Commands,
    X.Editable,
    X.FocusEvents,
    X.Tabindex,
    // DevTools,
    Xe,
    // DropCursor,
    Oo.configure({
      // TODO: This shorthand is kind of ugly
      ...n.placeholders !== void 0 ? { placeholders: n.placeholders } : {}
    }),
    Z.configure({
      types: ["blockContainer"]
    }),
    Ye,
    // Comments,
    // basics:
    tn,
    // marks:
    Ze,
    ...Object.values(n.styleSpecs).map((o) => o.implementation.mark),
    Uo,
    Ho,
    _o,
    // nodes
    qo,
    jo.configure({
      editor: n.editor,
      domAttributes: n.domAttributes
    }),
    Wo.configure({
      domAttributes: n.domAttributes
    }),
    ...Object.values(n.inlineContentSpecs).filter((o) => o.config !== "link" && o.config !== "text").map((o) => o.implementation.node.configure({
      editor: n.editor
    })),
    ...Object.values(n.blockSpecs).flatMap((o) => [
      // dependent nodes (e.g.: tablecell / row)
      ...(o.implementation.requiredExtensions || []).map(
        (r) => r.configure({
          editor: n.editor,
          domAttributes: n.domAttributes
        })
      ),
      // the actual node itself
      o.implementation.node.configure({
        editor: n.editor,
        domAttributes: n.domAttributes
      })
    ]),
    No(n.editor),
    Po(n.editor),
    Je.configure({ width: 5, color: "#ddeeff" }),
    // This needs to be at the bottom of this list, because Key events (such as enter, when selecting a /command),
    // should be handled before Enter handlers in other components like splitListItem
    Ro
  ];
  if (n.collaboration) {
    if (t.push(
      qe.configure({
        fragment: n.collaboration.fragment
      })
    ), (e = n.collaboration.provider) != null && e.awareness) {
      const o = (r) => {
        const i = document.createElement("span");
        i.classList.add("collaboration-cursor__caret"), i.setAttribute("style", `border-color: ${r.color}`);
        const s = document.createElement("span");
        s.classList.add("collaboration-cursor__label"), s.setAttribute("style", `background-color: ${r.color}`), s.insertBefore(document.createTextNode(r.name), null);
        const a = document.createTextNode("⁠"), l = document.createTextNode("⁠");
        return i.insertBefore(a, null), i.insertBefore(s, null), i.insertBefore(l, null), i;
      };
      t.push(
        Ke.configure({
          user: n.collaboration.user,
          render: n.collaboration.renderCursor || o,
          provider: n.collaboration.provider
        })
      );
    }
  } else
    t.push(Qe);
  return t;
};
function Jo(n, t) {
  const e = [];
  return n.forEach((o, r, i) => {
    i !== t && e.push(o);
  }), T.from(e);
}
function Xo(n, t) {
  let e = T.from(n.content);
  for (let o = 0; o < e.childCount; o++)
    if (e.child(o).type.spec.group === "blockContent") {
      const r = [e.child(o)];
      if (o + 1 < e.childCount && e.child(o + 1).type.spec.group === "blockGroup") {
        const s = e.child(o + 1).child(0).child(0);
        (s.type.name === "bulletListItem" || s.type.name === "numberedListItem") && (r.push(e.child(o + 1)), e = Jo(e, o + 1));
      }
      const i = t.state.schema.nodes.blockContainer.create(
        void 0,
        r
      );
      e = e.replaceChild(o, i);
    }
  return new U(e, n.openStart, n.openEnd);
}
class Tt {
  constructor(t) {
    d(this, "blockSpecs");
    d(this, "inlineContentSpecs");
    d(this, "styleSpecs");
    d(this, "blockSchema");
    d(this, "inlineContentSchema");
    d(this, "styleSchema");
    // Helper so that you can use typeof schema.BlockNoteEditor
    d(this, "BlockNoteEditor", "only for types");
    d(this, "Block", "only for types");
    d(this, "PartialBlock", "only for types");
    this.blockSpecs = (t == null ? void 0 : t.blockSpecs) || re, this.inlineContentSpecs = (t == null ? void 0 : t.inlineContentSpecs) || se, this.styleSpecs = (t == null ? void 0 : t.styleSpecs) || ie, this.blockSchema = te(this.blockSpecs), this.inlineContentSchema = ee(
      this.inlineContentSpecs
    ), this.styleSchema = oe(this.styleSpecs);
  }
  static create(t) {
    return new Tt(t);
  }
}
class Yo extends Me {
  constructor(e, o) {
    super({ ...e, content: void 0 });
    d(this, "_state");
    /**
     * Mounts / unmounts the editor to a dom element
     *
     * @param element DOM element to mount to, ur null / undefined to destroy
     */
    d(this, "mount", (e) => {
      e ? (this.options.element = e, this.createViewAlternative()) : this.destroy();
    });
    const r = this.schema;
    let i;
    const s = r.nodes.doc.createAndFill;
    r.nodes.doc.createAndFill = (...l) => {
      if (i)
        return i;
      const c = s.apply(r.nodes.doc, l), u = JSON.parse(JSON.stringify(c.toJSON()));
      return u.content[0].content[0].attrs.id = "initialBlockId", i = be.fromJSON(r, u), i;
    };
    let a;
    try {
      const l = e == null ? void 0 : e.content.map(
        (c) => D(c, this.schema, o).toJSON()
      );
      a = Be(
        {
          type: "doc",
          content: [
            {
              type: "blockGroup",
              content: l
            }
          ]
        },
        this.schema,
        this.options.parseOptions
      );
    } catch (l) {
      throw console.error(
        "Error creating document from blocks passed as `initialContent`. Caused by exception: ",
        l
      ), new Error(
        "Error creating document from blocks passed as `initialContent`:\n" + +JSON.stringify(e.content)
      );
    }
    this._state = Le.create({
      doc: a,
      schema: this.schema
      // selection: selection || undefined,
    });
  }
  get state() {
    return this.view && (this._state = this.view.state), this._state;
  }
  createView() {
  }
  /**
   * Replace the default `createView` method with a custom one - which we call on mount
   */
  createViewAlternative() {
    queueMicrotask(() => {
      this.view = new We(this.options.element, {
        ...this.options.editorProps,
        // @ts-ignore
        dispatchTransaction: this.dispatchTransaction.bind(this),
        state: this.state
      });
      const e = this.state.reconfigure({
        plugins: this.extensionManager.plugins
      });
      this.view.updateState(e), this.createNodeViews();
    });
  }
}
const Qo = {
  enableInputRules: !0,
  enablePasteRules: !0,
  enableCoreExtensions: !1
};
class ue {
  constructor(t) {
    d(this, "_tiptapEditor");
    d(this, "blockCache", /* @__PURE__ */ new WeakMap());
    d(this, "schema");
    d(this, "blockImplementations");
    d(this, "inlineContentImplementations");
    d(this, "styleImplementations");
    d(this, "formattingToolbar");
    d(this, "linkToolbar");
    d(this, "sideMenu");
    d(this, "suggestionMenus");
    d(this, "imagePanel");
    d(this, "tableHandles");
    d(this, "uploadFile");
    var l, c, u, p, m, h, f, k;
    this.options = t;
    const e = t;
    if (e.onEditorContentChange)
      throw new Error(
        "onEditorContentChange initialization option is deprecated, use <BlockNoteView onChange={...} />, the useEditorChange(...) hook, or editor.onChange(...)"
      );
    if (e.onTextCursorPositionChange)
      throw new Error(
        "onTextCursorPositionChange initialization option is deprecated, use <BlockNoteView onSelectionChange={...} />, the useEditorSelectionChange(...) hook, or editor.onSelectionChange(...)"
      );
    if (e.onEditorReady)
      throw new Error(
        "onEditorReady is deprecated. Editor is immediately ready for use after creation."
      );
    if (e.editable)
      throw new Error(
        "editable initialization option is deprecated, use <BlockNoteView editable={true/false} />, or alternatively editor.isEditable = true/false"
      );
    const o = {
      defaultStyles: !0,
      schema: t.schema || Tt.create(),
      ...t
    };
    this.schema = o.schema, this.blockImplementations = o.schema.blockSpecs, this.inlineContentImplementations = o.schema.inlineContentSpecs, this.styleImplementations = o.schema.styleSpecs, this.formattingToolbar = new uo(this), this.linkToolbar = new mo(this), this.sideMenu = new So(this), this.suggestionMenus = new bo(this), I("image", this) && (this.imagePanel = new xo(this)), I("table", this) && (this.tableHandles = new Io(this));
    const r = Ko({
      editor: this,
      placeholders: o.placeholders,
      domAttributes: o.domAttributes || {},
      blockSchema: this.schema.blockSchema,
      blockSpecs: this.schema.blockSpecs,
      styleSpecs: this.schema.styleSpecs,
      inlineContentSpecs: this.schema.inlineContentSpecs,
      collaboration: o.collaboration
    }), i = M.create({
      name: "BlockNoteUIExtension",
      addProseMirrorPlugins: () => [
        this.formattingToolbar.plugin,
        this.linkToolbar.plugin,
        this.sideMenu.plugin,
        this.suggestionMenus.plugin,
        ...this.imagePanel ? [this.imagePanel.plugin] : [],
        ...this.tableHandles ? [this.tableHandles.plugin] : []
      ]
    });
    r.push(i), this.uploadFile = o.uploadFile, o.collaboration && o.initialContent && console.warn(
      "When using Collaboration, initialContent might cause conflicts, because changes should come from the collaboration provider"
    );
    const s = o.initialContent || (t.collaboration ? [
      {
        type: "paragraph",
        id: "initialBlockId"
      }
    ] : [
      {
        type: "paragraph",
        id: Z.options.generateID()
      }
    ]);
    if (!Array.isArray(s) || s.length === 0)
      throw new Error(
        "initialContent must be a non-empty array of blocks, received: " + s
      );
    const a = {
      ...Qo,
      ...o._tiptapOptions,
      content: s,
      extensions: o.enableBlockNoteExtensions === !1 ? ((l = o._tiptapOptions) == null ? void 0 : l.extensions) || [] : [...((c = o._tiptapOptions) == null ? void 0 : c.extensions) || [], ...r],
      editorProps: {
        ...(u = o._tiptapOptions) == null ? void 0 : u.editorProps,
        attributes: {
          ...(m = (p = o._tiptapOptions) == null ? void 0 : p.editorProps) == null ? void 0 : m.attributes,
          ...(h = o.domAttributes) == null ? void 0 : h.editor,
          class: z(
            "bn-editor",
            o.defaultStyles ? "bn-default-styles" : "",
            ((k = (f = o.domAttributes) == null ? void 0 : f.editor) == null ? void 0 : k.class) || ""
          )
        },
        transformPasted: Xo
      }
    };
    this._tiptapEditor = new Yo(
      a,
      this.schema.styleSchema
    );
  }
  static create(t = {}) {
    return new ue(t);
  }
  /**
   * Mount the editor to a parent DOM element. Call mount(undefined) to clean up
   *
   * @warning Not needed for React, use BlockNoteView to take care of this
   */
  mount(t) {
    this._tiptapEditor.mount(t);
  }
  get prosemirrorView() {
    return this._tiptapEditor.view;
  }
  get domElement() {
    return this._tiptapEditor.view.dom;
  }
  isFocused() {
    return this._tiptapEditor.view.hasFocus();
  }
  focus() {
    this._tiptapEditor.view.focus();
  }
  /**
   * @deprecated, use `editor.document` instead
   */
  get topLevelBlocks() {
    return this.topLevelBlocks;
  }
  /**
   * Gets a snapshot of all top-level (non-nested) blocks in the editor.
   * @returns A snapshot of all top-level (non-nested) blocks in the editor.
   */
  get document() {
    const t = [];
    return this._tiptapEditor.state.doc.firstChild.descendants((e) => (t.push(
      y(
        e,
        this.schema.blockSchema,
        this.schema.inlineContentSchema,
        this.schema.styleSchema,
        this.blockCache
      )
    ), !1)), t;
  }
  /**
   * Gets a snapshot of an existing block from the editor.
   * @param blockIdentifier The identifier of an existing block that should be retrieved.
   * @returns The block that matches the identifier, or `undefined` if no matching block was found.
   */
  getBlock(t) {
    const e = typeof t == "string" ? t : t.id;
    let o;
    return this._tiptapEditor.state.doc.firstChild.descendants((r) => typeof o < "u" ? !1 : r.type.name !== "blockContainer" || r.attrs.id !== e ? !0 : (o = y(
      r,
      this.schema.blockSchema,
      this.schema.inlineContentSchema,
      this.schema.styleSchema,
      this.blockCache
    ), !1)), o;
  }
  /**
   * Traverses all blocks in the editor depth-first, and executes a callback for each.
   * @param callback The callback to execute for each block. Returning `false` stops the traversal.
   * @param reverse Whether the blocks should be traversed in reverse order.
   */
  forEachBlock(t, e = !1) {
    const o = this.document.slice();
    e && o.reverse();
    function r(i) {
      for (const s of i) {
        if (!t(s))
          return !1;
        const a = e ? s.children.slice().reverse() : s.children;
        if (!r(a))
          return !1;
      }
      return !0;
    }
    r(o);
  }
  /**
   * Executes a callback whenever the editor's contents change.
   * @param callback The callback to execute.
   */
  onEditorContentChange(t) {
    this._tiptapEditor.on("update", t);
  }
  /**
   * Executes a callback whenever the editor's selection changes.
   * @param callback The callback to execute.
   */
  onEditorSelectionChange(t) {
    this._tiptapEditor.on("selectionUpdate", t);
  }
  /**
   * Gets a snapshot of the current text cursor position.
   * @returns A snapshot of the current text cursor position.
   */
  getTextCursorPosition() {
    const { node: t, depth: e, startPos: o, endPos: r } = b(
      this._tiptapEditor.state.doc,
      this._tiptapEditor.state.selection.from
    ), i = this._tiptapEditor.state.doc.resolve(r).index(e - 1), s = this._tiptapEditor.state.doc.resolve(r + 1).node().childCount;
    let a;
    i > 0 && (a = this._tiptapEditor.state.doc.resolve(o - 2).node());
    let l;
    return i < s - 1 && (l = this._tiptapEditor.state.doc.resolve(r + 2).node()), {
      block: y(
        t,
        this.schema.blockSchema,
        this.schema.inlineContentSchema,
        this.schema.styleSchema,
        this.blockCache
      ),
      prevBlock: a === void 0 ? void 0 : y(
        a,
        this.schema.blockSchema,
        this.schema.inlineContentSchema,
        this.schema.styleSchema,
        this.blockCache
      ),
      nextBlock: l === void 0 ? void 0 : y(
        l,
        this.schema.blockSchema,
        this.schema.inlineContentSchema,
        this.schema.styleSchema,
        this.blockCache
      )
    };
  }
  /**
   * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could
   * not be found.
   * @param targetBlock The identifier of an existing block that the text cursor should be moved to.
   * @param placement Whether the text cursor should be placed at the start or end of the block.
   */
  setTextCursorPosition(t, e = "start") {
    const o = typeof t == "string" ? t : t.id, { posBeforeNode: r } = St(o, this._tiptapEditor.state.doc), { startPos: i, contentNode: s } = b(
      this._tiptapEditor.state.doc,
      r + 2
    ), a = this.schema.blockSchema[s.type.name].content;
    if (a === "none") {
      this._tiptapEditor.commands.setNodeSelection(i);
      return;
    }
    if (a === "inline")
      e === "start" ? this._tiptapEditor.commands.setTextSelection(i + 1) : this._tiptapEditor.commands.setTextSelection(
        i + s.nodeSize - 1
      );
    else if (a === "table")
      e === "start" ? this._tiptapEditor.commands.setTextSelection(i + 4) : this._tiptapEditor.commands.setTextSelection(
        i + s.nodeSize - 4
      );
    else
      throw new A(a);
  }
  /**
   * Gets a snapshot of the current selection.
   */
  getSelection() {
    if (this._tiptapEditor.state.selection.from === this._tiptapEditor.state.selection.to || "node" in this._tiptapEditor.state.selection)
      return;
    const t = [];
    return this._tiptapEditor.state.doc.descendants((e, o) => e.type.spec.group !== "blockContent" || o + e.nodeSize < this._tiptapEditor.state.selection.from || o > this._tiptapEditor.state.selection.to ? !0 : (t.push(
      y(
        this._tiptapEditor.state.doc.resolve(o).node(),
        this.schema.blockSchema,
        this.schema.inlineContentSchema,
        this.schema.styleSchema,
        this.blockCache
      )
    ), !1)), { blocks: t };
  }
  /**
   * Checks if the editor is currently editable, or if it's locked.
   * @returns True if the editor is editable, false otherwise.
   */
  get isEditable() {
    return this._tiptapEditor.isEditable;
  }
  /**
   * Makes the editor editable or locks it, depending on the argument passed.
   * @param editable True to make the editor editable, or false to lock it.
   */
  set isEditable(t) {
    this._tiptapEditor.options.editable !== t && this._tiptapEditor.setEditable(t);
  }
  /**
   * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an
   * error if the reference block could not be found.
   * @param blocksToInsert An array of partial blocks that should be inserted.
   * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.
   * @param placement Whether the blocks should be inserted just before, just after, or nested inside the
   * `referenceBlock`. Inserts the blocks at the start of the existing block's children if "nested" is used.
   */
  insertBlocks(t, e, o = "before") {
    return Kn(t, e, o, this);
  }
  /**
   * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be
   * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could
   * not be found.
   * @param blockToUpdate The block that should be updated.
   * @param update A partial block which defines how the existing block should be changed.
   */
  updateBlock(t, e) {
    return Jn(t, e, this);
  }
  /**
   * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.
   * @param blocksToRemove An array of identifiers for existing blocks that should be removed.
   */
  removeBlocks(t) {
    return Xn(t, this);
  }
  /**
   * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or
   * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in
   * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.
   * @param blocksToRemove An array of blocks that should be replaced.
   * @param blocksToInsert An array of partial blocks to replace the old ones with.
   */
  replaceBlocks(t, e) {
    return Yn(t, e, this);
  }
  /**
   * Insert a piece of content at the current cursor position.
   *
   * @param content can be a string, or array of partial inline content elements
   */
  insertInlineContent(t) {
    const e = at(
      t,
      this._tiptapEditor.schema,
      this.schema.styleSchema
    );
    Qn(
      {
        from: this._tiptapEditor.state.selection.from,
        to: this._tiptapEditor.state.selection.to
      },
      e,
      this
    );
  }
  /**
   * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.
   */
  getActiveStyles() {
    const t = {}, e = this._tiptapEditor.state.selection.$to.marks();
    for (const o of e) {
      const r = this.schema.styleSchema[o.type.name];
      if (!r) {
        console.warn("mark not found in styleschema", o.type.name);
        continue;
      }
      r.propSchema === "boolean" ? t[r.type] = !0 : t[r.type] = o.attrs.stringValue;
    }
    return t;
  }
  /**
   * Adds styles to the currently selected content.
   * @param styles The styles to add.
   */
  addStyles(t) {
    this._tiptapEditor.view.focus();
    for (const [e, o] of Object.entries(t)) {
      const r = this.schema.styleSchema[e];
      if (!r)
        throw new Error(`style ${e} not found in styleSchema`);
      if (r.propSchema === "boolean")
        this._tiptapEditor.commands.setMark(e);
      else if (r.propSchema === "string")
        this._tiptapEditor.commands.setMark(e, { stringValue: o });
      else
        throw new A(r.propSchema);
    }
  }
  /**
   * Removes styles from the currently selected content.
   * @param styles The styles to remove.
   */
  removeStyles(t) {
    this._tiptapEditor.view.focus();
    for (const e of Object.keys(t))
      this._tiptapEditor.commands.unsetMark(e);
  }
  /**
   * Toggles styles on the currently selected content.
   * @param styles The styles to toggle.
   */
  toggleStyles(t) {
    this._tiptapEditor.view.focus();
    for (const [e, o] of Object.entries(t)) {
      const r = this.schema.styleSchema[e];
      if (!r)
        throw new Error(`style ${e} not found in styleSchema`);
      if (r.propSchema === "boolean")
        this._tiptapEditor.commands.toggleMark(e);
      else if (r.propSchema === "string")
        this._tiptapEditor.commands.toggleMark(e, { stringValue: o });
      else
        throw new A(r.propSchema);
    }
  }
  /**
   * Gets the currently selected text.
   */
  getSelectedText() {
    return this._tiptapEditor.state.doc.textBetween(
      this._tiptapEditor.state.selection.from,
      this._tiptapEditor.state.selection.to
    );
  }
  /**
   * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.
   */
  getSelectedLinkUrl() {
    return this._tiptapEditor.getAttributes("link").href;
  }
  /**
   * Creates a new link to replace the selected content.
   * @param url The link URL.
   * @param text The text to display the link with.
   */
  createLink(t, e) {
    if (t === "")
      return;
    const { from: o, to: r } = this._tiptapEditor.state.selection;
    e || (e = this._tiptapEditor.state.doc.textBetween(o, r));
    const i = this._tiptapEditor.schema.mark("link", { href: t });
    this._tiptapEditor.view.dispatch(
      this._tiptapEditor.view.state.tr.insertText(e, o, r).addMark(o, o + e.length, i)
    );
  }
  /**
   * Checks if the block containing the text cursor can be nested.
   */
  canNestBlock() {
    const { startPos: t, depth: e } = b(
      this._tiptapEditor.state.doc,
      this._tiptapEditor.state.selection.from
    );
    return this._tiptapEditor.state.doc.resolve(t).index(e - 1) > 0;
  }
  /**
   * Nests the block containing the text cursor into the block above it.
   */
  nestBlock() {
    this._tiptapEditor.commands.sinkListItem("blockContainer");
  }
  /**
   * Checks if the block containing the text cursor is nested.
   */
  canUnnestBlock() {
    const { depth: t } = b(
      this._tiptapEditor.state.doc,
      this._tiptapEditor.state.selection.from
    );
    return t > 2;
  }
  /**
   * Lifts the block containing the text cursor out of its parent.
   */
  unnestBlock() {
    this._tiptapEditor.commands.liftListItem("blockContainer");
  }
  // TODO: Fix when implementing HTML/Markdown import & export
  /**
   * Serializes blocks into an HTML string. To better conform to HTML standards, children of blocks which aren't list
   * items are un-nested in the output HTML.
   * @param blocks An array of blocks that should be serialized into HTML.
   * @returns The blocks, serialized as an HTML string.
   */
  async blocksToHTMLLossy(t = this.document) {
    return lt(
      this._tiptapEditor.schema,
      this
    ).exportBlocks(t);
  }
  /**
   * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and
   * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote
   * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.
   * @param html The HTML string to parse blocks from.
   * @returns The blocks parsed from the HTML string.
   */
  async tryParseHTMLToBlocks(t) {
    return ce(
      t,
      this.schema.blockSchema,
      this.schema.inlineContentSchema,
      this.schema.styleSchema,
      this._tiptapEditor.schema
    );
  }
  /**
   * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of
   * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.
   * @param blocks An array of blocks that should be serialized into Markdown.
   * @returns The blocks, serialized as a Markdown string.
   */
  async blocksToMarkdownLossy(t = this.document) {
    return to(t, this._tiptapEditor.schema, this);
  }
  /**
   * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on
   * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it
   * as text.
   * @param markdown The Markdown string to parse blocks from.
   * @returns The blocks parsed from the Markdown string.
   */
  async tryParseMarkdownToBlocks(t) {
    return ao(
      t,
      this.schema.blockSchema,
      this.schema.inlineContentSchema,
      this.schema.styleSchema,
      this._tiptapEditor.schema
    );
  }
  /**
   * Updates the user info for the current user that's shown to other collaborators.
   */
  updateCollaborationUserInfo(t) {
    if (!this.options.collaboration)
      throw new Error(
        "Cannot update collaboration user info when collaboration is disabled."
      );
    this._tiptapEditor.commands.updateUser(t);
  }
  /**
   * A callback function that runs whenever the editor's contents change.
   *
   * @param callback The callback to execute.
   * @returns A function to remove the callback.
   */
  onChange(t) {
    const e = () => {
      t(this);
    };
    return this._tiptapEditor.on("update", e), () => {
      this._tiptapEditor.off("update", e);
    };
  }
  /**
   * A callback function that runs whenever the text cursor position or selection changes.
   *
   * @param callback The callback to execute.
   * @returns A function to remove the callback.
   */
  onSelectionChange(t) {
    const e = () => {
      t(this);
    };
    return this._tiptapEditor.on("selectionUpdate", e), () => {
      this._tiptapEditor.off("selectionUpdate", e);
    };
  }
}
function Zo(n) {
  let t = n.getTextCursorPosition().block, e = n.schema.blockSchema[t.type].content;
  for (; e === "none"; )
    t = n.getTextCursorPosition().nextBlock, e = n.schema.blockSchema[t.type].content, n.setTextCursorPosition(t, "end");
}
function P(n, t) {
  const e = n.getTextCursorPosition().block;
  if (e.content === void 0)
    throw new Error("Slash Menu open in a block that doesn't contain content.");
  Array.isArray(e.content) && (e.content.length === 1 && Q(e.content[0]) && e.content[0].type === "text" && e.content[0].text === "/" || e.content.length === 0) ? n.updateBlock(e, t) : (n.insertBlocks([t], e, "after"), n.setTextCursorPosition(
    n.getTextCursorPosition().nextBlock,
    "end"
  ));
  const o = n.getTextCursorPosition().block;
  return Zo(n), o;
}
function $r(n) {
  const t = [];
  return I("heading", n) && t.push(
    {
      title: "Heading 1",
      onItemClick: () => {
        P(n, {
          type: "heading",
          props: { level: 1 }
        });
      },
      subtext: "Used for a top-level heading",
      badge: F("Mod-Alt-1"),
      aliases: ["h", "heading1", "h1"],
      group: "Headings"
    },
    {
      title: "Heading 2",
      onItemClick: () => {
        P(n, {
          type: "heading",
          props: { level: 2 }
        });
      },
      subtext: "Used for key sections",
      badge: F("Mod-Alt-2"),
      aliases: ["h2", "heading2", "subheading"],
      group: "Headings"
    },
    {
      title: "Heading 3",
      onItemClick: () => {
        P(n, {
          type: "heading",
          props: { level: 3 }
        });
      },
      subtext: "Used for subsections and group headings",
      badge: F("Mod-Alt-3"),
      aliases: ["h3", "heading3", "subheading"],
      group: "Headings"
    }
  ), I("numberedListItem", n) && t.push({
    title: "Numbered List",
    onItemClick: () => {
      P(n, {
        type: "numberedListItem"
      });
    },
    subtext: "Used to display a numbered list",
    badge: F("Mod-Shift-7"),
    aliases: ["ol", "li", "list", "numberedlist", "numbered list"],
    group: "Basic blocks"
  }), I("bulletListItem", n) && t.push({
    title: "Bullet List",
    onItemClick: () => {
      P(n, {
        type: "bulletListItem"
      });
    },
    subtext: "Used to display an unordered list",
    badge: F("Mod-Shift-8"),
    aliases: ["ul", "li", "list", "bulletlist", "bullet list"],
    group: "Basic blocks"
  }), I("paragraph", n) && t.push({
    title: "Paragraph",
    onItemClick: () => {
      P(n, {
        type: "paragraph"
      });
    },
    subtext: "Used for the body of your document",
    badge: F("Mod-Alt-0"),
    aliases: ["p", "paragraph"],
    group: "Basic blocks"
  }), I("table", n) && t.push({
    title: "Table",
    onItemClick: () => {
      P(n, {
        type: "table",
        content: {
          type: "tableContent",
          rows: [
            {
              cells: ["", "", ""]
            },
            {
              cells: ["", "", ""]
            }
          ]
        }
      });
    },
    subtext: "Used for for tables",
    aliases: ["table"],
    group: "Advanced",
    badge: void 0
  }), I("image", n) && t.push({
    title: "Image",
    onItemClick: () => {
      const e = P(n, {
        type: "image"
      });
      n.prosemirrorView.dispatch(
        n._tiptapEditor.state.tr.setMeta(n.imagePanel.plugin, {
          block: e
        })
      );
    },
    subtext: "Insert an image",
    aliases: [
      "image",
      "imageUpload",
      "upload",
      "img",
      "picture",
      "media",
      "url",
      "drive",
      "dropbox"
    ],
    group: "Media"
  }), t;
}
function Gr(n, t) {
  return n.filter(
    ({ title: e, aliases: o }) => e.toLowerCase().startsWith(t.toLowerCase()) || o && o.filter(
      (r) => r.toLowerCase().startsWith(t.toLowerCase())
    ).length !== 0
  );
}
function mt(n = "") {
  return typeof n == "string" ? [
    {
      type: "text",
      text: n,
      styles: {}
    }
  ] : n;
}
function pe(n) {
  return typeof n == "string" ? mt(n) : Array.isArray(n) ? n.flatMap((t) => typeof t == "string" ? mt(t) : Gt(t) ? {
    ...t,
    content: mt(t.content)
  } : Q(t) ? t : {
    props: {},
    ...t,
    content: pe(t.content)
  }) : n;
}
function jr(n, t) {
  return t.map(
    (e) => he(n, e)
  );
}
function he(n, t) {
  const e = {
    id: "",
    type: t.type,
    props: {},
    content: n[t.type].content === "inline" ? [] : void 0,
    children: [],
    ...t
  };
  return Object.entries(n[t.type].propSchema).forEach(
    ([o, r]) => {
      e.props[o] === void 0 && (e.props[o] = r.default);
    }
  ), {
    ...e,
    content: pe(e.content),
    children: e.children.map((o) => he(n, o))
  };
}
function tr(n) {
  n.id || (n.id = Z.options.generateID()), n.children && er(n.children);
}
function er(n) {
  for (const t of n)
    tr(t);
}
export {
  ue as BlockNoteEditor,
  Tt as BlockNoteSchema,
  uo as FormattingToolbarProsemirrorPlugin,
  lo as FormattingToolbarView,
  xo as ImagePanelProsemirrorPlugin,
  Co as ImagePanelView,
  mo as LinkToolbarProsemirrorPlugin,
  So as SideMenuProsemirrorPlugin,
  vo as SideMenuView,
  bo as SuggestionMenuProseMirrorPlugin,
  Io as TableHandlesProsemirrorPlugin,
  Lo as TableHandlesView,
  Z as UniqueID,
  A as UnreachableCaseError,
  tr as addIdsToBlock,
  er as addIdsToBlocks,
  pn as addInlineContentAttributes,
  hn as addInlineContentKeyboardShortcuts,
  kn as addStyleAttributes,
  D as blockToNode,
  st as camelToDataKebab,
  Vr as checkBlockHasDefaultProp,
  zr as checkBlockIsDefaultType,
  qn as checkBlockTypeHasDefaultProp,
  I as checkDefaultBlockTypeInSchema,
  vt as contentNodeToInlineContent,
  un as createBlockSpec,
  et as createBlockSpecFromStronglyTypedTiptapNode,
  lt as createExternalHTMLExporter,
  Or as createInlineContentSpec,
  fn as createInlineContentSpecFromTipTapNode,
  Zt as createInternalBlockSpec,
  Xt as createInternalHTMLSerializer,
  mn as createInternalInlineContentSpec,
  ne as createInternalStyleSpec,
  q as createStronglyTypedTiptapNode,
  _r as createStyleSpec,
  _ as createStyleSpecFromTipTapMark,
  Fr as createSuggestionMenu,
  Wn as defaultBlockSchema,
  re as defaultBlockSpecs,
  Rr as defaultInlineContentSchema,
  se as defaultInlineContentSpecs,
  w as defaultProps,
  Ur as defaultStyleSchema,
  ie as defaultStyleSpecs,
  Gr as filterSuggestionItems,
  F as formatKeyboardShortcut,
  co as formattingToolbarPluginKey,
  cn as getBlockFromPos,
  Ko as getBlockNoteExtensions,
  te as getBlockSchemaFromSpecs,
  $r as getDefaultSlashMenuItems,
  xt as getDraggableBlockFromCoords,
  gn as getInlineContentParseRules,
  ee as getInlineContentSchemaFromSpecs,
  dn as getParseRules,
  yn as getStyleParseRules,
  oe as getStyleSchemaFromSpecs,
  Yt as inheritedProps,
  at as inlineContentToNodes,
  P as insertOrUpdateBlock,
  ln as isAppleOS,
  It as isLinkInlineContent,
  Gt as isPartialLinkInlineContent,
  Dr as isSafari,
  Q as isStyledTextInlineContent,
  ho as linkToolbarPluginKey,
  z as mergeCSSClasses,
  y as nodeToBlock,
  qt as nodeToCustomInlineContent,
  he as partialBlockToBlockForTesting,
  jr as partialBlocksToBlocksForTesting,
  Qt as propsToAttributes,
  Eo as sideMenuPluginKey,
  bn as stylePropsToAttributes,
  R as suggestionMenuPluginKey,
  jt as tableContentToNodes,
  Y as tableHandlesPluginKey,
  Hr as uploadToTmpFilesDotOrg_DEV_ONLY,
  pt as wrapInBlockStructure
};
//# sourceMappingURL=blocknote.js.map
